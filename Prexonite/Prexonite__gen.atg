//-- GENERATED BY PxCoco -merge --//
//-- make sure to modify the source files instead of this one! --//

#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Header.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

//A comment
using System.IO;
using Prexonite;
using System.Collections.Generic;
using FatalError = Prexonite.Compiler.FatalCompilerException;
using StringBuilder = System.Text.StringBuilder;
using Prexonite.Compiler.Ast;
using Prexonite.Types;

COMPILER Prexonite

/*-- Global scope --*/



#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Scanner.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*---- SCANNER ------*/
/* Interface version */

IGNORECASE
	
TOKENS
		//Basic token
		id
		anyId
		lid
        ns
		
  /*--------------------------------------------------------------------------------*/
        integer
  /*--------------------------------------------------------------------------------*/
        real
  /*--------------------------------------------------------------------------------*/
        string
        
  /*--------------------------------------------------------------------------------*/
    bitAnd // &
	assign // =
	comma  // ,
	dec    // --
	div    // /
	dot    // .
	eq     // ==
	gt     // >
	ge     // >=
	inc    // ++
	lbrace // {
	lbrack // [
	lpar   // (
	lt     // <
	le     // <=
	minus  // -
	ne     // !=
	bitOr  // |
	plus   // +
	pow    // ^
	rbrace // }
    rbrack // ]
    rpar   // )
    tilde  // ~
    times  // *
    semicolon // ;
	colon  // :
	doublecolon // ::
	coalescence	//??
	question // ?
	pointer// ->
	implementation // =>
	at     // @
	appendleft // <<
	appendright // >>
	

    //Handled by the scanner:
    var
    ref
    true
	false

    //Handled by keyword check
    BEGINKEYWORDS
    mod
	is
	as
	not
	enabled
	disabled
	function
	command	
	asm	
	declare
	build
	return
	in
	to
	add
	continue
	break
	yield
	or
	and
	xor
	label
	goto
	static	
	null	
	if
	unless
	else
	new
	coroutine
	from
	do
	does
	while
	until
	for
	foreach
	try
	catch
	finally
	throw
	uusing //Coco/R does not accept "using" as a token name.
	ENDKEYWORDS
	
    //SPECIAL
    LPopExpr //has no textual representation.

IGNORE '\r' + '\n' + '\t'

/*------------------------------*/
/*---- Parser ------------------*/
PRODUCTIONS
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Parser.Assembler.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/* ---- Assembler Language ---- */

AsmStatementBlock<AstBlock block>
=
	lbrace
	{
	    AsmInstruction<block>        
	}
	rbrace
|   AsmInstruction<block> semicolon     
.

AsmInstruction<AstBlock block>          (.  int arguments = 0;
                                            string id = null;
                                            double dblArg = 0.0;
                                            string insbase = null; string detail = null;
                                            bool bolArg = false;
                                            OpCode code;
                                            bool justEffect = false;
                                            int values = 0;
                                            int rotations = 0;
                                            int index = 0;
                                        .)
=
    //VARIABLE DECLARATION              
                                        (. SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
    ( var | ref                         (. kind = SymbolInterpretations.LocalReferenceVariable; .)
    )
    AsmId<out id>
                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            target.Symbols.Add(id, new SymbolEntry(kind, id));
                                        .)
    {   comma
        AsmId<out id>                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            target.Symbols.Add(id, new SymbolEntry(kind, id));
                                        .)
    }
|   //NULL INSTRUCTIONS
    IF(isInNullGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code));
                                        .)
                                        
|   //LABEL
    IF( isAsmInstruction("label",null) )
    AsmId<out insbase>
    
    //Enter label
    AsmId<out id>
                                        (. addLabel(block, id); .)
|   //NOP/DATA INSTRUCTION
    IF(isAsmInstruction("nop", null))
    AsmId<out insbase>                  (.  Instruction ins = new Instruction(OpCode.nop); .)
    [  plus AsmId<out id>               (.  ins.Id = id; .)
    ]
                                        (.  addInstruction(block, ins); .)
    
|   //ROTATE INSTRUCTION
    IF(isAsmInstruction("rot", null))
    AsmId<out insbase>
    dot Integer<out rotations>
    comma Integer<out values>    
                                        //Create rot instruction
                                        (.  addInstruction(block, Instruction.CreateRotate(rotations, values)); .)
   
|	//INDIRECT LOCAL CALL BY INDEX
	IF(isAsmInstruction("indloci", null))
	AsmId<out insbase>
	dot Integer<out arguments>
	Integer<out index>
										//Create indloci instruction
										(.	addInstruction(block, Instruction.CreateIndLocI(index, arguments)); .)    
|   //EXCHANGE INSTRUCTION
    IF(isAsmInstruction("swap", null))
    AsmId<out insbase>
                                        (.  addInstruction(block, Instruction.CreateExchange()); .)
   
    
|   //LOAD CONSTANT . REAL
    IF(isAsmInstruction("ldc", "real"))
    AsmId<out insbase>
    dot
    AsmId<out detail>    
    SignedReal<out dblArg>                    
                                        (.  addInstruction(block, Instruction.CreateConstant(dblArg)); .)
    

|   //LOAD CONSTANT . BOOL    
    IF(isAsmInstruction("ldc", "bool"))
    AsmId<out insbase>
    dot
    AsmId<out detail>
    Boolean<out bolArg>     
                                        (.  addInstruction(block, Instruction.CreateConstant(bolArg)); .)
    
    
|   //INTEGER INSTRUCTIONS
    IF(isInIntegerGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    SignedInteger<out arguments>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments));
                                        .)
                                        
|   //JUMP INSTRUCTIONS
    IF(isInJumpGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  Instruction ins = null;
                                            code = getOpCode(insbase, detail);
                                        .)
    //Symbolic:
    (   AsmId<out id>
                                        (.  
                                            ins = new Instruction(code, -1, id);
                                        .)
    |   Integer<out arguments>          (.  ins = new Instruction(code, arguments); .)
    )                                   (.  addInstruction(block, ins); .)
    

|   //ID INSTRUCTIONS
    IF(isInIdGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    AsmId<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, id));
                                        .)
    

|   //ID+ARG INSTRUCTIONS
    IF(isInIdArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmId<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)
 
 |   //ARG INSTRUCTIONS
    IF(isInArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, null, justEffect));
                                        .)   

|   //QUALID+ARG INSTRUCTIONS
    IF(isInQualidArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmQualid<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)

|   //ERROR PRODUCTION: INVALID INSTRUCTION
    AsmId<out insbase>                  (.  SemErr("Invalid assembler instruction \"" + insbase + "\" (" + t + ")."); .)
        
.

AsmId<out string id>        (.  id = "\\NoId\\"; .)
=
    String<out id>
|   Id<out id>
|   (   mod
    |   is
    |   not
    //  enabled
    //  disabled
    //  build
    |   return
    |   in
    |   to
    //  add
    |   continue
    |   break
    |   or
    |   and
    |   xor
    |   goto
    |   null
    |   else
    |   if
    |   unless
    |   new
    |   while
    |   until
    |   for
    //   in
    |   foreach
    |   command
    |   as
    |	try
    |	throw
    )                       (.  id = cache(t.val); .)
.

AsmQualid<out string qualid>
                            (.   .)
=
    AsmId<out qualid>
.
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Parser.Expression.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */



Expr<out IAstExpression expr>
										(.	AstGetSet complex = null; .)
=
	KeyValuePairExpr<out expr>
	{	
		appendright
		GetCall<out complex>		    (.	complex.Arguments.RightAppend(expr); 
										    complex.Arguments.ReleaseRightAppend();
										    if(complex is AstGetSetSymbol && ((AstGetSetSymbol)complex).IsVariable)
										        complex.Call = PCall.Set;
										    expr = complex;										    
									    .)
	}
.

KeyValuePairExpr<out IAstExpression expr>
=
	AtomicExpr<out expr>
	[	colon							(.	IAstExpression value; .)
		Expr<out value>					(.	expr = new AstKeyValuePair(this, expr, value); .)
	]
.

AtomicExpr<out IAstExpression expr>		(.	AstConditionalExpression cexpr = null; expr = null; .)
=	
	OrExpr<out expr>
    {
        question                        (.  cexpr = new AstConditionalExpression(this, expr); .)
        AtomicExpr<out cexpr.IfExpression>
        colon
        AtomicExpr<out cexpr.ElseExpression>  (.  expr = cexpr; .)
    }    
|										(.	bool isNegated = false; .)
	(	if
	|	unless							(.	isNegated = true; .)
	)
	lpar OrExpr<out expr> rpar			(.	cexpr = new AstConditionalExpression(this, expr, isNegated); .)
	AtomicExpr<out cexpr.IfExpression>
    else
    AtomicExpr<out cexpr.ElseExpression>(.  expr = cexpr; .)
.

OrExpr<out IAstExpression expr>
										(. IAstExpression lhs, rhs; .)
=
	AndExpr<out lhs>                    (.  expr = lhs; .)
    [   or OrExpr<out rhs>              (.  expr = new AstLogicalOr(this, lhs, rhs); .)
    ]

.

AndExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitOrExpr<out lhs>                  (.  expr = lhs; .)
    [   and AndExpr<out rhs>            (.  expr = new AstLogicalAnd(this, lhs, rhs); .)
    ]
.

BitOrExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitXorExpr<out lhs>                 (. expr = lhs; .)
    { bitAnd BitXorExpr<out rhs>        (. expr = new AstBinaryOperator(this, expr, BinaryOperator.BitwiseOr, rhs); .)
    }
.

BitXorExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    BitAndExpr<out lhs>                 (.  expr = lhs; .)
    {   xor BitAndExpr<out rhs>
                                        (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.ExclusiveOr, rhs); .)
    }
.

BitAndExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    NotExpr<out lhs>                    (.  expr = lhs; .)
    {   bitAnd NotExpr<out rhs>
                                        (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.BitwiseAnd, rhs); .)
    }
.

NotExpr<out IAstExpression expr>
                                        (. IAstExpression lhs; bool isNot = false; .)
=
    [   not                             (.  isNot = true; .)
    ]
    EqlExpr<out lhs>                    (.  expr = isNot ? new AstUnaryOperator(this, UnaryOperator.LogicalNot, lhs) : lhs; .)
.

EqlExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    RelExpr<out lhs>                    (. expr = lhs; .)
    {   (   eq                          (.  op = BinaryOperator.Equality; .)
        |   ne                          (.  op = BinaryOperator.Inequality; .)    
        ) RelExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

RelExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None;  .)
=
    CoalExpr<out lhs>                   (.  expr = lhs; .)
    {   (   lt                          (.  op = BinaryOperator.LessThan;              .)
        |   le                          (.  op = BinaryOperator.LessThanOrEqual;       .)
        |   gt                          (.  op = BinaryOperator.GreaterThan;           .)
        |   ge                          (.  op = BinaryOperator.GreaterThanOrEqual;    .)
        ) CoalExpr<out rhs>             (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

CoalExpr<out IAstExpression expr>
										(.	IAstExpression lhs, rhs; AstCoalescence coal = new AstCoalescence(this); .)
=
	AddExpr<out lhs>					(.	expr = lhs; coal.Expressions.Add(lhs); .)
	{
		coalescence
		AddExpr<out rhs>				(.	expr = coal; coal.Expressions.Add(rhs); .)
	}
.										

AddExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs,rhs; BinaryOperator op = BinaryOperator.None; .)
=
    MulExpr<out lhs>                    (.  expr = lhs; .)
    {   (   plus                        (.  op = BinaryOperator.Addition;      .)
        |   minus                       (.  op = BinaryOperator.Subtraction;   .) 
        ) MulExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

MulExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    PowExpr<out lhs>                    (.  expr = lhs; .)
    {   (   times                       (.  op = BinaryOperator.Multiply;      .)
        |   div                         (.  op = BinaryOperator.Division;        .)
        |   mod                         (.  op = BinaryOperator.Modulus;       .)
        ) PowExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

PowExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    AssignExpr<out lhs>                  (.  expr = lhs; .)
    {   pow AssignExpr<out rhs>          (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.Power, rhs); .)
    }
.

AssignExpr<out IAstExpression expr>     (.  AstGetSet assignment; BinaryOperator setModifier = BinaryOperator.None;
                                            IAstType T;
                                        .)
=
    PostfixUnaryExpr<out expr>
    (IF(isAssignmentOperator())
                                       (.  assignment = expr as AstGetSet;
                                            if(assignment == null) 
                                            {
                                                SemErr(string.Format("Cannot assign to a {0}",
                                                    expr.GetType().Name));
                                                assignment = new AstGetSetSymbol(this, PCall.Get, "SEMANTIC_ERROR",
                                                    SymbolInterpretations.LocalObjectVariable); //to prevent null references
                                            }
                                            assignment.Call = PCall.Set;
                                        .)
        (
            (   assign                  (.  setModifier = BinaryOperator.None; .)
	        |   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	        |   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	        |   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	        |   div assign              (.  setModifier = BinaryOperator.Division; .)
	        |   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	        |   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	        |	coalescence assign		(.	setModifier = BinaryOperator.Coalescence; .)
	        )   Expr<out expr>        //(.  expr = expr; .)
	        
	    |   (   tilde  assign           (.  setModifier = BinaryOperator.Cast; .)
	        )TypeExpr<out T>            (.  expr = T; .)
	    )                               
	                                    (.  assignment.Arguments.Add(expr); 
	                                        assignment.SetModifier = setModifier;
                                            expr = assignment;
                                        .)        
    |)
.

PostfixUnaryExpr<out IAstExpression expr>
                                        (.  IAstType type = null; AstGetSet extension; .)
=
    PrefixUnaryExpr<out expr>   
    {   tilde TypeExpr<out type>        (.  expr = new AstTypecast(this, expr, type); .)
    |   is TypeExpr<out type>           (.  expr = new AstTypecheck(this, expr, type); .)
    |   inc                             (.  expr = new AstUnaryOperator(this, UnaryOperator.PostIncrement, expr); .)
    |   dec                             (.  expr = new AstUnaryOperator(this, UnaryOperator.PostDecrement, expr); .)
    |   GetSetExtension<expr, out extension>
                                        (.  expr = extension; .)
    }
.

PrefixUnaryExpr<out IAstExpression expr>
                                        (.  UnaryOperator op = UnaryOperator.None; .)
=
    {   plus
    |   minus                           (.  op = UnaryOperator.UnaryNegation; .)
    |   inc                             (.  op = UnaryOperator.PreIncrement; .)
    |   dec                             (.  op = UnaryOperator.PreDecrement; .)
    }    
    Primary<out expr>                   (.  if(op != UnaryOperator.None) expr = new AstUnaryOperator(this, op, expr); .)
.

Primary<out IAstExpression expr>
                                        (.  expr = null;
                                            AstGetSet complex = null; bool declared; .)
=
	(.  _pushLexerState(Lexer.Asm); .)	(.	AstBlockExpression blockExpr = new AstBlockExpression(this); .)
    asm lpar { AsmInstruction<blockExpr> } rpar
    (.  _popLexerState(); .)			(.	expr = blockExpr; .)
|   Constant<out expr>
|   CoroutineCreation<out expr>
|   ObjectCreation<out expr>
|   ListLiteral<out expr>
|	HashLiteral<out expr>
|	LoopExpr<out expr>
|	(. AstThrow th; .)
	ThrowExpression<out th>				(. expr = th; .)
|   IF(isLambdaExpression())
    LambdaExpression<out expr>
|
    (   lpar Expr<out expr> rpar
    |   GetInitiator<out complex, out declared>
                                        (.  expr = complex; .)
    )
|   LPopExpr lpar Expr<out expr>        (.  //This is a hack that makes string interpolation with expressions possible
                                            //The non-verbal token "LPopExpr" (has no character representation) is 
                                            //returned by the lexer if the parser has to treat an expression in a special
                                            //way. This includes notifying the parser when the expression has been parsed, as
                                            //well as injecting the necessary plus operator.
                                            _popLexerState(); _inject(_plus); .)
    rpar
.

Constant<out IAstExpression expr>
                                        (.  expr = null; int vi; double vr; bool vb; string vs; .)
=
        Integer<out vi>                 (.  expr = new AstConstant(this, vi); .)
    |   Real<out vr>                    (.  expr = new AstConstant(this, vr); .)
    |   Boolean<out vb>                 (.  expr = new AstConstant(this, vb); .)
    |   String<out vs>                  (.  expr = new AstConstant(this, vs); .)
    |   Null							(.  expr = new AstConstant(this, null); .)
.

ListLiteral<out IAstExpression expr>
                                        (.  IAstExpression iexpr = null; 
                                            AstListLiteral lst = new AstListLiteral(this);
                                            expr = lst;
                                        .)
=
    lbrack
    [   Expr<out iexpr>                 (.  lst.Elements.Add(iexpr); .)
        {   comma
            Expr<out iexpr>             (.  lst.Elements.Add(iexpr); .)
        }
    ]
    rbrack
.

HashLiteral<out IAstExpression expr>
										(.	IAstExpression iexpr = null; 
											AstHashLiteral hash = new AstHashLiteral(this);
											expr = hash;
										.)
=
	lbrace
	[	Expr<out iexpr>					(.	hash.Elements.Add(iexpr); .)
		{	comma
			Expr<out iexpr>				(.	hash.Elements.Add(iexpr); .)
		}
	]
	rbrace
.

LoopExpr<out IAstExpression expr>
										(.	AstBlock dummyBlock = new AstBlock(this);
										.)
=
	(	WhileLoop<dummyBlock>
	|	ForLoop<dummyBlock>
	|	ForeachLoop<dummyBlock>
	)									(.	expr = new AstLoopExpression(this, (AstLoop) dummyBlock.Statements[0]); .)
.										
											

ObjectCreation<out IAstExpression expr>
                                        (.  IAstType type; expr = null; .)
=
    new TypeExpr<out type>              (.  AstObjectCreation creation = new AstObjectCreation(this, type); .)
    Arguments<creation.Arguments>       (.  expr = creation; .)
.

CoroutineCreation<out IAstExpression expr>
                                        (.  
                                            AstCreateCoroutine cor = new AstCreateCoroutine(this); 
                                            IAstExpression iexpr;
                                            expr = cor;
                                        .)
=
    coroutine Expr<out iexpr>           (.  cor.Expression = iexpr; .)
    [ for Arguments<cor.Arguments> ]
.

LambdaExpression<out IAstExpression expr>
                                        (.  expr = null;
                                            PFunction func = new PFunction(TargetApplication, generateNestedFunctionId());                                             
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta["ParentFunction"] = target.Function.Id;
                                            TargetApplication.Functions.Add(func);
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            CompilerTarget ft = FunctionTargets[func];
                                            ft.ParentTarget = target;
                                        .)
=
(   FormalArg<ft>
|   lpar
    [	FormalArg<ft> 
	    {	comma
		    FormalArg<ft>
	    }
    ]
    rpar
)
                                        (.
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
implementation                                        
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)
                                        (.
                                            target = oldTarget;
                                            if(errors.count == 0)
                                            {
                                                Ast[func].EmitCode(FunctionTargets[func]);
                                                FunctionTargets[func].FinishTarget();
                                            }
                                            
                                            expr = new AstCreateClosure(this, func.Id);                                         
                                        .)
.

ThrowExpression<out AstThrow th>		(.  th = new AstThrow(this); .)
=
    throw
    Expr<out th.Expression>
.

ExplicitTypeExpr<out IAstType type>     (.  type = null; .)
=
    tilde PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

TypeExpr<out IAstType type>             (.  type = null; .)
=
    PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

ClrTypeExpr<out IAstType type>          
                                        (.  string id; .)
=
                                        (.  StringBuilder typeId = new StringBuilder(); .)
    (   doublecolon
    |   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    )
    {   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    }
    Id<out id>                          (.  typeId.Append(id);
                                            type = new AstConstantTypeExpression(this, 
                                                "Object(\"" + StringPType.Escape(typeId.ToString()) + "\")");
                                        .)
.

PrexoniteTypeExpr<out IAstType type>
                                        (.  string id = null; type = null; .)
=
    ( Id<out id> | null                 (.  id = NullPType.Literal; .)                          
    )
                                        (.  AstDynamicTypeExpression dType = new AstDynamicTypeExpression(this, id); .)
    [   lt
        [   TypeExprElement<dType.Arguments>   
            { comma TypeExprElement<dType.Arguments> }
        ]
        gt
    ]
                                        (.  type = dType; .)
.

TypeExprElement<. List<IAstExpression> args .>
                                        (.  IAstExpression expr; IAstType type; .)
=
    Constant<out expr>                  (.  args.Add(expr); .)
|   ExplicitTypeExpr<out type>          (.  args.Add(type); .)
|   lpar Expr<out expr> rpar            (.  args.Add(expr); .)
.
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Parser.GlobalScope.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite	
                            (.  PFunction func; .)				
=
    {	[   GlobalVariableDefinition
        |   Declaration
        |   MetaAssignment<TargetApplication>
        ]   SYNC semicolon
    |	GlobalCode
    |   BuildBlock
    |	FunctionDefinition<out func>
    }
    EOF
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable target>	(. string key = null; MetaEntry entry = null; .)
=
(	is  					(. entry = true; .)
	[not					(. entry = false; .)
	]
	GlobalId<out key>
|
	GlobalId<out key>
	( enabled				(. entry = true; .)
	| disabled  			(. entry = false; .)
	| MetaExpr<out entry>
	)
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(target.Meta.ContainsKey(key))
                                {
                                    entry = target.Meta[key];
                                    entry.AddToList(subEntry.List);
                                }else
                                    entry = subEntry;
                            .)
)							(. if(entry == null || key == null) SemErr("Meta assignment did not generate an entry."); else target.Meta[key] = entry; .)	
.

MetaExpr<out MetaEntry entry>
							(. bool sw; int i; double r; entry = null; string str; .)
=							
	Boolean<out sw>			(. entry = sw; .)
|	Integer<out i>			(. entry = i.ToString(); .)
|	Real<out r>				(. entry = r.ToString(); .)
|   String<out str>         (. entry = str; .)
|   GlobalQualifiedId<out str>       (. entry = str; .)
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); MetaEntry subEntry; .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   WEAK comma
            MetaExpr<out subEntry> (. lst.Add(subEntry); .)
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition	(.  string id; PVariable vari; SymbolInterpretations type = SymbolInterpretations.GlobalObjectVariable;; .)
=
SYNC
	(   var                 
	|   ref                 (.  type = SymbolInterpretations.GlobalReferenceVariable; .)
	)
	
	GlobalId<out id>        (.
	                            Symbols[id] = new SymbolEntry(type, id);
	                            if(TargetApplication.Variables.ContainsKey(id))
	                                vari = TargetApplication.Variables[id];
	                            else
	                            {
	                                vari = new PVariable(id);
	                                TargetApplication.Variables[id] = vari;
	                            }
	                        .)
	[	lbrack  		    //Meta block for variables
		{	MetaAssignment<vari> SYNC semicolon
		}
		rbrack
	]
	[	                    (.  _pushLexerState(Lexer.Local); .)
	    assign              (.  CompilerTarget lastTarget = target;
                                target=FunctionTargets[Application.InitializationId];
                                IAstExpression expr;
                            .)
		Expr<out expr>
		                    (.  _popLexerState();
								if(errors.count == 0)
								{
									AstGetSet complex = new AstGetSetSymbol(this, PCall.Set, id, InterpretAsObjectVariable(type));
									complex.Arguments.Add(expr);
									target.Ast.Add(complex);
									vari.Meta[Application.InitializationId] = TargetApplication._RegisterInitializationUpdate().ToString();
									Loader._EmitPartialInitializationCode();
		                        }
		                        target = lastTarget;
		                    .)
	]
.

/* ---- Global declaration ---- */

Declaration
                            (. SymbolInterpretations type = SymbolInterpretations.Undefined; .)
=
SYNC
	declare
	[	var 		        (. type = SymbolInterpretations.GlobalObjectVariable; .)
	|   ref                 (. type = SymbolInterpretations.GlobalReferenceVariable; .)
	|	function			(. type = SymbolInterpretations.Function; .)
	|   command             (. type = SymbolInterpretations.Command; .)
	]
	DeclarationInstance<type>
	{WEAK comma DeclarationInstance<type>}
.
	
DeclarationInstance<SymbolInterpretations type>
                            (.  string id; string aId; .)
=			
	Id<out id>              (.  aId = id; .)
	[ as Id<out aId> ]
	                        (.  SymbolEntry inferredType;
	                            if(target == null) //global symbol
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                            else
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(target.Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(target.Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                target.Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                        .)
.

/* ---- Build Block ---- */

BuildBlock
=
	SYNC build                  (.  PFunction func = new PFunction(TargetApplication);
                                    CompilerTarget lastTarget = target; 
                                    target = Loader.CreateFunctionTarget(func, new AstBlock(this));
                                    target.Declare(SymbolInterpretations.Command, "Add", Loader.BuildAddCommand);
                                    target.Declare(SymbolInterpretations.Command, "Require", Loader.BuildRequireCommand);
                                    target.Declare(SymbolInterpretations.Command, "Default", Loader.BuildDefaultCommand);
                                    target.Declare(SymbolInterpretations.Command, "Hook", Loader.BuildHookCommand);
                                    target.Declare(SymbolInterpretations.Command, "GetLoader", Loader.BuildGetLoaderCommand);
                                    _pushLexerState(Lexer.Local);                                
                                .)
	
	[ does ]	
	StatementBlock<target.Ast>
	
                                (.  
	                                _popLexerState();
                                    if(errors.count > 0)
                                    {
                                        SemErr("Cannot execute build block. Errors detected");
                                        return;
                                    }
                                    
                                    target.Ast.EmitCode(target);
                                    target.FinishTarget();	                                
                                    target = lastTarget;
                                    //Run the build block 
                                    FunctionContext fctx = func.CreateFunctionContext(ParentEngine, new PValue[] {}, new PVariable[] {}, true);
                                    
                                    try
                                    {
                                        TargetApplication._SuppressInitialization = true;
                                        Loader.BuildCommandsEnabled = true;
                                        ParentEngine.Process(fctx);
                                    }
                                    finally
                                    {
                                        Loader.BuildCommandsEnabled = false;
                                        TargetApplication._SuppressInitialization = false;
                                    }
	                            .)
.

/* ---- Global Code ---- */

GlobalCode							(.
										PFunction func = TargetApplication._InitializationFunction;
										CompilerTarget ft = FunctionTargets[func];
									.)
=
									(.	
										target = ft; 
                                        _pushLexerState(Lexer.Local);
                                    .)
	lbrace 
	{ Statement<target.Ast> } 
	rbrace
									(.
										if(errors.count == 0)
										{
											TargetApplication._RequireInitialization();
											Loader._EmitPartialInitializationCode();
										}
										target = null;
										_popLexerState();
									.)
.

/* ---- Function definition ---- */

FunctionDefinition<out PFunction func>
                                    (.  
                                        func = null; 
                                        string id;     
                                        string funcId; 
                                        func = null; 
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        PFunction corBody = null;
                                        PFunction corStub = null;
                                        string corId = null;
                                        CompilerTarget ct = null;
                                        CompilerTarget cst = null;
                                    .)         
=	
	(   function
	|   coroutine                   (.  isCoroutine = true;
	                                .)
	)
	Id<out id>                      (.  funcId = id;
                                        if(Engine.StringsAreEqual(id, @"\init"))
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                SemErr("Cannot define initialization code inside another function.");
                                            if(isCoroutine)
                                                SemErr("Cannot define initialization code as a coroutine.");
                                        }
                                        else
                                        {
                                            if(isNested)
                                            {
                                                funcId = generateNestedFunctionId(id);
                                                SmartDeclareLocal(id, SymbolInterpretations.LocalReferenceVariable);
                                            }
                                            
                                            func = new PFunction(TargetApplication, funcId);
                                            
                                            if(isNested)
                                                 func.Meta["LogicalId"] = id;
                                            
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            TargetApplication.Functions.Add(func);
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        if(isCoroutine)
                                        {
                                            corStub = func;
                                            
                                            //Create coroutine body function
                                            corId = generateNestedFunctionId(ft);                                            
                                            corBody = new PFunction(TargetApplication, corId);
                                            Loader.CreateFunctionTarget(corBody, new AstBlock(this));
                                            TargetApplication.Functions.Add(corBody);
                                            corBody.Meta["LogicalId"] = id;

                                            //Get compiler target references
                                            ct = FunctionTargets[corBody];
                                            cst = ft;
                                            ct.ParentTarget = cst;
                                        }
                                        if(target != null) //Link to parent in case of a nested function
                                            ft.ParentTarget = target;	                                           
	                                    
	                                .)
    [   lpar
	    [	FormalArg<ft> 
		    {	[comma]
			    FormalArg<ft>
		    }
	    ]
	    rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
	]	                            (.  if(target == null && 
	                                        (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)))
	                                    {
	                                            //Add the name to the symboltable
	                                            Symbols[func.Id] = new SymbolEntry(SymbolInterpretations.Function, func.Id);
	                                    }
	                                    //Target the coroutine body instead of the stub
                                        if(isCoroutine)
                                            func = corBody;
	                                .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        {   MetaAssignment<func> SYNC semicolon
        }
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  CompilerTarget lastTarget = target;
                                        target = FunctionTargets[func]; 
                                        _pushLexerState(Lexer.Local);
                                    .)
    (   [ does ]
        StatementBlock<target.Ast>
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        target = lastTarget; 
                                        //Compile AST
                                        if(errors.count == 0)
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                            }
                                            else
                                            {
												FunctionTargets[func].ExecuteCompilerHooks();
                                                Ast[func].EmitCode(FunctionTargets[func]);
                                                FunctionTargets[func].FinishTarget();
                                            }
                                            
                                        if(isCoroutine)
                                        {
                                            //Stub has to be returned
                                            func = corStub;
                                            //Generate code for the stub
                                            AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
                                            crcor.Expression = new AstCreateClosure(this,corBody.Id);
                                            AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
                                            retst.Expression = crcor;
                                            cst.Ast.Add(retst);
                                            cst.Ast.EmitCode(cst);
                                            cst.FinishTarget();
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
=
	[ var | ref                     (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
	]
	Id<out id>                      (.  ft.Function.Parameters.Add(id); 
	                                    ft.Symbols.Add(id, new SymbolEntry(kind, id));
	                                .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId                           (.  id = cache(t.val.Substring(1)); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   Ns<out id>                      (.  StringBuilder buffer = new StringBuilder(id); buffer.Append('.'); .)
    {   Ns<out id>                 (.  buffer.Append(id); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = buffer.ToString(); .)
.
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Parser.Helper.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Id<out string id>               (.  id = "\\NoId\\"; .) //<-- should never surface. this is for debugging purposes
=
    GlobalId<out id>
|   (   enabled
    |   disabled
    |   build
    |   add
    )                           (.  id = cache(t.val); .)
.

Ns<out string ns>               (. ns = "\\NoId\\"; .)
=
    ns                          (. ns = cache(t.val); .)
.

Boolean<out bool value>         (.  value = true; .)
=                   
	true          
|	false                       (.  value = false; .)
.

Integer<out int value>
=
	integer                     (.  if(!TryParseInteger(t.val, out value))
	                                    SemErr(t, "Cannot recognize integer " + t.val);
	                            .)
.

SignedInteger<out int value>    (. int modifier = 1; .)
=
    [   plus
    |   minus                   (. modifier = -1; .)
    ]   Integer<out value>      (. value = modifier * value; .)
.

Real<out double value>  
=
	real            
	/*
	[   e                       (.  real += "e"; .)
	    [   plus     
	    |   minus               (.  real += "-"; .)
	    ]
	    real                    (.   real += t.val; .)
	] */
	                            (.  string real = t.val;
	                                if(!TryParseReal(real, out value))
	                                    SemErr(t, "Cannot recognize real " + real);
	                            .)
.

SignedReal<out double value>    (. value = 0.0; double modifier = 1.0; int ival; .)
=
    [   plus
    |   minus                   (. modifier = -1.0; .)
    ]   ( Real<out value> 
        | Integer<out ival>     (. value = ival; .)
        )
                                (. value = modifier * value; .)
.

String<out string value>
=
    string                      (. value = cache(t.val); .)
.

Null = null .
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Parser.Statement.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

StatementBlock<AstBlock block>
=
	Statement<block>
.

Statement<AstBlock block>
=
(
		IF( isLabel() )
			ExplicitLabel<block>  
	|   [ SimpleStatement<block> ] semicolon
	|   StructureStatement<block>
)
{	and Statement<block> 
}
.

SimpleStatement<AstBlock block>
=
	ExplicitGoTo<block>
|   Declaration
|   IF ( isVariableDeclaration() ) 
        VariableDeclarationStatement
|   GetSetComplex<block>
|   Return<block>
|   Throw<block>
.

StructureStatement<AstBlock block>
=
    (.  _pushLexerState(Lexer.Asm); .)
    asm AsmStatementBlock<block>
    (.  _popLexerState(); .)
|   Condition<block>
|   WhileLoop<block>
|   ForLoop<block>
|   ForeachLoop<block>
|   NestedFunction<block>
|   TryCatchFinally<block>
|   Using<block>
|	lbrace
	{
		Statement<block>
	}
	rbrace
.

GetSetComplex<AstBlock block>
                                        (.  AstGetSet complex = null; 
                                            AstGetSetSymbol symbol = null;
                                            bool isDeclaration = false;
                                        .)
=
//GetSet Initiator
GetInitiator<out complex, out isDeclaration>

//GetSet Extensions
    {   GetSetExtension<complex, out complex>
    }
//GetSet Terminator
(
|   inc                                 (.  block.Add(new AstUnaryOperator(this, UnaryOperator.PostIncrement, complex));
                                            complex = null;
                                        .)
|   dec                                 (.  block.Add(new AstUnaryOperator(this, UnaryOperator.PostDecrement, complex));
                                            complex = null;
                                        .)
|   Assignment<complex>                 (.  symbol = complex as AstGetSetSymbol;
                                            if(symbol != null && InterpretationIsVariable(symbol.Interpretation) && isDeclaration)
                                                symbol.Interpretation = InterpretAsObjectVariable(symbol.Interpretation);
                                        .)
)
                                        (.  //Add the complex to the block
                                            if(complex != null)
                                                block.Add(complex);
                                        .)
.

GetSetExtension<IAstExpression subject, out AstGetSet extension>
                                        (.  extension = null; string id;
											if(subject == null)
											{
												SemErr("Member access not preceded by a proper expression.");
												subject = new AstConstant(this,null);
											}
                                        .)
                                        
=
    IF( isIndirectCall() )
    dot                                 (.  extension = new AstIndirectCall(this, PCall.Get, subject); .)
    Arguments<extension.Arguments>
|   dot
    Id<out id>                          (.  extension = new AstGetSetMemberAccess(this, PCall.Get, subject, id); .)
    Arguments<extension.Arguments> 
|                                       (.  
                                            IAstExpression expr; 
                                            extension = new AstGetSetMemberAccess(this, PCall.Get, subject, ""); 
                                        .)
    lbrack [
            Expr<out expr>              (.  extension.Arguments.Add(expr); .)  
            { WEAK comma Expr<out expr>   (.  extension.Arguments.Add(expr); .)
            }
        ]                                             
    rbrack                                                                      
.

GetInitiator<out AstGetSet complex, out bool isDeclaration>
                                        (.  complex = null; 
                                            AstGetSetSymbol symbol = null;
                                            AstGetSetStatic staticCall = null;
                                            AstGetSet member = null;
                                            IAstExpression expr = null;
                                            List<IAstExpression> args = new List<IAstExpression>();
                                            isDeclaration = false;                                            
                                            string id;
                                        .)
=
    //Actual value
    (   IF( isLikeFunction(la.val) ) 
        Function<out symbol>
    |   Variable<out symbol, out isDeclaration>
    |   StaticCall<out staticCall>
    |	lpar Expr<out expr>				(.	args.Add(expr); .)
		{	comma Expr<out expr>		(.	args.Add(expr); .)
		}
		rpar
		(	GetSetExtension<expr, out member>
										(.	if(args.Count > 1)
												SemErr("A member access cannot have multiple subjects. (Did you mean '>>'?)");
										.)
		|	appendright
			GetCall<out complex>		(.	complex.Arguments.RightAppend(args);
											complex.Arguments.ReleaseRightAppend();
											if(complex is AstGetSetSymbol && ((AstGetSetSymbol)complex).IsVariable)
										        complex.Call = PCall.Set;
											member = complex;
										.)
		)
    )
                                        (.  complex = 
												(AstGetSet)symbol ?? 
												(AstGetSet)staticCall ?? 
												(AstGetSet)member; 
										.)
    //Reference
|   IF( isDeDereference() )
    pointer pointer Id<out id>          (.  SymbolEntry s = target.Symbols[id];
                                            SymbolInterpretations kind;
                                            if(s == null)
                                            {   
                                                SemErr("The symbol " + id + " is not defined"); 
                                                s = new SymbolEntry(SymbolInterpretations.LocalObjectVariable, id);
                                                kind = s.Interpretation;
                                            }
                                            else
                                            {
                                                kind = s.Interpretation;
                                                if(s.Interpretation == SymbolInterpretations.LocalReferenceVariable)
                                                    kind = SymbolInterpretations.LocalObjectVariable;
                                                else if(s.Interpretation == SymbolInterpretations.GlobalReferenceVariable)
                                                    kind = SymbolInterpretations.GlobalObjectVariable;
                                                else
                                                    SemErr("Only reference variables can be dereferenced twice.");
                                            }
                                            complex = new AstGetSetReference(this, s.Id, kind);
                                        .)
|   pointer Id<out id>                  (.  SymbolEntry s = target.Symbols[id];
                                            if(s == null)
                                            {   
                                                SemErr("The symbol " + id + " is not defined"); 
                                                s = new SymbolEntry(SymbolInterpretations.LocalObjectVariable, id);
                                            }
                                            else if(InterpretationIsVariable(s.Interpretation))
                                            {
                                                if(isOuterVariable(id))
                                                    target.RequireOuterVariable(id);
                                            }
                                            complex = new AstGetSetReference(this, s.Id, s.Interpretation);
                                        .)
.

VariableDeclaration<out AstGetSetSymbol variable>
                                        (.  variable = null; string staticId = null; .)
=                                       (.  string id = null; SymbolInterpretations kind = SymbolInterpretations.Undefined; .)
(   (  var                              (.  kind = SymbolInterpretations.LocalObjectVariable; .)
    |  ref                              (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
    )
    
    Id<out id>                          (.  
                                            SmartDeclareLocal(id, kind);
                                            staticId = id; 
                                        .)
|   static                              (.  kind = SymbolInterpretations.GlobalObjectVariable; .)
    [   var
    |   ref                             (.  kind = SymbolInterpretations.GlobalReferenceVariable; .)
    ]
    Id<out id>                          (.  staticId = target.Function.Id + "\\static\\" + id;
                                            target.Declare(kind, id, staticId);
                                            if(!target.Loader.Options.TargetApplication.Variables.ContainsKey(staticId))
                                                target.Loader.Options.TargetApplication.Variables.Add(staticId, new PVariable(staticId));
                                        .)
)                                       (.  variable = InterpretationIsObjectVariable(kind) ?
												new AstGetSetSymbol(this, PCall.Get, staticId, kind)
											:
												new AstGetSetReference(this, PCall.Get, staticId, InterpretAsObjectVariable(kind)); .)
.

Variable<out AstGetSetSymbol variable, out bool isDeclared>
                                        (.  variable = null; string id; isDeclared = false; .)
=
    VariableDeclaration<out variable>   (. isDeclared = true; .)
|   Id<out id>                          (.  if(target.Symbols.ContainsKey(id))
                                            {
                                                SymbolEntry varSym = target.Symbols[id];
                                                if(InterpretationIsVariable(varSym.Interpretation))
                                                {
                                                    if(isOuterVariable(id))
                                                        target.RequireOuterVariable(id);
                                                    variable = new AstGetSetSymbol(this, varSym.Id, varSym.Interpretation);
                                                }
                                                else
                                                    SemErr(t.line, t.col, "Variable name expected");
                                            }
                                            else
                                            {
                                                SemErr(t.line, t.col, "Unkown symbol \"" + id + "\". Variable name expected.");
                                            }
                                        .)
.

VariableDeclarationStatement
=                                       (.  AstGetSetSymbol variable; .)
    VariableDeclaration<out variable>
                                        //No additional action is required. This is just a platform
                                        //  for variable declarations without assignment.
.

Function<out AstGetSetSymbol function>
                                (.  function = null; string id; .)
=
    Id<out id>                  (.  if(!target.Symbols.ContainsKey(id))
                                    {
                                        SemErr("There is no function-like symbol named " + id + ".");
                                        function = new AstGetSetSymbol(this, id, SymbolInterpretations.Function);
                                    }
                                    else
                                    {
                                        if(isOuterVariable(id))
                                            target.RequireOuterVariable(id);
                                        SymbolEntry sym = target.Symbols[id];
                                        function = new AstGetSetSymbol(this, sym.Id, sym.Interpretation);
                                    }
                                .)
    Arguments<function.Arguments>    
.

StaticCall<out AstGetSetStatic staticCall>
                                (.  IAstType typeExpr;
                                    string memberId;
                                    staticCall = null;
                                .)
=
    ExplicitTypeExpr<out typeExpr>
    dot Id<out memberId>        (.  staticCall = new AstGetSetStatic(this, PCall.Get, typeExpr, memberId); .)
    Arguments<staticCall.Arguments>
.

/*
StaticCall<out AstGetSetStatic staticCall>
                                (.  string id = "";
                                    System.Text.StringBuilder idBuilder = new System.Text.StringBuilder();
                                    bool staticPrefix = false;
                                .)
=

    [   doublecolon             (.  staticPrefix = true; .)
    ]   Ns<out id>              (.  idBuilder.Append(id); .)
    {   Ns<out id>              (.  idBuilder.Append("."+id); .)
    }
    Id<out id>                  (.  staticCall = createStaticCall(idBuilder.ToString(), id, staticPrefix); .)
    Arguments<staticCall.Arguments> 
. // */
                                    //Fallback in case of a syntax error to avoid NullReferenceExceptions
ExplicitLabel<AstBlock block>   (.  string id = "--\\NotAnId\\--"; .)
=
    (   Id<out id> colon
    |   lid                     (.  id = cache(t.val.Substring(0,t.val.Length-1)); .)
    )                           (.  block.Statements.Add(new AstExplicitLabel(this, id)); .)
.

ExplicitGoTo<AstBlock block>    (.  string id; .)
=
    goto
    Id<out id>                  (.  block.Statements.Add(new AstExplicitGoTo(this, id)); .)
.

Assignment<AstGetSet lvalue>
                                (.  IAstExpression expr = null;
									BinaryOperator setModifier = BinaryOperator.None;
									IAstType T;
								.)
=
(
	(   ( assign /*| appendleft*/ ) (.  setModifier = BinaryOperator.None; .)
	|   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	|   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	|   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	|   div assign              (.  setModifier = BinaryOperator.Division; .)
	|   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	|   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	|	coalescence assign		(.	setModifier = BinaryOperator.Coalescence; .)
	)   Expr<out expr>        //(.	expr = expr; .)
	
|	(	tilde assign			(.	setModifier = BinaryOperator.Cast; .)
	)	TypeExpr<out T>			(.	expr = T; .)
)								
								(.  lvalue.Arguments.Add(expr);
									lvalue.Call = PCall.Set; 
									lvalue.SetModifier = setModifier;
								.)
.

Condition<AstBlock block>
                                (. IAstExpression expr = null; bool isNegative = false; .)
=
    (   if                      (.  isNegative = false; .)
    |   unless                  (.  isNegative = true; .)
    )
    
    lpar Expr<out expr> rpar
                                (.  AstCondition cond = new AstCondition(this, expr, isNegative); .)
    
    StatementBlock<cond.IfBlock> 

    
    [   else StatementBlock<cond.ElseBlock> 

    ]                           (.  block.Add(cond); .)
.

WhileLoop<AstBlock block>
                                (.  AstWhileLoop loop = null;
                                    bool isPositive = true; 
                                .)
=
(   (   while  | until          (.  isPositive = false; .)    
    )                           (.  loop = new AstWhileLoop(this, true, isPositive); .)
    lpar Expr<out loop.Condition> rpar
                                (.  target.BeginBlock(loop.Labels); .)
    StatementBlock<loop.Block> 
|   do                          (.  AstBlock loopBody = new AstBlock(this); 
                                    BlockLabels labels = AstWhileLoop.CreateBlockLabels();
                                    target.BeginBlock(labels);
                                .)
    StatementBlock<loopBody>
    (   while  | until          (.  isPositive = false; .)    
    )                           (.  loop = new AstWhileLoop(this, false, isPositive); 
                                    loop.Labels = labels;
                                    loop.Block = loopBody;
                                .)
    lpar Expr<out loop.Condition> rpar
)                               (.  target.EndBlock(); block.Add(loop); .)
.

ForLoop<AstBlock block>         (.  AstForLoop loop;
                                .)
=
    for                         (.  loop = new AstForLoop(this); target.BeginBlock(loop.Labels); .)
    lpar StatementBlock<loop.Initialize>
    (
		do StatementBlock<loop.NextIteration> 
                                (.  loop.IsPrecondition = false; .)
        (   while
        |   until               (.  loop.IsPositive = false; .)
        )
        Expr<out loop.Condition>
    |   [   while
        |   until               (.  loop.IsPositive = false; .)
        ]       
        Expr<out loop.Condition> 
        semicolon
        SimpleStatement<loop.NextIteration>
    )
    rpar
    StatementBlock<loop.Block>  (.  target.EndBlock(); block.Add(loop); .) // */
.

ForeachLoop<AstBlock block>
=
    foreach                      (.  AstForeachLoop loop = new AstForeachLoop(this); .)
    lpar
    GetCall<out loop.Element> 
    in 
    Expr<out loop.List> 
    rpar
                                (.  target.BeginBlock(loop.Labels); .)
    StatementBlock<loop.Block>
                                (.  target.EndBlock(); .)
    
    
                                (.  block.Add(loop); .) 
.

GetCall<out AstGetSet complex>
                                (.  AstGetSet getMember = null; bool isDeclaration; .)
=
    GetInitiator<out complex, out isDeclaration>
    { GetSetExtension<complex, out getMember> }
    
                                (.  if(getMember != null) 
                                    {
                                        complex = getMember; 
                                    }
                                    else
                                    {
                                        AstGetSetSymbol symbol = complex as AstGetSetSymbol;
                                        if(symbol != null && InterpretationIsVariable(symbol.Interpretation) && isDeclaration)
                                        {
                                            symbol.Interpretation = InterpretAsObjectVariable(symbol.Interpretation);
                                            complex = symbol;
                                        }                                        
                                    } .)
.

Return<AstBlock block>          (.  AstReturn ret = null; 
                                    AstExplicitGoTo jump = null; 
                                    IAstExpression expr = null; 
                                    BlockLabels bl = target.CurrentBlock;
                                .)
=
(   
    (
        return                  (.  ret = new AstReturn(this, ReturnVariant.Exit); .)
    |   yield                   (.  ret = new AstReturn(this, ReturnVariant.Continue); .)
    )
    [   Expr<out expr>          (.  ret.Expression = expr; .)
    |   assign                  (.  ret.ReturnVariant = ReturnVariant.Set; .)
        Expr<out expr>          (.  ret.Expression = expr; .)
    ]
|   break                       (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Break); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.BreakLabel);
                                .)
|   continue                    (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Continue); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.ContinueLabel);
                                .)
)                               (.  block.Add((AstNode)ret ?? (AstNode)jump); .)
.

NestedFunction<AstBlock block>
                                (.  PFunction func; .)
=
    FunctionDefinition<out func>
                                (.  
                                    string logicalId = func.Meta["LogicalId"];
                                    func.Meta["ParentFunction"] = target.Function.Id;
                                    string physicalId = func.Id;
                                    
                                    AstGetSetSymbol setVar = new AstGetSetSymbol(this, PCall.Set, logicalId, SymbolInterpretations.LocalObjectVariable);
                                    setVar.Arguments.Add( new AstCreateClosure(this, physicalId) );
                                    block.Add(setVar);
                                .)
.

TryCatchFinally<AstBlock block>
                                (.  AstTryCatchFinally a = new AstTryCatchFinally(this); .)
=
    try
    lbrace
    {   Statement<a.TryBlock>
    }
    rbrace
    [	catch
		[   lpar
			GetCall<out a.ExceptionVar>
			rpar
		]
		lbrace
		{   Statement<a.CatchBlock>
		}
		rbrace		
	    
		[
			finally
			lbrace
			{   Statement<a.FinallyBlock>
			}
			rbrace
		]
		
	|	finally
		lbrace
		{   Statement<a.FinallyBlock>
		}
		rbrace
		
		[	catch
			[   lpar
				GetCall<out a.ExceptionVar>
				rpar
			]
			lbrace
			{   Statement<a.CatchBlock>
			}
			rbrace
		]
	]                       
                                (.  block.Add(a); .)
.

Throw<AstBlock block>
                                (.  AstThrow th; .)
=
	ThrowExpression<out th>
                                (.  block.Add(th); .)
.                                

Using<AstBlock block>
                                (.  AstUsing use = new AstUsing(this); .)
=
    uusing lpar GetCall<out use.Container> assign Expr<out use.Expression> rpar
    StatementBlock<use.Block>
                                (.  block.Add(use); .)
.

Arguments<ArgumentsProxy args>
                                (.  
									IAstExpression expr;
                                .)
=
	[
		lpar
		[	Expr<out expr>      (.  args.Add(expr); .)
			{	WEAK comma
				Expr<out expr>  (.  args.Add(expr); .)
			}
		]
		rpar
	]
								(.	args.RemeberRightAppendPosition(); .)
	[
		appendleft
		(
			lpar
			[	Expr<out expr>	(.  args.Add(expr); .)
				{	comma
					Expr<out expr>	
								(.  args.Add(expr); .)
				}
			]
			rpar
		|	Expr<out expr>		(.  args.Add(expr); .)
		)
	]
.
#file:F:\DotNetProjects\Prexonite\Prexonite\Compiler\Grammar\Footer.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

END Prexonite.#file:default#

/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite	
                            (.  PFunction func; .)				
=
    {	[   GlobalVariableDefinition
        |   Declaration
        |   MetaAssignment<TargetApplication>
        ]   SYNC semicolon
    |	GlobalCode
    |   BuildBlock
    |	FunctionDefinition<out func>
    }
    EOF
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable target>	(. string key = null; MetaEntry entry = null; .)
=
(	is  					(. entry = true; .)
	[not					(. entry = false; .)
	]
	GlobalId<out key>
|
	GlobalId<out key>
	( enabled				(. entry = true; .)
	| disabled  			(. entry = false; .)
	| MetaExpr<out entry>
	)
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(target.Meta.ContainsKey(key))
                                {
                                    entry = target.Meta[key];
                                    entry = entry.AddToList(subEntry.List);
                                }
                                else
                                {
                                   entry = subEntry;
                                }
                            .)
)							(. if(entry == null || key == null) 
                                    SemErr("Meta assignment did not generate an entry.");
                               else 
                                    target.Meta[key] = entry; 
                            .)	
.

MetaExpr<out MetaEntry entry>
							(. bool sw; int i; double r; entry = null; string str; .)
=							
	Boolean<out sw>			(. entry = sw; .)
|	Integer<out i>			(. entry = i.ToString(); .)
|	Real<out r>				(. entry = r.ToString(); .)
|   String<out str>         (. entry = str; .)
|   GlobalQualifiedId<out str>       (. entry = str; .)
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); MetaEntry subEntry; .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   WEAK comma
            MetaExpr<out subEntry> (. lst.Add(subEntry); .)
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition	(.  
                                string id = null; 
                                List<string> aliases = new List<string>();
                                PVariable vari; 
                                SymbolInterpretations type = SymbolInterpretations.GlobalObjectVariable; 
                            .)
=

	(   var                 
	|   ref                 (.  type = SymbolInterpretations.GlobalReferenceVariable; .)
	)
	
	(   GlobalId<out id>    (.  aliases.Add(id); .)
	    [ GlobalVariableAliasList<aliases> ]
	|   GlobalVariableAliasList<aliases>
	                        (.  id = Engine.GenerateName("v"); .)
	)
	                        (.
	                            foreach(var alias in aliases)
	                                Symbols[alias] = new SymbolEntry(type, id);
	                            if(TargetApplication.Variables.ContainsKey(id))
	                                vari = TargetApplication.Variables[id];
	                            else
	                            {
	                                vari = new PVariable(id);
	                                TargetApplication.Variables[id] = vari;
	                            }
	                        .)
	[	lbrack  		    //Meta block for variables
		{	MetaAssignment<vari> SYNC semicolon
		}
		rbrack
	]
	[	                    (.  _pushLexerState(Lexer.Local); .)
	    assign              (.  CompilerTarget lastTarget = target;
                                target=FunctionTargets[Application.InitializationId];
                                IAstExpression expr;
                            .)
		Expr<out expr>
		                    (.  _popLexerState();
								if(errors.count == 0)
								{
									AstGetSet complex = new AstGetSetSymbol(this, PCall.Set, id, InterpretAsObjectVariable(type));
									complex.Arguments.Add(expr);
									target.Ast.Add(complex);
									vari.Meta[Application.InitializationId] = TargetApplication._RegisterInitializationUpdate().ToString();
									Loader._EmitPartialInitializationCode();
		                        }
		                        target = lastTarget;
		                    .)
	]
.

GlobalVariableAliasList<. IList<string> aliases .>
                            (.  string id = "\\NoId_In_GlobalVariableAliasList_\\"; .)
=
    as GlobalId<out id>     (.  aliases.Add(id); .)
    {   comma
        GlobalId<out id>    (.  aliases.Add(id); .)
    }
.

/* ---- Global declaration ---- */

Declaration
                            (. SymbolInterpretations type = SymbolInterpretations.Undefined; .)
=
SYNC
	declare
	[	var 		        (. type = SymbolInterpretations.GlobalObjectVariable; .)
	|   ref                 (. type = SymbolInterpretations.GlobalReferenceVariable; .)
	|	function			(. type = SymbolInterpretations.Function; .)
	|   command             (. type = SymbolInterpretations.Command; .)
	]
	DeclarationInstance<type>
	{WEAK comma DeclarationInstance<type>}
.
	
DeclarationInstance<SymbolInterpretations type>
                            (.  string id; string aId; .)
=			
	Id<out id>              (.  aId = id; .)
	[ as Id<out aId> ]
	                        (.  SymbolEntry inferredType;
	                            if(target == null) //global symbol
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                            else
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(target.Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(target.Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                target.Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                        .)
.

/* ---- Build Block ---- */

BuildBlock
=
	SYNC build                  (.  PFunction func = new PFunction(TargetApplication);
                                    CompilerTarget lastTarget = target; 
                                    target = Loader.CreateFunctionTarget(func, new AstBlock(this));
                                    Loader.DeclareBuildBlockCommands(target);
                                    _pushLexerState(Lexer.Local);                                
                                .)
	
	[ does ]	
	StatementBlock<target.Ast>
	
                                (.  
	                                _popLexerState();
                                    if(errors.count > 0)
                                    {
                                        SemErr("Cannot execute build block. Errors detected");
                                        return;
                                    }
                                    
                                    //Emit code for top-level build block
                                    try {
                                        target.Ast.EmitCode(target, true);
                                    
                                        target.Function.Meta["File"] = scanner.File;
                                        target.FinishTarget();	                                
                                        target = lastTarget;
                                        //Run the build block 
                                        FunctionContext fctx = func.CreateFunctionContext(ParentEngine, new PValue[] {}, new PVariable[] {}, true);
                                    
                                        try
                                        {
                                            TargetApplication._SuppressInitialization = true;
                                            Loader.BuildCommandsEnabled = true;
                                            ParentEngine.Process(fctx);
                                        }
                                        finally
                                        {
                                            Loader.BuildCommandsEnabled = false;
                                            TargetApplication._SuppressInitialization = false;
                                        }
                                    } catch(Exception e) {
                                        SemErr("Exception during compilation and execution of build block.\n" + e.ToString());
                                    }
	                            .)
.

/* ---- Global Code ---- */

GlobalCode							(.
										PFunction func = TargetApplication._InitializationFunction;
										CompilerTarget ft = FunctionTargets[func];
										if(ft == null)
										    throw new PrexoniteException("Internal compilation error: InitializeFunction got lost.");
									.)
=
									(.	
										target = ft; 
                                        _pushLexerState(Lexer.Local);
                                    .)
	lbrace 
	{ Statement<target.Ast> } 
	rbrace
									(.
                                        try {
										    if(errors.count == 0)
										    {
											    TargetApplication._RequireInitialization();
											    Loader._EmitPartialInitializationCode();
										    }
                                        } catch(Exception e) {
                                            SemErr("Exception during compilation of initialization code.\n" + e.ToString());
                                        } finally {
										    //Symbols defined in this block are not available to further global code blocks
										    target.Symbols.Clear();
										    target = null;
										    _popLexerState();
                                        }
									.)
.

/* ---- Function definition ---- */

FunctionAliasList<. IList<string> aliases .> 
                                    (.  String id; .)
=
    as Id<out id>                   (.  aliases.Add(id); .)
    [   comma Id<out id>            (.  aliases.Add(id); .)
    ]
.

FunctionDefinition<out PFunction func>
                                    (.  
                                        func = null; 
                                        List<string> funcAliases = new List<string>();
                                        string id = null; //The logical id (given in the source code)
                                        string funcId; //The "physical" function id
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        bool isMacro = false;
                                        bool isLazy = false;
                                        PFunction derBody = null; //The derived (coroutine/lazy) body function (carries a different name)
                                        PFunction derStub = null; //The derived (coroutine/lazy) stub function (carries the name(s) specified)
                                        string derId = null; //The name of the derived stub
                                        CompilerTarget ct = null;   //The compiler target for the function (as mentioned in the source code)
                                        CompilerTarget cst = null;  //The compiler target for a stub (coroutine/lazy)
                                    .)         
=	
	(   lazy [function]             (.  isLazy = true; .)
	|   function
	|   coroutine                   (.  isCoroutine = true; .)
	|   macro [function]            (.  isMacro = true; .)
	)
	(   Id<out id>                  (.  funcAliases.Add(id); .)
	    [ FunctionAliasList<funcAliases> ]
	|   FunctionAliasList<funcAliases>
	)                               (.  
	                                    funcId = id ?? Engine.GenerateName("f");
                                        if(Engine.StringsAreEqual(id, @"\init")) //Treat "\init" specially (that's the initialization code)
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                SemErr("Cannot define initialization code inside another function.");
                                            if(isCoroutine)
                                                SemErr("Cannot define initialization code as a coroutine.");
                                            if(isLazy)
                                                SemErr("Cannot define initialization code as a lazy function.");
                                            if(isMacro)
                                                SemErr("Cannot define initialization code as a macro function.");
                                        }
                                        else
                                        {
                                            var localId = id;
                                            
                                            if(isNested)
                                            {
                                                if(isMacro)
                                                    SemErr("Inner macros are illegal. Macros must be top-level.");
                                                    
                                                funcId = generateLocalId(id ?? "inner");
                                                
                                                if(string.IsNullOrEmpty(localId))
                                                {
                                                    //Create shadow name
                                                    localId = generateLocalId(id ?? "inner");
                                                }
                                                SmartDeclareLocal(localId, SymbolInterpretations.LocalReferenceVariable);
                                                foreach(var alias in funcAliases)
                                                        SmartDeclareLocal(alias, localId, SymbolInterpretations.LocalReferenceVariable, false);
                                                
                                            }
                                            
                                            func = new PFunction(TargetApplication, funcId);
                                            
                                            if(isNested)
                                            {
                                                 func.Meta[PFunction.LogicalIdKey] = localId;
                                                 if(isLazy)
                                                    mark_as_let(target.Function,localId);
                                            }
                                            
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            
                                            //Add function to application
                                            if(TargetApplication.Functions.Contains(func.Id) && !TargetApplication.Meta.GetDefault(Application.AllowOverridingKey,true))
												SemErr(t,"Application " + TargetApplication.Id + " does not allow overriding of function " + func.Id + ".");
                                            TargetApplication.Functions.AddOverride(func);
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        
                                        //Generate derived stub
                                        if(isCoroutine || isLazy)
                                        {
                                            derStub = func;
                                            
                                            //Create derived body function
                                            derId = ft.GenerateLocalId();
                                            derBody = new PFunction(TargetApplication, derId);
                                            Loader.CreateFunctionTarget(derBody, new AstBlock(this));
                                            TargetApplication.Functions.Add(derBody);
                                            derBody.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                            if(isCoroutine)
                                            {
                                                derBody.Meta[PFunction.VolatileKey] = true;
                                                derBody.Meta[PFunction.DeficiencyKey] = "Coroutine body can only be executed by VM anyway.";
                                            }

                                            //Swap compiler target references
                                            // -> Compile source code into derived body
                                            // -> Let derived stub have the physical function id
                                            ct = FunctionTargets[derBody];
                                            cst = ft;
                                            ct.ParentTarget = cst;
                                        }
                                        
                                        if(isNested) //Link to parent in case of a nested function
                                        {
                                            ft.ParentTarget = target;	                                           
                                            if(isLazy)
                                                ft = ct;
                                        }	                                    
	                                .)
    [   lpar
	    [	FormalArg<ft> 
		    {	[comma]
			    FormalArg<ft>
		    }
	    ]
	    rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
	]	                            (.  
		                                if(isNested && isLazy)
		                                    ft = cst;
	                                    
	                                    if(target == null && 
	                                        (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)) &&
	                                        (!isNested))
	                                    {
	                                            //Add the name to the symboltable
	                                            foreach(var alias in funcAliases)	                                                
	                                                Symbols[alias] = new SymbolEntry(SymbolInterpretations.Function, func.Id);
	                                            
	                                            //Store the original (logical id, mentioned in the source code)
	                                            if((!string.IsNullOrEmpty(id)))
	                                                func.Meta[PFunction.LogicalIdKey] = id ?? funcId;
	                                    }
	                                    
	                                    //Target the derived (coroutine/lazy) body instead of the stub
                                        if(isCoroutine || isLazy)
                                            func = derBody;
	                                .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        {   MetaAssignment<func> SYNC semicolon
        }
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  
                                    
                                        //Imprint certain meta key from parent function
                                        if(isNested)
                                        {
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                        }

                                        //Copy stub parameters to body of lazy function
                                        if(isLazy && !isNested)
	                                    {
	                                        foreach(var kvp in ft.LocalSymbols)
	                                        {
	                                            var paramId = kvp.Key;
	                                            var s = kvp.Value;
	                                            //Lazy functions cannot have ref parameters
	                                            if(s.Interpretation != SymbolInterpretations.LocalObjectVariable)
	                                                SemErr("Lazy functions can only have value parameters (ref is not allowed)");
	                                            ct.Function.Parameters.Add(s.Id);
	                                            ct.Symbols.Add(paramId, s);
	                                        }
	                                    }
                                    
                                        CompilerTarget lastTarget = target;
                                        target = FunctionTargets[func]; 
                                        _pushLexerState(Lexer.Local);
                                        if(isMacro)
                                            target.SetupAsMacro();
                                    .)
    (   [ does ]
        StatementBlock<target.Ast>
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        target = lastTarget; 
                                        //Compile AST
                                        if(errors.count == 0)
                                        {
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                try {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of initialization code." + e.Message);
                                                }
                                            }
                                            else
                                            {
                                                try {
                                                //Apply compiler hooks for all kinds of functions (lazy/coroutine/macro)
												FunctionTargets[func].ExecuteCompilerHooks();
												//Emit code for top-level block
                                                Ast[func].EmitCode(FunctionTargets[func], true);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of function body of " + id + "." + e.Message);
                                                }
                                            }                                       
                                            
											if(isCoroutine)
											{
                                                try {
												    //Stub has to be returned into the physical slot mentioned in the source code
												    func = derStub;
												    //Generate code for the stub
												    AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
												    crcor.Expression = new AstCreateClosure(this,derBody.Id);
												    AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
												    retst.Expression = crcor;
												    cst.Ast.Add(retst);
												    //Emit code for top-level block
												    cst.Ast.EmitCode(cst,true);
												    cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of coroutine stub for " + id + ". " + e.Message);
                                                }
											}
											else if(isLazy)
											{
											    derStub.Meta[PFunction.LazyKey] = true;
											    derStub.Meta["strict"] = true;
											
											    //Stub has to be returned into the physical slot mentioned in the source code
											    func = derStub;
											    
											    //Generate code for the stub
											    IAstExpression retVal;										    
										        
										        if(isNested)
										        {
										            //Nested lazy functions need a stub to capture their environment by value (handled by NestedFunction)
										            
										            //Generate stub code
										            retVal = new AstCreateClosure(this, ct.Function.Id);
										            
										            //Inject asthunk-conversion code into body
										            var inject = derStub.Parameters.Select(par => 
										            {
										                var getParam =
										                    new AstGetSetSymbol(this, PCall.Get, par, SymbolInterpretations.LocalObjectVariable);
										                var asThunkCall = 
											                new AstGetSetSymbol(this, PCall.Get, Engine.AsThunkAlias, SymbolInterpretations.Command);
											            asThunkCall.Arguments.Add(getParam);
											            var setParam =
											                new AstGetSetSymbol(this, PCall.Set, par, SymbolInterpretations.LocalObjectVariable);
											            setParam.Arguments.Add(asThunkCall);
											            return (AstNode) setParam;
										            });
										            ct.Ast.InsertRange(0,inject);
										        }
										        else
										        {										            
										            //Global lazy functions don't technically need a stub. Might be removed later on
										            var call = new AstGetSetSymbol(this, ct.Function.Id, SymbolInterpretations.Function);
										            
										            //Generate code for arguments (each wrapped in a `asThunk` command call)
											        foreach(var par in derStub.Parameters)
											        {
											            var getParam = 
											                new AstGetSetSymbol(this, PCall.Get, par, SymbolInterpretations.LocalObjectVariable);
											            var asThunkCall = 
											                new AstGetSetSymbol(this, PCall.Get, Engine.AsThunkAlias, SymbolInterpretations.Command);
											            asThunkCall.Arguments.Add(getParam);
											            call.Arguments.Add(asThunkCall);
											        }
											        
											        retVal = call;
										        }								    
											    
											    
											    //Assemble return statement
											    var ret = new AstReturn(this, ReturnVariant.Exit);
											    ret.Expression = retVal;
											    
											    cst.Ast.Add(ret);
											    
                                                try {
											    //Emit code for stub
											    cst.Ast.EmitCode(cst,true);
											    cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy function stub for " + id + ". " + e.Message);
                                                }
											}                                        
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
=
	[ var | ref                     (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
	]
	Id<out id>                      (.  
	                                    //Note: lazy functions need to copy the
	                                    //  parameters of the stub to the body!
	                                    ft.Function.Parameters.Add(id); 
	                                    ft.Symbols.Add(id, new SymbolEntry(kind, id));
	                                .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId                           (.  id = cache(t.val.Substring(1)); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   Ns<out id>                      (.  StringBuilder buffer = new StringBuilder(id); buffer.Append('.'); .)
    {   Ns<out id>                 (.  buffer.Append(id); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = buffer.ToString(); .)
.
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

build does require("prx_interactive.pxs", "prx_lib.pxs");

Name prx\main;
Description "prx main logic.";
Author SealedSun;
Version "v.beta-preview-4";

Entry prx\main;

declare function 
	displayHelp,
	prx\interactive;
    
Add Prexonite::Compiler to Import;
    
var targetPath;
var sourceFiles;

declare var app, ldr;
	
function printHead does println("** PREXONITE $(meta("Version")) **");

var originalArgs;

function prx\main(args)
{
    originalArgs = args;
    
	if(args == null or args.Length == 0)
	{
    	printHead;
		println("NO ARGUMENTS DETECTED.");
		displayHelp;	
		break;
	}
	
	//Define the states of the arguments parser
	var state\compile = 3;      //Just compiling the application
	var state\target = 4;       //Next argument defines the target
	var state\run = 5;          //Running the application after compilation
	var state\interactive = 6;  //Launching the interactive console after compilation
	var state\arg = 7;          //Gathering arguments for the application
	
	//Define default settings
	var state = state\run;      //Run the compiled application b default
	var sourceFiles = [];
	var verbose = false;
	var headerOnly = false;
	
	var scriptArgs = [];
	
	//Interpret arguments one by one
	foreach(var current in args)
	{
		if(current == null or current.Length == 0)
			continue;
		else if(state == state\arg)
			scriptArgs[] = current;
		else if(current.StartsWith("-"))
			if(current == "-c")
				state = state\compile;
			else if(current == "-t")
				state = state\target;
			else if(current == "-i")
				state = state\interactive;
			else if(current == "-r")
				state = state\run;
			else if(current == "-v")
			    verbose = true;
			else if(current == "-h")
			    headerOnly = true;
			else if(current == "-a")
				state = state\arg;
		    else if(current == "-b")
		        supportsTabs = true;
			else if(current == "-?")
			{
				displayHelp;
				return;
			}
			else
				red = () => println("Unknown option " + current + "."); //see *1*
		else if(state == state\compile Or state == state\run Or state == state\interactive)
			if(not System::IO::File.Exists(current))
				red = () => println("The source file \"" + current + "\" can not be found.");
			else
				sourceFiles.Add = current;
		else if(state == state\target)
			targetPath = current;
	}
	
	//*1*: 'red' is a function that takes in another function/lambda expression
	// and executes it in a context where console output is printed in red.
	// See it's definition in 'prx_lib.pxs' for more details.
	
	//'run' and 'compile' require source files. 'interactive' doesn't.
	if(sourceFiles.Count == 0)
	{
		printHead;
    	if(state == state\interactive)
		    prx\interactive;
		else
    	    red = () => println("No source files specified.");
		return;	
	}
	
	//Assemble a default target path if necessary
	if(targetPath == null or targetPath.Length == 0)
		targetPath = System::IO::Path.GetFileNameWithoutExtension(sourceFiles[0]) + ".c.pxs";
		
	//Report
	if(verbose)
	{
    	printHead;
	    println("Target:\t" + targetPath + "\n\nSources:");
    }
    
    //Create a new application. The id extracted from the first source file's name is just decoration
	app = new ::Application(System::IO::Path.GetFileNameWithoutExtension(sourceFiles[0]));
	//Create the loader (the compiler) for this application
	var options = new ::LoaderOptions(thisEngine, app);
	ldr = new ::Loader(options);
	var exc = null; //<--- holds exceptions

	try
	{
		foreach(var sourceFile in sourceFiles)
		{
	    	if(verbose) 
	    	    println("\t* " + sourceFile);
	    	    
	    	//The next call compiles 'sourceFile' into 'app'
			ldr.LoadFromFile(sourceFile);
		}
		if(verbose) 
		    println("Compilation done!");
	}
	catch(var exc)
	{
        green = () => println(exc);
	}
	
	//Compilation errors are not thrown as exceptions but held in 'ldr.Errors'
	if(ldr.Errors.Count != 0 Or not (exc is null)) 
	    red = () =>
        	{    	
        		println("Errors detected. Aborting...");
        		foreach(var err in ldr.Errors)
        			println(err);
            	return;
        	};
	
    //Decide what to do with the just compiled application
	if(state == state\interactive)
	{
    	//'prx\interactive' is defined in 'prx_interactive.pxs'
runInteractive:
        prx\interactive;
    }
	else if(state == state\run)
	{
    	//The application might not run in non-interactive mode
    	if(app.Meta["interactive"].Switch)
    	{
            //The application requires to be run in interactive mode.
            //Extract the id of the interactive entry function from the 
            // applications metadata...
            var intMainId = 
                app.Meta.ContainsKey("entry\\interactive") ? 
                    app.Meta["entry\\interactive"].Text 
                :
                    "main\\interactive"; //... or use a default name.
                    
            //If that function exists, execute it first
            if(app.Functions.Contains(intMainId))
                var intMain = app.Functions[intMainId].Run(thisEngine);
            
            //before going into interactive mode.
            goto runInteractive;
    	}
    	else
    	{
        	//Run the application (run it's entry function).
        	// the script arguments have to be converted to a Prexonite.PValue[] first.
	        app.Run(thisEngine, scriptArgs~Object<"Prexonite.PValue[]">);
        }
    }
	else
	{
    	//Store the compiled application in a file.
    	using(var writer = new System::IO::StreamWriter(targetPath, false))
    	{
        	if(headerOnly)
        	    ldr.StoreSymbols(writer);
        	else
    	        ldr.Store(writer);
        }
    }
}

//A little bit of vodoo magic (read 'custom commands') replaces the original 
// call to 'prx\main' with a new call using 'originalArgs' as the arguments.
// And by 'replace' I mean deleting the old stack entry and inserting the new one.
function reboot does __replace_call(@"prx\main", originalArgs);

function displayHelp does print = 
	"Usage:\n" + 
	"\tprx -c {sources...} (-t {target...} [-h] | -r | -i) [-v | -a <arguments...> | -b]\n" +
	"\tprx -i\n" +
	"\tprx -?\n" +
	"\n" + 
	"List the required source files (*.pxs) after the -c switch.\n" + 
	"Define the name of the output file using -t.\n"+
	"\n"+
	"The default action is storing the compiled application in the target file.\n"+
	"Run the application instead by using the -r switch.\n"+
	"Enter interactive mode (with or without a compiled application) using the -i switch.\n"+
	"-v enables additional output.\n"+
	"-h extracts declarations.\n"+
	"-b enables tab completion (accepts only ASCII characters)."+
	"-a forwards the rest of the arguments to the executed script.\n";
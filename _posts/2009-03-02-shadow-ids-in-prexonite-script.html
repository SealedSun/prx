--- 
meta: 
  _edit_last: "1"
title: Shadow ids in Prexonite Script
published: true
status: publish
tags: 
- C#
- Prexonite
type: post
layout: post
---
<h3>Downloads<sup><a href="#f1">1</a></sup></h3>
<ul>
<li><a href="https://github.com/downloads/SealedSun/prx/prexonite_2010_01_15_src.zip" title="Prexonite Script compiler and language runtime source code for January 10 release">Prexonite <del>March 09</del> January 10 Sources</a></li>
<li><a href="https://github.com/downloads/SealedSun/prx/prexonite_2010_01_15_bin.zip" title="Prexonite Script compiler and language runtime binaries for January 10 release">Prexonite <del>March 09</del> January 10 Binaries</a></li></ul>

<p>
  New this time around is the very small but useful addition of shadow ids, a feature not entirely unlike  the concept of shadowing in C#, thus the name.
</p>
<p>
  Imagine you are working with two comparatively complex libraries, say a convenient wrapper around the Prexonite compiler and some sort of templating engine. 
  If the respective authors of those two libraries both decide to use the identifier `load` for one of their functions, you end up in trouble.
</p>
<p>
  Even though it is absolutely possible to define different symbols (i.e., names) to differentiate between those functions, Prexonite's architecture does not allow two functions with the same physical name inside one application. 
  And since the physical id happens to be the id the function has been defined with, a collision is inevitable.
</p>
<h3>Enter shadow ids</h3>
<p>
  Have a look at the following example:
</p>
<pre><code>function as load, compiler_load (path, loader)
{
  if(loader is Null)
  {
    var engine = asm(ldr.eng);
    var app = asm(ldr.app);
    loader = new Prexonite::Compiler::Loader
      (engine, app);
  }
  loader.LoadFromFile(path);
}</code></pre>
<p>
  This function is a wrapper around the <code>Prexonite.Compiler.Loader.LoadFromFile</code> method in some fictional <code>compiler</code> library file. 
  Notice the keyword <code><em>as</em></code> in front of the list of names for that function. 
  It means that the function itself is anonymous, i.e. it's actual name is generated by the compiler.
  To access the function, you may use any of the alternative names specified.
</p>
<p>
  In addition to that, a generalization for shadow ids is provided for easy function alias definition:
</p>
<pre><code>function compiler_load as load (path, loader)
{
  …
}</code></pre>
<p>
  …which defines an ordinary function <code>compiler_load</code> and immediately adds an alias <code>load</code> for convenient access. 
  This is really just syntactic sugar for
</p>
<pre><code>function compiler_load (path, loader)
{
  …
}
declare compiler_load as load;</code></pre>
<h3>Limitations</h3>
<ul>
	<li>
    <p>
      Shadow ids do not provide obfuscation, they are formed by appending a unique string to the first id in the alias list.
      So <code>function as f, g(){}</code> will be named something like <code>f\gene05c25a4869140c599e4982665b48417</code>.
    </p>
    <p>
      Also, <code>f</code> will be persisted in meta data as the functions <code>LogicalId</code>. This, however is an implementation detail and must not be relied upon.
    </p>
    </li>
	<li>
    <p>
      There is currently no equivalent for global variable definitions, although such a feature is planned.
    </p>
  </li>
</ul>
<h3>Debugging support</h3>
<p>
  The Prexonite Script architecture was never built with debugging in mind. Although line/column/file information is (somewhat) propagated to the AST, it is not used thereafter. 
  There is no mechanism to map instructions to code lines (or vice-versa). Nontheless I am currently prototyping a simple, byte code based, command line debugger.
</p>
<p>
  It will probably come in the form of a library with a special <code>breakpoint</code> function, that invokes an environment not unlike the interactive mode for <code>Prx.exe</code>. 
  It supports <em>inspection of the stack</em>, <em>local variables</em>, <em>watch expressions</em>, <em>stepping</em> (through byte code, not statements) as well as <em>step into</em> functionality.
</p>
<p>
  Have a look at this example session:
</p>
<pre>Local variables of main
 var y = 2;
 var x = 1;

Stack of context of function main
 1: {{1~Int}}
 2: {{2~Int}}
code = function main
[
LogicalId main;import False;
\symbol_mapping {0 -&gt; 0,
1 -&gt; 1};
]
 does asm {
var y,x
   00: @func.0 debug_break
        ldc.int 1
        stloc x
        ldloc x
        ldc.int 1
        add
        stloc y
        ldloc y
        ldloc x
-&gt; 09:  cgt
        jump.f 14
        ldloc x
       @cmd.1 println
        jump 16
   14:  ldloc y
       @cmd.1 println
   16:  ldc.string "Bye!"
        cmd.1 println
   18:  ret.value
   19: }

main@9&gt;</pre>
<p>
  Notice how references to local variables are shown by-name even though the underlying bytecode actually uses the faster by-index opcodes. 
  At the top you see the list of local variables, followed by a display of the current stack. Above the prompt is an enhanced view of the bytecode with only important addresses marked (beginning, end, current and jumpt targets).
</p>
<p>
  What is missing right now, is <em>step-into</em>. 
  Because the debugger is invoked on a per stack context basis (aka function activation). 
  Enabling the debugger for calls made from the current context requires intercepting all corresponding calls. 
  The task is non-trivial because closure, coroutine and structure method calls are statically indistinguishable from calls to aribrary implementations of <code>IIndirectCall</code> and friends.
</p>
<h3>Macro system</h3>
<p>
  Another area of development is the addition of a more user friendly macro system into Prexonite Script. 
  Currently, one can rewrite undefined ids, a mechanism that is not supposed to be a replacement for macros but rather a means of changing the default handling of unknown ids.
</p>
<p>
  Alternatively, compiler hooks can be used to transform entire functions. 
  Not only is it very tedious to find the specific calls to replace, it's also not guaranteed that you find every instance of a certain expression by traversing the tree. 
  All uses of compiler hooks share a similar pattern of searching a certain dummy function reference and replacing it with custom nodes, using the transformed function itself and any of its parameters as arguments.
</p>
<p>
  A possible simplification of this scheme would be the explicit support for macro functions:
<pre><code>macro square(x)
{
  //Define a
  var tmp = define("tmp");
  var assignment = ast("GetSetSymbol",SetCall,tmp,[x]);
  var computation = multiply(tmp,tmp);
  return block([assignment, computation]);
}</code></pre>
<p>
  The macro square transforms calls to it like <code>( square(x+2) )</code> to an expression like <code>( let tmp = x+2 in (tmp)*(tmp) )</code>. 
  The details are not fleshed out yet. 
  A more concrete discussion follows.
</p>

<div id="footnotes">
  <h3>Footnotes</h3>
  <ol>
    <li>      
      <a name="f1">&nbsp;</a> The linked downloads are from January 2010 instead of March 2009. When converting the blog entry, I felt that this was the safer approximation than taking a random commit from around March 2009 (I no longer have that exact download on file).
    </li>
  </ol>
</div>
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

build
{
	require("prx_lib.pxs");
}

Name prx\interactive;
Description "Provides interactive command line for prx";
Author SealedSun;

Import { System, System::Text, Prexonite, Prexonite::Compiler };

var engine;

declare function reboot;

//The follwing code block is compiled
// as part of the initialization of the application.
// Global variable assignments too are part of the '\init' function.
{
	engine = new Prexonite::Engine;
	//The interactive prompt uses a second, isolated engine for execution.
	var thisE = thisEngine;
	
	//Copy those 4 timing commands from the current engine to the 
	// interactive engine
	foreach(var alias in [
			@"timer\start",
			@"timer\stop",
			@"timer\elapsed",
			@"timer\reset"])
		engine.Commands.AddUserCommand(alias, thisE.Commands[alias]);
}

var app; //<-- the compiled application
var ldr; //<-- the loader used to compile 'app'

var evalStep = 1; //<-- helps to make identifiers unique

function prx\interactive()
{
    println("Entering Prexonite INTERACTIVE MODE.\nType :quit to quit.\n\"=<expr>\" evaluates an expression.\n\":<GlobalStatement>\" inserts global code.");
    
    //Either create a new application or use the one compiled in 'prx\main'.
    if(app == null)
        app = new Prexonite::Application("Interactive_Scripting");
    else
        println("Using compiled application ($(app.Id))");
    
    //Create a new loader (='compiler') if necessary
    if(ldr == null)
        ldr = new ::Loader(engine, app);
    
    //Define a default prompt color
    prompt\color = ::ConsoleColor.Red;
    
    var buffer = new ::StringBuilder;
    //Compile some standard code into the interactive application
    buffer.AppendLine("var prompt = null;");
    if(Not app.Functions.Contains("exit"))
        buffer.AppendLine("function exit(c) does System::Environment.Exit(c is Null ? 0 : c);");
    buffer.AppendLine("declare exit as quit;");
    ldr.LoadFromString(buffer.ToString);
    buffer.Length = 0;
    
    var errors;
    var lastCode;
    
    //This function tries to load code from the buffer
    function tryLoad()
    {
        try 
        {
            lastCode = buffer.ToString; //Save the code for error reporting
            ldr.LoadFromString(lastCode);            
        } 
        catch(var exc)
        {
            //Exceptions are truly exceptional, so they should be printed
            // out right away.
            green = () =>
			{
    			println(exc);
				foreach(var err in errors)
					println(err);
			};
			return false;
        }
        finally
        {
            //Save errors for review and clean up.
            buffer.Length = 0;
            errors = ~List.CreateFromList(ldr.Errors);
            ldr.Errors.Clear;
            return errors.Count == 0;
        }
    }
    
    //Print errors (if 'otherErrors' is null, 'errors' is used)
    function printErrors(otherErrors) does red = () =>
    {
        otherErrors ??= errors;
        foreach(var err in otherErrors);
            println(err);
    };
    
    //Generate the next unique function id
    function nextFuncId = "eval\\" + evalStep++;
    
    //Function that shortens a string
    var shortenTo = 20;
    function shortened(s) = s.Length <= shortenTo ? s : (s.Substring(0,shortenTo-3) + "...");
    
    //Get 'raw' using showPrompt (passing the value of the variable 'prompt' 
    // from inside 'app') until that 'raw' is ":quit".
    //This 'for' syntax might look stupid at first but it manages to separate
    // more complex iteration logic from the loop body.
    // One only needs to look at the header to know under what conditions
    // the loop runs. In addition, the body code can use the traditional
    // 'continue' statement to skip an iteration.
    for(var raw; do raw = showPrompt(app.Variables["prompt"].Value.Self); until raw.ToLower == ":quit")
    {        
        var funcId = nextFuncId; //<-- get the first unique function id
        var cmd = "r"; //<-- assume execution of code
        
        if(raw.ToLower == ":reload") //this directive restarts prx\main with the same arguments. See 'prx_main.pxs' for details.
        {
            reboot;
            break;          
        }
        else if(raw.ToLower.StartsWith(":compile "))
        {
            cmd = "c";
            raw = raw.Substring(9);
            goto executeStatement;
        }
        else if(raw.StartsWith("=")) //force compilation as an expression
        {
            raw = raw.Substring(1);
            buffer.Append = "function $(funcId) does println(\"$(shortened(raw).Escape) = \") = \n$(raw)\n;";
            if(Not tryLoad)
            {
                printErrors;
                continue;   
            }
        }
        else if(raw.StartsWith("::")) //Must be a static get/set
            goto executeStatement;
        else if(raw.StartsWith(":")) //Global code
        {
            buffer.Append = raw.Substring(1);
executeGlobal:
            if(Not tryLoad)
            {
                printErrors;
                continue;
            }  
            cmd = "g"; //do not execute anything          
        }
        else if(raw.ToLower.StartsWith("global ")) //Global code too
        {
            buffer.Append = raw.Substring(7);
            goto executeGlobal;
        }
        else
        {
executeStatement:
            //First, try to compile the code as an expression
            buffer.AppendFormat(" function {0} does println = \"{1} = \" + ( {2} ) ; ", funcId, shortened(raw).Escape, raw);
            if(Not tryLoad)
            {
                //should that fail, try to compile the code as a statement
                var evalErrors = errors;
                var evalCode = lastCode;

                funcId = nextFuncId;
                buffer.AppendFormat(" function {0} {{ {1} ; }} ", funcId, raw);

                if(Not tryLoad)
                {
                    //if both fails, the code must be wrong.
                    // show why it can't be an expression
                    println("(" + raw + ") is not an expression:");
                        println(evalCode);
                    printErrors(evalErrors);

                    // shwo why it can't be a statement
                    println;
                    println("{" + shortened(raw) + "; } is also not a statement:");
                        println(lastCode);
                    printErrors(errors);

                    continue;
                }
            }
        }             
        
        try
        {
            if(cmd == "r")
            {
                //A function needs to be run
                unless(app.Functions[funcId] is Null)
                    app.Functions[funcId].Run(engine);
            }
            else if(cmd == "c")
            {
                var codeSB = new System::Text::StringBuilder;
                unless(app.Functions[funcId] is null)
                    app.Functions[funcId].Store(codeSB);
                println(codeSB);
            }
        }
        catch(var exc)
        {
           green = () => println(exc);
        }
        finally
        {
            function removeEvalFunctions()
            {
                var toRemove =  foreach(var func in app.Functions)
                                    if(func.Id.StartsWith("eval\\"))
                                        yield func;
                                ;
                                        
                foreach(var func in toRemove)
                {
                    app.Functions.Remove(func);
                }
            }
            removeEvalFunctions();
        } //end finally
    } //end for -> next prompt
}
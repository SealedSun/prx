using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Runtime.CompilerServices;
using PxCoco.Msbuild;

// ReSharper disable CheckNamespace
// ReSharper disable MemberCanBePrivate.Global

namespace at.jku.ssw.Coco
{
    public static partial class Coco
    {      
        public static void Merge(string targetPath, string[] sourcePaths, Action<string> logMessage, string relativePathRoot = null)
        {
            string relativePath(string path) => 
                relativePathRoot == null ? path : Platform.GetRelativePath(relativePathRoot, path);

            const int bufferSize = 512;
            var buffer = new byte[bufferSize];
            //Use a target stream
            using (var ts = new FileStream(targetPath, FileMode.Create, FileAccess.Write, FileShare.None))
            using (var sw = new StreamWriter(ts))
            {
                sw.WriteLine("//-- GENERATED BY PxCoco -merge --//");
                sw.WriteLine("//-- make sure to modify the source files instead of this one! --//");
                sw.WriteLine("//-- file paths are relative to: {0} --//", relativePathRoot);
                foreach (var sourcePath in sourcePaths)
                {
                    if (!File.Exists(sourcePath))
                    {
                        logMessage("Source file " + sourcePath + " does not exist.");
                        continue;
                    }
                    var sourceName = Path.GetFileName(sourcePath);
                    logMessage.Invoke($"Adding {sourceName} to {Path.GetFileName(targetPath)}.");
                    //Use a source stream
                    using (var ss = new FileStream(sourcePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        sw.WriteLine("\n#file:" + relativePath(sourcePath) + "#");
                        sw.Flush();
                        int bytesRead;
                        while((bytesRead = ss.Read(buffer, 0, bufferSize)) > 0)
                            ts.Write(buffer, 0, bytesRead);                        
                    }
                    
                }
                //Switch line processing back to normal, in case the user wants to add stuff here
                sw.WriteLine("#file:default#");
                sw.Flush();
            }
        }

        public static void MergeCommandLine(string[] args)
        {
            if (args.Length < 3)
            {
                Console.WriteLine("Usage: PxCoco -merge {grammarParts.atg} output.atg");
                return;
            }
            
            string relativePath = null;
            var sourcePaths = new List<string>();

            var argv = new Queue<string>(args);

            bool next(out string arg)
            {
                // Queue.TryDequeue is not present in .NET Framework 4.8
                if (argv.Count > 0)
                {
                    arg = argv.Dequeue();
                    return true;
                }
                else
                {
                    arg = null;
                    return false;
                }
            }

            while (next(out var arg))
            {
                switch (arg)
                {
                    case "-relative" when next(out relativePath):
                        break;
                    default:
                        sourcePaths.Add(arg);
                        break;
                }
            }

            // The last source path is actually the target path
            if (sourcePaths.Count < 2)
            {
                throw new ArgumentException("At least two paths are required (source, target).");
            }
            var targetPath = sourcePaths[sourcePaths.Count - 1];
            sourcePaths.RemoveAt(sourcePaths.Count - 1);

            Merge(targetPath, sourcePaths.ToArray(), Console.WriteLine, relativePath);
        }
    }
}

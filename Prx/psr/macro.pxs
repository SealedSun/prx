 
build does require(@"psr\ast.pxs");

function is_in_macro\impl as is_in_macro(context) [is compiler;] = 
    ([context.Function]
    >> append(context.GetParentFunctions())
    >> where(f => f.Meta[Prexonite::Compiler::CompilerTarget.MacroMetaKey].Switch)
    >> limit(1)
    >> count) > 0;
    
/* establish_macro_context - Allows a macro, that only works in other macros, to be applied in nested functions of macros as well.*/
function establish_macro_context\impl as establish_macro_context(context) [is compiler;]
{
    if(context is null)
        throw @"establish_macro_context\impl: context cannot be null.";
    var contextAlias = Prexonite::Compiler::MacroAliases.ContextAlias;
    if(not is_in_macro(context)) 
    {
        context.ReportMessage(Prexonite::Compiler::ParseMessageSeverity.Error, "Cannot establish macro context outside of macro", context.Invocation);
        return;
    }

    if(not (context.OuterVariables >> map(?.ToUpperInvariant) >> contains(contextAlias.ToUpperInvariant)))
        context.RequireOuterVariable(contextAlias);
}

/* ast\macro - Works like ast from psr\ast.pxs but automatically supplies file, line and column information 
    taken from the macro invocation. */
macro ast\macro(type)
{   
    var macroInvocation = context.Invocation;
    
    var astCall = ast\withPos("GetSetSymbol",
        macroInvocation.File, macroInvocation.Line,macroInvocation.Column,
        SI.get, ->ast\withPos.Id, SI.func);
    
    var nodeFile;
    var nodeLine;
    var nodeColumn;
    
    if(is_in_macro(context))
    {
        establish_macro_context(context);
        
        var getContext = ast\withPos("GetSetSymbol",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column ,
            SI.get,Prexonite::Compiler::MacroAliases.ContextAlias,SI.lref);
        
        var getInv = ast\withPos("GetSetMemberAccess",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column ,SI.get,getContext,"Invocation");
        nodeFile = ast\withPos("GetSetMemberAccess",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column, SI.get, getInv, "File");
        nodeLine = ast\withPos("GetSetMemberAccess",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column, SI.get, getInv, "Line");
        nodeColumn = ast\withPos("GetSetMemberAccess",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column, SI.get, getInv, "Column");
    }
    else 
    {
        nodeFile = ast\withPos("Constant",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column,macroInvocation.File);
        nodeLine = ast\withPos("Constant",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column,macroInvocation.Line);
        nodeColumn = ast\withPos("Constant",
            macroInvocation.File, macroInvocation.Line,macroInvocation.Column,macroInvocation.Column);
    }
    
    astCall.Arguments.AddRange([type,nodeFile, nodeLine, nodeColumn ]);
    astCall.Arguments.AddRange(var args >> skip(1));
    
    return astCall;
}

declare ast\macro as ast;

//This macro makes passing `context` to is_in_macro optional (but still possible)
macro is_in_macro(explicitContext)
{
    if(explicitContext is null and not is_in_macro\impl(context))
    {
        context.ReportMessage(Prexonite::Compiler::ParseMessageSeverity.Error, "If is_in_macro is not used inside a macro, the context has to be passed explicitly.", context.Invocation);
        return;
    }
    
    var getContext;
    if(explicitContext is null)
    {
        establish_macro_context(context);
        getContext = ast("GetSetSymbol",SI.get,Prexonite::Compiler::MacroAliases.ContextAlias,SI.lref);
    }
    else
    {
        getContext = explicitContext;
    }
    
    var funcCall = ast("GetSetSymbol",SI.get,->is_in_macro\impl.Id,SI.func);
    funcCall.Arguments.Add(getContext);
    return funcCall;
}

macro establish_macro_context()
{
    establish_macro_context\impl(context);
    
    var estCall = ast("GetSetSymbol", SI.get, ->establish_macro_context\impl.Id, SI.func);
    estCall.Arguments.Add(ast("GetSetSymbol", SI.get, Prexonite::Compiler::MacroAliases.ContextAlias, SI.lref));
    return estCall;
}

function macro\report_any(message, severity)
    [\sharedNames {context};]
{
    var getContext = ast("GetSetSymbol", SI.get, Prexonite::Compiler::MacroAliases.ContextAlias, SI.lref);
    var parseMessageSeverity_t = ast("ConstantTypeExpression", "Object(\"Prexonite.Compiler.ParseMessageSeverity\")");
    var getSeverity = ast("GetSetStatic", SI.get, parseMessageSeverity_t, severity);
    var getInvocation = ast("GetSetMemberAccess", SI.get, getContext, "Invocation");
    var reportMessage = ast("GetSetMemberAccess", SI.get, getContext, "ReportMessage");    
    reportMessage.Arguments.Add(getSeverity);
    reportMessage.Arguments.Add(message);
    reportMessage.Arguments.Add(getInvocation);
    
    return reportMessage;
}

macro macro\report_error(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Error");
}

macro macro\report_warning(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Warning");
}

macro macro\report_info(message)
{
    establish_macro_context;
    
    ref impl = asm( newclo macro\report_any );
    
    return impl(message, "Info");
}

//Create node type check functions (to separate macro implementations from the CLR ast node types.
var ast_is_expression [is compiler;];
var ast_is_effect [is compiler;];
var ast_is_partially_applicable [is compiler;];
var ast_is_partial_application [is compiler;];

build
{
    function human_name(t) = if((var n = t.Name).StartsWith("Ast")) n.Substring(3) else n;
    
    var AstNode_t = System::Type.GetType("Prexonite.Compiler.Ast.AstNode");
    
    //Create check function for each type that inherits from AstNode
    AstNode_t.Assembly.GetTypes() 
    >> where(t => astnode_t.IsAssignableFrom(t))
    >> var node_ts;
    
    foreach(new var node_t in node_ts)
    {
        var ref_name = "ast_is_$(human_name(node_t))";
        var ref_var = new Prexonite::PVariable;
        function check_is_node_t(node_arg) [is compiler;]
        {
            //Ensure is object type in the first place
            if((var arg_pt = boxed(node_arg).Type) is not Prexonite::Types::ObjectPType)
                return false;
                
            var arg_t = arg_pt.ClrType;
            
            //Check if it is correct node, but not a partial application
            return node_t.IsAssignableFrom(arg_t) and not node_arg.CheckForPlaceholders();
        }
        ref_var.Value = boxed(->check_is_node_t);
        ref_var.Meta["compiler"] = true;
        
        //Add variable and declare corresponding symbol
        GetLoader.ParentApplication.Variables.Add(ref_name, ref_var);
        GetLoader.Symbols.Add(ref_name,new Prexonite::Compiler::SymbolEntry(SI.gref,ref_name));
    }
    
    //Create special check functions for expressions, partially applicables and effects
    var interfaces = ["Prexonite.Compiler.Ast.IAstExpression": ast_is_expression = ?,
                      "Prexonite.Compiler.Ast.IAstEffect": ast_is_effect = ?,
                      "Prexonite.Compiler.Ast.IAstPartiallyApplicable": ast_is_partially_applicable = ?];
    foreach(var entry in interfaces)
    {
        new var interface_t = System::Type.GetType(entry.Key);
        function check_is_interface_t(node_arg) [is compiler;]
        {
            //Ensure is object type in the first place
            if((var arg_pt = boxed(node_arg).Type) is not Prexonite::Types::ObjectPType)
                return false;
                
            var arg_t = arg_pt.ClrType;
            
            //Check if it is correct node, but not a partial application
            return  AstNode_t.IsAssignableFrom(arg_t) 
              and   interface_t.IsAssignableFrom(arg_t) 
              and   not node_arg.CheckForPlaceholders();
        }
        
        entry.Value.() = check_is_interface_t(?);
    }
    
    //Create special check function for partial application
    function check_is_partial_application(node_arg) [is compiler;]
    {
        //Ensure is object type in the first place
            if((var arg_pt = boxed(node_arg).Type) is not Prexonite::Types::ObjectPType)
                return false;
                
            var arg_t = arg_pt.ClrType;
            
            //Check if it is node and a partial application
            return  AstNode_t.IsAssignableFrom(arg_t) 
              and   node_arg.CheckForPlaceholders();
    }
    ast_is_partial_application = check_is_partial_application(?);
    
    //Remove helper functions
    GetLoader.ParentApplication.Functions.Remove(->human_name.Id);
}

declare ref ast_is_expression, ast_is_partially_applicable, ast_is_effect, ast_is_partial_application;

macro tempalloc(getContext)
{
    if(is_in_macro(context))
    {
        establish_macro_context;
    }
    else if(getContext is Null)
    {
        macro\report_error("tempalloc must either be called in a macro context, or be supplied a context~Prexonite::Compiler::CompilerTarget");
        return;
    }
    
    getContext ??= ast("GetSetSymbol",SI.get,Prexonite::Compiler::MacroAliases.ContextAlias,SI.lref);
    
    return ast("GetSetMemberAccess",SI.get,getContext,"AllocateTemporaryVariable");
}

macro tempfree(getContext, tempId)
{
    if(tempId is Null)
    {
        tempId = getContext;
        getContext = null;
    }
    
    var contextAlias = Prexonite::Compiler::MacroAliases.ContextAlias;
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    else if(getContext is Null)
    {
        macro\report_error("tempfree must either be called in a macro context, or be supplied a macroInvocation~Prexonite::Compiler::Ast::AstMacroInvocation");
        return;
    }
    
    if(tempId is Null)
    {
        macro\report_error("tempfree must know which temporary variable to free!");
        return;
    }
    
    getContext ??= ast("GetSetSymbol",SI.get,contextAlias,SI.lref);
    
    var c = ast("GetSetMemberAccess",SI.get,getContext,"FreeTemporaryVariable");
    c.Arguments.Add(tempId);
    
    return c;
}

//Optimization
function optimize\ref(context, ref node) [is compiler;]
{
    return node = context.GetOptimizedNode(node);
}

macro optimize(contextRef, node)
{
    if(node is Null)
    {
        node = contextRef;
        contextRef = null;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
        contextRef ??= ast("GetSetSymbol",SI.get,Prexonite::Compiler::MacroAliases.ContextAlias,SI.lref);
    }
    else if(contextRef is Null)
    {
        macro\report_error("optimize(context, node) requires a macro context.");
        return;
    }
    
    if(node is Null)
    {
        macro\report_error("optimize([context, ] node) requires a node to optimize");
        return;
    }
    
    if(ast_is_GetSetSymbol(node))
    {
        var setNode = node.GetCopy();
        setNode.Call = SI.set;
        
        var optCall = ast("GetSetMemberAccess",SI.get,contextRef,"GetOptimizedNode");
        optCall.Arguments.Add(node);        
        setNode.Arguments.Add(optCall);
        
        return setNode;
    }
    else 
    {
        var funCall = ast("GetSetSymbol",SI.get, ->optimize\ref.Id, SI.func);
        funCall.Arguments.Add(contextRef);
        funCall.Arguments.AddRange(var args);
        return funCall;
    }
}

//Safe "evaluation" of constant arguments
function ast\read(context, expr) [is compiler;]
{
    if(expr is Null)
        return null;
        
    //Apply optimization to get constant folding
    optimize(context, expr);
    
    function convert(subexpr)
    {        
        if(subexpr is Prexonite::Compiler::Ast::AstConstant)
            return subexpr.Constant;
        else if(subexpr is Prexonite::Compiler::Ast::AstListLiteral)
            return subexpr.Elements >> map(convert(?)) >> all;
        else if(subexpr is Prexonite::Compiler::Ast::AstHashLiteral)
            return subexpr.Elements >> map(convert(?)) >> all;
        else if(subexpr is Prexonite::Compiler::Ast::AstKeyValuePair)
            return convert(subexpr.Key) : convert(subexpr.Value);
        else if(subexpr is Prexonite::Compiler::Ast::AstNull)
            return null;
        else 
            throw "Cannot convert compile-time expression $(boxed(expr)) to runtime value.";
    }
    
    return convert(expr);
}

function macro\_extract_id(prototype)[is compiler;]
{
    if(ast_is_MacroInvocation(prototype))
        return prototype.MacroId;
    else
        return prototype.Id;
}

macro macro\reference(prototype)
{
    if(context.IsJustEffect)
        return;
    
    var id = macro\_extract_id(prototype);    
    var ldrfunc = new Prexonite::Instruction(Prexonite::OpCode.ldr_func,id);
    
    context.SuppressDefaultExpression = true;
    return ast("AsmInstruction",ldrfunc);
}

macro macro\id(prototype)
{
    if(context.IsJustEffect)
        return;
    return ast("Constant",macro\_extract_id(prototype));
}

macro macro\interpretation(prototype)
{
    if(context.IsJustEffect)
        return;
    
    var getSI = ast("GetSetSymbol",SI.get,"SI",SI.gvar);
    
    var siMem;
    if(ast_is_MacroInvocation(prototype))
    {
        var i = prototype.Interpretation;
        if(SI.m.is_func(i))
            siMem = "func";
        else if(SI.m.is_cmd(i))
            siMem = "cmd";
        else {
            macro\report_error("Unkown macro interpretation $i. Assuming function");
            siMem = "func";
        }
        
        var getSI\m = ast("GetSetMemberAccess",SI.get,getSI,"m");
        var getSI\m\i = ast("GetSetMemberAccess",SI.get,getSI\m,siMem);
            
        return getSI\m\i;
    }
    else if(ast_is_GetSetSymbol(prototype))
    {
        var i = prototype.Interpretation;
        if(SI.is_lvar(i))
            siMem = "lvar";
        else if(SI.is_lref(i))
            siMem = "lref";
        else if(SI.is_gvar(i))
            siMem = "gvar";
        else if(SI.is_gref(i))
            siMem = "gref";
        else if(SI.is_func(i))
            siMem = "func";
        else if(SI.is_cmd(i))
            siMem = "cmd";
        else if(SI.is_mcmd(i))
            siMem = "mcmd";
        else {
            macro\report_error("Unkown symbol interpretation $i. Assuming function");
            siMem = "func";
        }
        
        var getSI\i = ast("GetSetMemberAccess",SI.get,getSI,siMem);
        
        return getSI\i;
    }
}

//ast helper
macro ast\invoke_macro(macroId, symbolInterpretation)
{
    if(context.IsJustEffect)
        return;
        
    if(is_in_macro)
        establish_macro_context;

    var c = ast("MacroInvocation",macro\id(ast\macro), SI.m.func);
    c.Arguments.Add(ast("Constant","MacroInvocation"));
    
    //try parse ast\invoke_macro(macro\id($PROTOTYPE))
    if(symbolInterpretation is null)
    {   if(ast_is_MacroInvocation(macroId) 
            and macroId.MacroId == macro\id(macro\id)
            and macroId.Arguments.Count > 0)
        {
            var i = macroId.Arguments[0].Interpretation;
            var siMem;
            if(SI.m.is_func(i))
                siMem = "func";
            else if(SI.m.is_cmd(i))
                siMem = "cmd";
            else {
                macro\report_error("Unkown macro interpretation $i. Assuming function");
                siMem = "func";
            }
            
            var getSI = ast("GetSetSymbol",SI.get,"SI",SI.gvar);
            var getSI\m = ast("GetSetMemberAccess",SI.get,getSI,"m");
            var getSI\m\i = ast("GetSetMemberAccess",SI.get,getSI\m,siMem);
            if((var args).Count > 1)
                args[1] = getSI\m\i;
            else
                args[] = getSI\m\i;
        }
        else 
        {
            macro\report_warning("No symbol interpretation provided for construction of ast\\invoke_macro node in function $(context.Function).");
        }
    }
    
    c.Arguments.AddRange(var args);    
        
    return c;
}

macro ast\symbol(symbolInterpretation)
{
    var c = ast\invoke_macro(macro\id(ast\macro));
    var getSI = ast("GetSetSymbol",SI.get,"SI",SI.gvar);
    var getSI\cmd = ast("GetSetMemberAccess",SI.get,getSI,ast\read(context, symbolInterpretation));
    c.Arguments.Add(ast("Constant", "GetSetSymbol"));
    c.Arguments.AddRange(var args >> skip(1));
    c.Arguments.Add(getSI\cmd);
    return c;
}

macro ast\symbol\mk_macro(symbolInterpretation)
{
    var block = ast("BlockExpression");
    
    //Generation of
    //  var c = ast\invoke_macro(->ast\symbol.Id);
    var varC = tempalloc;
    var mc = ast\invoke_macro(macro\id(ast\invoke_macro));
    mc.Arguments.Add(ast("Constant",macro\id(ast\symbol)));
    var prototype = ast\invoke_macro(macro\id(ast\symbol));
    mc.Arguments.Add(asm(newclo macro\interpretation).(prototype));
    var setC = ast("GetSetSymbol",SI.set, varC, SI.lvar);
    setC.Arguments.Add(mc);
    block.Add(setC);
    
    //Generation of
    //  c.Arguments.Add(ast("Constant","func"));
    var getC = ast("GetSetSymbol",SI.get,varC,SI.lvar);
    var getC\Arguments = ast("GetSetMemberAccess",SI.get,getC,"Arguments");
    var getC\Arguments\Add = ast("GetSetMemberAccess",SI.get,getC\Arguments,"Add");
    var constFunc = ast\invoke_macro(macro\id(ast\macro));
    constFunc.Arguments.Add(ast("Constant","Constant"));
    constFunc.Arguments.Add(symbolInterpretation);
    getC\Arguments\Add.Arguments.Add(constFunc);
    block.Add(getC\Arguments\Add);
    
    //Generation of
    //  c.Arguments.AddRange(var args);
    var getC\Arguments = getC\Arguments.GetCopy();
    var getC\Arguments\AddRange = ast("GetSetMemberAccess",SI.get,getC\Arguments,"AddRange");
    if(not (context.Function.Variables >> contains(Prexonite::PFunction.ArgumentListId)))
        context.Function.Variables.Add(Prexonite::PFunction.ArgumentListId);
    getC\Arguments\AddRange.Arguments.Add(ast("GetSetSymbol",SI.get,Prexonite::PFunction.ArgumentListId,SI.lvar));
    block.Add(getC\Arguments\AddRange);
    
    //Generation of
    //  return c;
    block.Expression = getC.GetCopy();   
    
    tempfree(varC);
    
    return block;
}

macro ast\cmd = ast\symbol\mk_macro("cmd");
macro ast\func = ast\symbol\mk_macro("func");
macro ast\lvar = ast\symbol\mk_macro("lvar");
macro ast\lref = ast\symbol\mk_macro("lref");
macro ast\gvar = ast\symbol\mk_macro("gvar");
macro ast\gref = ast\symbol\mk_macro("gref");

//Create GetSetMemberAccess node
macro ast\member(subject, call_type, id)
{
    if(id is Null)
    {
        id = call_type;
        call_type = null;
    }
    
    if(is_in_macro)
        establish_macro_context;
    
    id ??= ast("Constant","");
    call_type ??= ast("GetSetMemberAccess",SI.get,ast\gvar(SI.get,"SI"),"get");
    
    var c = ast\invoke_macro(macro\id(ast\macro));
    c.Arguments.Add(ast("Constant","GetSetMemberAccess"));
    c.Arguments.Add(call_type);
    c.Arguments.Add(subject);
    c.Arguments.Add(id);
    
    return c;
}

function ast\const\dynamic(value) [is compiler;]
{
    if(value is Null)
    {
        return ast("Null");
    }
    else if(value is Int or value is Real or value is Bool or value is String)
    {
        return ast("Constant",value);
    }
    else if(value is List)
    {
        var lst = ast("ListLiteral");
        foreach(var v in value)
            lst.Elements.Add(ast\const\dynamic(v));
        return lst;
    }
    else if(value is Prexonite::Types::PValueKeyValuePair)
    {
        var kvp = ast("KeyValuePair", ast\const\dynamic(value.Key), ast\const\dynamic(value.Value));
        return kvp;
    }
    else
    {
        throw "Cannot represent runtime value $(value.\boxed) as compile-time value.";
    }
}

macro ast\const(value)
[ Add Prexonite::Compiler::Ast to Imports;]
{   
    if(is_in_macro)
        establish_macro_context;
 
    if(value is ::AstNull)
    {
        var c = ast\invoke_macro(macro\id(ast\macro));
        c.Arguments.Add(ast("Constant","Null"));
        return c;
    }
    else if(value is ::AstConstant)
    {
        var c = ast\invoke_macro(macro\id(ast\macro));
        c.Arguments.Add(ast("Constant","Constant"));
        c.Arguments.Add(value);
        return c;
    }
    else if(value is ::AstKeyValuePair)
    {
        var kvp = ast\invoke_macro(macro\id(ast\macro));
        kvp.Arguments.Add(ast("Constant","KeyValuePair"));
        kvp.Arguments.Add(value.Key);
        kvp.Arguments.Add(value.Value);
        return kvp;
    }
    else
    {
        var c = ast\func(->ast\const\dynamic.Id);
        c.Arguments.Add(value);
        return c;        
    }
}

//Create return nodes
macro ast\ret\generic_proc(expr, kind)
{   
    if(is_in_macro)
        establish_macro_context;
 
    var getSI = ast\gvar(SI.get, "SI");
    var mkRetNode = ast\invoke_macro(macro\id(ast\macro));
    mkRetNode.Arguments.Add(ast\const("Return"));
    mkRetNode.Arguments.Add(ast\member(getSI, SI.get, "ret\\$kind"));
    if(expr is Null)
    {
        if(kind.ToLower == "set")
            throw "Set return requires an expression.";
        return mkRetNode;
    }
    else
    {
        var block = ast("BlockExpression");
        var vr = tempalloc;
        
        //store ret node in variable r
        var setR = ast\lvar(SI.set, vr);
        setR.Arguments.Add(mkRetNode);
        block.Add(setR);
        
        //assign expr to r.Expression
        var setE = ast\member(ast\lvar(SI.get, vr), SI.set, "Expression");
        setE.Arguments.Add(expr);
        block.Add(setE);
        
        block.Expression = ast\lvar(SI.get, vr);
        
        tempfree(vr);        
        return block;
    } 
}

macro ast\ret\val as ast\ret(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"exit");
}

macro ast\ret\continue as ast\yield(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"continue");
}

macro ast\ret\break(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"break");
}

macro ast\ret\set(expr)
{
    return asm(newclo ast\ret\generic_proc).(expr,"set");
}

//Evaluate Ast nodes (really executing them, so watch out!)
function ast\run\impl(loader, block) [is compiler;]
{
    var func = new Prexonite::PFunction(loader.ParentApplication);
    var funcTarget = loader.CreateFunctionTarget(func, block);
    funcTarget.Ast.EmitCode(funcTarget, true);
    funcTarget.FinishTarget();
    var result = func.();
    loader.FunctionTargets.Remove(funcTarget);
    loader.ParentApplication.Functions.Remove(func);
    return result;
}

macro ast\run(loaderRef, block)
{
    if(block is Null)
    {
        block = loaderRef;
        loaderRef = null;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    
    if(loaderRef is Null)
    {
        macro\report_error("ast\\run must be supplied a loader~Prexonite::Compiler::Loader");
        return;
    }
    
    var c = ast\func(->ast\run\impl.Id);
    c.Arguments.Add(loaderRef);
    c.Arguments.Add(block);
    
    return c;
}

function ast\eval\impl(loader, expr) [is compiler;]
{
    var block = ast("Block");
    block.Add(ast\ret(expr));
    return ast\run(loader, block);
}

macro ast\eval(loaderRef, expr)
{
    if(expr is Null)
    {
        expr = loaderRef;
        loaderRef = null;
    }
    
    if(is_in_macro)
    {
        establish_macro_context;
    }
    else if(loaderRef is Null)
    {
        macro\report_error(
            "ast\\eval must be supplied a loader~::Loader");
        return;
    }
    
    var c = ast\func(->ast\eval\impl.Id);
    c.Arguments.Add(loaderRef);
    c.Arguments.Add(expr);
    
    return c;
}

//Abbreviation for ast nodes with arguments
macro ast\with_arguments as ast\args (astN)
{
    if(is_in_macro)
        establish_macro_context;

    var block = ast("BlockExpression");
    var astV = tempalloc;
    
    var assignAst = ast\lvar(SI.set, astV);
    assignAst.Arguments.Add(astN);
    block.Add(assignAst);
    
    var args;
    if(args.Count > 1)
    {
        if(args.Count > 2)
        {      
            var getArguments = ast\member(ast\lvar(SI.get, astV), SI.get, "Arguments");
            var argumentsV = tempalloc;
            var assignAst = ast\lvar(SI.set, argumentsV);
            assignAst.Arguments.Add(getArguments);
            block.Add(assignAst);
            
            function getArguments = ast\lvar(argumentsV);
        }
        else
        {
            function getArguments = ast\member(ast\lvar(SI.get, astV), SI.get, "Arguments");
        }
        
        foreach(var argN in var args >> skip(1))
        {
            var assignAst = ast\member(getArguments, SI.get, "Add");
            assignAst.Arguments.Add(argN);
            block.Add(assignAst);
        }
        
        if(argumentsV is not null)
            tempfree(argumentsV);
    }
    
    block.Expression = ast\lvar(SI.get, astV);
    tempfree(astV);
    return block;
}

//Object creation (simple, constant type expressions)
macro ast\new\const as ast\new(typename)
{   
    if(is_in_macro)
        establish_macro_context;
    
    var block = ast("BlockExpression");
    var constructV = tempalloc;
    
    //Create object creation node { $constructV = new ObjectCreation(new ConstantTypeExpression($typename)) }   
    block.Add(ast\args(ast\lvar(SI.set, constructV),
        ast\args(ast\invoke_macro(macro\id(ast)),
            ast\const("ObjectCreation"),
            ast\args(ast\invoke_macro(macro\id(ast)),
                ast\const("ConstantTypeExpression"),
                typename
            )
        )
    ));
    
    //Add constructor arguments to constructor nodes
    var args;
    if(args.Count > 1)
    {
        var argsV = tempalloc;
        var getConstruct = ast\lvar(SI.get, constructV);
        var getArguments = ast\member(getConstruct, SI.get, "Arguments");
        var assignArgs = ast\lvar(SI.set, argsV);
        assignArgs.Arguments.Add(getArguments);
        block.add(assignArgs);
        function getArguments = ast\lvar(SI.get, argsV); 
        
        foreach(var argN in var args >> skip(1))
        {
            var addArgument = ast\member(getArguments, SI.get, "Add");
            addArgument.Arguments.Add(argN);
            block.Add(addArgument);
        }
        
        tempfree(argsV);
    }
    
    //return object creation node
    block.Expression = ast\lvar(SI.get, constructV);
    tempfree(constructV);
    return block;
}

//Aliases for old macro environment variables that are still compatible with the new system
macro macro\deprecated\newvar as newvar
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `newvar` is no longer supported. Use `tempalloc` instead (if you need the variable to be non-temporary, just don't free it at the end).");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "newvar");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\loader as loader
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `loader` is no longer supported. Code that uses the loader directly, needs to be placed in build blocks. There you can use `getLoader` to get a reference to the loader.");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "loader");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\target as target
{
    if(is_in_macro)
    {
        macro\report_error("The macro environment variable `target` is no longer supported. Code that uses the compiler target directly, needs to be placed in build blocks. There you can use `getLoader` to get a reference to the loader, which in turn references the individual compiler targets.");
        return;
    }
    else
    {
        var unr = ast("Unresolved", "target");
        unr.Call = context.Call;
        return unr;
    }
}

macro macro\deprecated\locals as locals
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "locals");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `locals` is deprecated. Access local variable information via the `context` variable instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    var getFunction = ast\member(getContext,SI.get,"Function");
    return ast\member(getFunction, SI.get, "Variables");
}

macro macro\deprecated\callType as callType
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "callType");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `callType` is deprecated. Access the call type via  `context.Call` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "Call");
}

macro macro\deprecated\justEffect as justEffect
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "justEffect");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `justEffect` is deprecated. Access this information via  `context.IsJustEffect` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "IsJustEffect");
}

macro macro\deprecated\macroInvocation as macroInvocation
{
    if(not is_in_macro)
    {
        var unr = ast("Unresolved", "macroInvocation");
        unr.Call = context.Call;
        return unr;
    }
    
    macro\report_warning("The macro environment variable `macroInvocation` is deprecated. Access the reference to the macro invocation via `context.Invocation` instead.");
    
    establish_macro_context;
    
    var getContext = ast\lref(SI.get, Prexonite::Compiler::MacroAliases.ContextAlias);
    return ast\member(getContext, SI.get, "Invocation");
}

//Position report
macro __FILE__ as CURRENT_FILE
{
    if(is_in_macro)
        establish_macro_context;
    return ast("Constant",context.Invocation.File);
}

macro __LINE__ as CURRENT_LINE
{
    if(is_in_macro)
        establish_macro_context;
    return ast("Constant",context.Invocation.Line);
}

macro __COLUMN__ as CURRENT_COLUMN, __COL__
{
    if(is_in_macro)
        establish_macro_context;
    return ast("Constant",context.Invocation.Column);
}

macro __POSITION__ as POSITION, __POS__
{
    if(is_in_macro)
        establish_macro_context;
    var file = System::IO::Path.GetFileName(context.Invocation.File);
    var line = context.Invocation.Line;
    var col = context.Invocation.Column;
    return ast\const("$file, line $line, column $col");
}

macro compile_macros\macro as compile_macros()
{
    if(is_in_macro)
        establish_macro_context;
    var c = ast\cmd(SI.get, Prexonite::Engine.CompileToCilAlias);
    c.Arguments.Add(ast\const(false));
    return c;
}

--- 
meta: 
  _edit_last: "1"
title: A functional touch
published: true
status: publish
tags: 
- Prexonite
- Programming
type: post
layout: post
---
<p>Over the last few days, I've been working on two things: the reorganization of built-in commands and the improvement of the &quot;Functional Experience&quot;.
  <strong>Why do commands need reordering?</strong> 
  Because it gets difficult to find the right file among over 40 commands.
  <strong>Why the sudden increase in numbers?</strong> 
  I added proxies for System.Math methods for both easy and fast access to mathematical functions such as <code>Sqrt</code> and Sin, but also <code>Pi.Additionally</code>, the most important coroutines from the Prexonite Standard Repository for list processing have been implemented in managed code, again for performance reasons. 
</p>
<p>
  Map, Where, Limit, Skip and friends now inject managed coroutines into the stack.
  The commands are now organized in the namespaces Core, List, Math and Text. 
  The latter currently contains the fixed layout functions SetCenter, SetLeft and SetRight, which fill a given string with some character sequence until it has a certain length and is aligned correctly.
</p>
<p>
  Now what the hell do you mean by &quot;<em>Functional Experience</em>&quot;?
  I haven't told anyone but the Prexonite VM is absolutely terrible when it comes to recursion. Unfortunately, recursion happens to be one of the key elements in functional programming and, as you might have noticed, Prexonite Script comes with a lot of syntactic sugar that makes it look like a functional programming language.
  Ok, lambda expressions and closures are &quot;true&quot; functional features but the lack of a sophisticated type system makes it almost impossible to reason about a program in the way functional compilers do. 
</p>
<p>
  Nonetheless, I added two features with the last commit, that make PXS a tiny little bit more functional.
</p>
<h3>First of all: Tail Call Optimization</h3>
<p>
  Yes, the thing that helps with recursion.
</p>
<pre><code>function fac(n,r) =
if(n == 1)
  r
else
  fac(n-1,n*r);
</code></pre>
<p>
  I benchmarked this function three times, with different tail call optimization strategies. The difference is huge. 
  See for yourself (10'000 computations of 16!): 
</p>
<img src="/res/book1-1717-image001-thumb11.gif" alt="Comparison of different tail call optimization strategies." width="490" height="254" />
<p>
  Two strategies are employed: An implementation of tail call optimization for directly recursive functions inside the compiler, that turns recursive calls into direct iterations (jumps to the beginning of the function with different arguments). 
</p>
<p>
  What I call "virtual machine optimization" is a special tail call instruction that removes the current stack frame after having called the function or closure.
  Now apparently the virtual machine "optimization" is not particularly fast but uses far less memory than the normal invocation.
  Prexonite will never be able to recognize indirect recursion due to the lack of control flow analysis. This, however, does not mean that return statements inside conditions or calls in tail position are not recognized. 
</p>
<p>
  I'm not sure if Prexonite will ever handle simple recursive return expressions like the normal definition of the factorial:
</p>
<pre><code>ï»¿function fac n =
if (n==1)
  1
else
  n*fac(n-1);
</code></pre>
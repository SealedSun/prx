/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */



Expr<out IAstExpression expr>
										(.	AstGetSet complex = null; .)
=
	KeyValuePairExpr<out expr>
	{	
		appendright
		GetCall<out complex>			(.	complex.Arguments.RightAppend(expr); 
											complex.Arguments.ReleaseRightAppend();
											expr = complex;
										.)
	}
.

KeyValuePairExpr<out IAstExpression expr>
=
	AtomicExpr<out expr>
	[	colon							(.	IAstExpression value; .)
		Expr<out value>					(.	expr = new AstKeyValuePair(this, expr, value); .)
	]
.

AtomicExpr<out IAstExpression expr>		(.	AstConditionalExpression cexpr = null; expr = null; .)
=	
	OrExpr<out expr>
    {
        question                        (.  cexpr = new AstConditionalExpression(this, expr); .)
        AtomicExpr<out cexpr.IfExpression>
        colon
        AtomicExpr<out cexpr.ElseExpression>  (.  expr = cexpr; .)
    }    
|										(.	bool isNegated = false; .)
	(	if
	|	unless							(.	isNegated = true; .)
	)
	lpar OrExpr<out expr> rpar			(.	cexpr = new AstConditionalExpression(this, expr, isNegated); .)
	AtomicExpr<out cexpr.IfExpression>
    else
    AtomicExpr<out cexpr.ElseExpression>(.  expr = cexpr; .)
.

OrExpr<out IAstExpression expr>
										(. IAstExpression lhs, rhs; .)
=
	AndExpr<out lhs>                    (.  expr = lhs; .)
    [   or OrExpr<out rhs>              (.  expr = new AstLogicalOr(this, lhs, rhs); .)
    ]

.

AndExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitOrExpr<out lhs>                  (.  expr = lhs; .)
    [   and AndExpr<out rhs>            (.  expr = new AstLogicalAnd(this, lhs, rhs); .)
    ]
.

BitOrExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitXorExpr<out lhs>                 (. expr = lhs; .)
    { bitAnd BitXorExpr<out rhs>        (. expr = new AstBinaryOperator(this, expr, BinaryOperator.BitwiseOr, rhs); .)
    }
.

BitXorExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    BitAndExpr<out lhs>                 (.  expr = lhs; .)
    {   xor BitAndExpr<out rhs>
                                        (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.ExclusiveOr, rhs); .)
    }
.

BitAndExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    NotExpr<out lhs>                    (.  expr = lhs; .)
    {   bitAnd NotExpr<out rhs>
                                        (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.BitwiseAnd, rhs); .)
    }
.

NotExpr<out IAstExpression expr>
                                        (. IAstExpression lhs; bool isNot = false; .)
=
    [   not                             (.  isNot = true; .)
    ]
    EqlExpr<out lhs>                    (.  expr = isNot ? new AstUnaryOperator(this, UnaryOperator.LogicalNot, lhs) : lhs; .)
.

EqlExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    RelExpr<out lhs>                    (. expr = lhs; .)
    {   (   eq                          (.  op = BinaryOperator.Equality; .)
        |   ne                          (.  op = BinaryOperator.Inequality; .)    
        ) RelExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

RelExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None;  .)
=
    CoalExpr<out lhs>                   (.  expr = lhs; .)
    {   (   lt                          (.  op = BinaryOperator.LessThan;              .)
        |   le                          (.  op = BinaryOperator.LessThanOrEqual;       .)
        |   gt                          (.  op = BinaryOperator.GreaterThan;           .)
        |   ge                          (.  op = BinaryOperator.GreaterThanOrEqual;    .)
        ) CoalExpr<out rhs>             (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

CoalExpr<out IAstExpression expr>
										(.	IAstExpression lhs, rhs; AstCoalescence coal = new AstCoalescence(this); .)
=
	AddExpr<out lhs>					(.	expr = lhs; coal.Expressions.Add(lhs); .)
	{
		coalescence
		AddExpr<out rhs>				(.	expr = coal; coal.Expressions.Add(rhs); .)
	}
.										

AddExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs,rhs; BinaryOperator op = BinaryOperator.None; .)
=
    MulExpr<out lhs>                    (.  expr = lhs; .)
    {   (   plus                        (.  op = BinaryOperator.Addition;      .)
        |   minus                       (.  op = BinaryOperator.Subtraction;   .) 
        ) MulExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

MulExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    PowExpr<out lhs>                    (.  expr = lhs; .)
    {   (   times                       (.  op = BinaryOperator.Multiply;      .)
        |   div                         (.  op = BinaryOperator.Division;        .)
        |   mod                         (.  op = BinaryOperator.Modulus;       .)
        ) PowExpr<out rhs>              (.  expr = new AstBinaryOperator(this, expr, op, rhs); .)
    }
.

PowExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    PostfixUnaryExpr<out lhs>                  (.  expr = lhs; .)
    {   pow PostfixUnaryExpr<out rhs>          (.  expr = new AstBinaryOperator(this, expr, BinaryOperator.Power, rhs); .)
    }
.

PostfixUnaryExpr<out IAstExpression expr>
                                        (.  IAstType type = null; AstGetSet extension; .)
=
    PrefixUnaryExpr<out expr>   
    {   tilde TypeExpr<out type>        (.  expr = new AstTypecast(this, expr, type); .)
    |   is TypeExpr<out type>           (.  expr = new AstTypecheck(this, expr, type); .)
    |   inc                             (.  expr = new AstUnaryOperator(this, UnaryOperator.PostIncrement, expr); .)
    |   dec                             (.  expr = new AstUnaryOperator(this, UnaryOperator.PostDecrement, expr); .)
    |   GetSetExtension<expr, out extension>
                                        (.  expr = extension; .)
    }
.

PrefixUnaryExpr<out IAstExpression expr>
                                        (.  UnaryOperator op = UnaryOperator.None; .)
=
    {   plus
    |   minus                           (.  op = UnaryOperator.UnaryNegation; .)
    |   inc                             (.  op = UnaryOperator.PreIncrement; .)
    |   dec                             (.  op = UnaryOperator.PreDecrement; .)
    }    
    Primary<out expr>                   (.  if(op != UnaryOperator.None) expr = new AstUnaryOperator(this, op, expr); .)
.

Primary<out IAstExpression expr>
                                        (.  expr = null;
                                            AstGetSet complex = null; bool declared; .)
=
	(.  _pushLexerState(Lexer.Asm); .)	(.	AstBlockExpression blockExpr = new AstBlockExpression(this); .)
    asm lpar { AsmInstruction<blockExpr> } rpar
    (.  _popLexerState(); .)			(.	expr = blockExpr; .)
|   Constant<out expr>
|   CoroutineCreation<out expr>
|   ObjectCreation<out expr>
|   ListLiteral<out expr>
|	HashLiteral<out expr>
|	LoopExpr<out expr>
|   IF(isLambdaExpression())
    LambdaExpression<out expr>
|
    (   lpar Expr<out expr> rpar
    |   GetInitiator<out complex, out declared>
                                        (.  expr = complex; .)
    )
|   LPopExpr lpar Expr<out expr>        (.  //This is a hack that makes string interpolation with expressions possible
                                            //The non-verbal token "LPopExpr" (has no character representation) is 
                                            //returned by the lexer if the parser has to treat an expression in a special
                                            //way. This includes notifying the parser when the expression has been parsed, as
                                            //well as injecting the necessary plus operator.
                                            _popLexerState(); _inject(_plus); .)
    rpar
.

Constant<out IAstExpression expr>
                                        (.  expr = null; int vi; double vr; bool vb; string vs; .)
=
        Integer<out vi>                 (.  expr = new AstConstant(this, vi); .)
    |   Real<out vr>                    (.  expr = new AstConstant(this, vr); .)
    |   Boolean<out vb>                 (.  expr = new AstConstant(this, vb); .)
    |   String<out vs>                  (.  expr = new AstConstant(this, vs); .)
    |   Null							(.  expr = new AstConstant(this, null); .)
.

ListLiteral<out IAstExpression expr>
                                        (.  IAstExpression iexpr = null; 
                                            AstListLiteral lst = new AstListLiteral(this);
                                            expr = lst;
                                        .)
=
    lbrack
    [   Expr<out iexpr>                 (.  lst.Elements.Add(iexpr); .)
        {   comma
            Expr<out iexpr>             (.  lst.Elements.Add(iexpr); .)
        }
    ]
    rbrack
.

HashLiteral<out IAstExpression expr>
										(.	IAstExpression iexpr = null; 
											AstHashLiteral hash = new AstHashLiteral(this);
											expr = hash;
										.)
=
	lbrace
	[	Expr<out iexpr>					(.	hash.Elements.Add(iexpr); .)
		{	comma
			Expr<out iexpr>				(.	hash.Elements.Add(iexpr); .)
		}
	]
	rbrace
.

LoopExpr<out IAstExpression expr>
										(.	AstBlock dummyBlock = new AstBlock(this);
										.)
=
	(	WhileLoop<dummyBlock>
	|	ForLoop<dummyBlock>
	|	ForeachLoop<dummyBlock>
	)									(.	expr = new AstLoopExpression(this, (AstLoop) dummyBlock.Statements[0]); .)
.										
											

ObjectCreation<out IAstExpression expr>
                                        (.  IAstType type; expr = null; .)
=
    new TypeExpr<out type>              (.  AstObjectCreation creation = new AstObjectCreation(this, type); .)
    [   Arguments<creation.Arguments>  
    ]                                   (.  expr = creation; .)
.

CoroutineCreation<out IAstExpression expr>
                                        (.  
                                            AstCreateCoroutine cor = new AstCreateCoroutine(this); 
                                            IAstExpression iexpr;
                                            expr = cor;
                                        .)
=
    coroutine Expr<out iexpr>           (.  cor.Expression = iexpr; .)
    [ for Arguments<cor.Arguments> ]
.

LambdaExpression<out IAstExpression expr>
                                        (.  expr = null;
                                            PFunction func = new PFunction(TargetApplication, generateNestedFunctionId());                                             
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            TargetApplication.Functions.Add(func);
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            CompilerTarget ft = FunctionTargets[func];
                                            ft.ParentTarget = target;
                                        .)
=
(   FormalArg<ft>
|   lpar
    [	FormalArg<ft> 
	    {	comma
		    FormalArg<ft>
	    }
    ]
    rpar
)
                                        (.
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
implementation                                        
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)
                                        (.
                                            target = oldTarget;
                                            if(errors.count == 0)
                                            {
                                                Ast[func].EmitCode(FunctionTargets[func]);
                                                FunctionTargets[func].FinishTarget();
                                            }
                                            
                                            expr = new AstCreateClosure(this, func.Id);                                         
                                        .)
.

ExplicitTypeExpr<out IAstType type>     (.  type = null; .)
=
    tilde PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

TypeExpr<out IAstType type>             (.  type = null; .)
=
    PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

ClrTypeExpr<out IAstType type>          
                                        (.  string id; .)
=
                                        (.  StringBuilder typeId = new StringBuilder(); .)
    (   doublecolon
    |   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    )
    {   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    }
    Id<out id>                          (.  typeId.Append(id);
                                            type = new AstConstantTypeExpression(this, 
                                                "Object(\"" + StringPType.Escape(typeId.ToString()) + "\")");
                                        .)
.

PrexoniteTypeExpr<out IAstType type>
                                        (.  string id = null; type = null; .)
=
    ( Id<out id> | null                 (.  id = NullPType.Literal; .)                          
    )
                                        (.  AstDynamicTypeExpression dType = new AstDynamicTypeExpression(this, id); .)
    [   lt
        [   TypeExprElement<dType.Arguments>   
            { comma TypeExprElement<dType.Arguments> }
        ]
        gt
    ]
                                        (.  type = dType; .)
.

TypeExprElement<. List<IAstExpression> args .>
                                        (.  IAstExpression expr; IAstType type; .)
=
    Constant<out expr>                  (.  args.Add(expr); .)
|   ExplicitTypeExpr<out type>          (.  args.Add(type); .)
|   lpar Expr<out expr> rpar            (.  args.Add(expr); .)
.
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite	
                            (.  PFunction func; .)				
=
    {	[   GlobalVariableDefinition
      |   MetaAssignment<TargetApplication>
      ]   SYNC semicolon
    | Declaration2
    |	GlobalCode
    | BuildBlock
    |	FunctionDefinition<out func>
    }
    EOF
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable metaTable>	(. string key = null; MetaEntry entry = null; .)
=
(	is  					(. entry = true; .)
  [not					(. entry = false; .)
  ]
  GlobalId<out key>
|   not                     (. entry = false; .)
    GlobalId<out key>
|
  GlobalId<out key>
  ( enabled				(. entry = true; .)
  | disabled  			(. entry = false; .)
  | MetaExpr<out entry>
    |                       (. entry = true; .)
  )
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(metaTable.Meta.ContainsKey(key))
                                {
                                    entry = metaTable.Meta[key];
                                    entry = entry.AddToList(subEntry.List);
                                }
                                else
                                {
                                   entry = subEntry;
                                }
                            .)
)							(. if(entry == null || key == null) 
                                    SemErr("Meta assignment did not generate an entry.");
                               else 
                                    metaTable.Meta[key] = entry; 
                            .)	
.

MetaExpr<out MetaEntry entry>
              (. bool sw; int i; double r; entry = null; string str; .)
=							
  Boolean<out sw>			(. entry = sw; .)
|	Integer<out i>			(. entry = i.ToString(CultureInfo.InvariantCulture); .)
|	Real<out r>				(. entry = r.ToString(CultureInfo.InvariantCulture); .)
|   String<out str>         (. entry = str; .)
|   GlobalQualifiedId<out str>       (. entry = str; .)
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); 
                               MetaEntry subEntry; 
                               bool lastWasEmpty = false;
                            .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   comma           (. if(lastWasEmpty)
                                    SemErr("Missing meta expression in list (two consecutive commas).");
                            .)
            (   MetaExpr<out subEntry> 
                            (. lst.Add(subEntry); 
                               lastWasEmpty = false;
                            .)
            |               (. lastWasEmpty = true; .)   
            )
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition	(.  
                                string id = null; 
                                List<string> aliases = new List<string>();
                                string primaryAlias = null;
                                VariableDeclaration vari; 
                                SymbolInterpretations type = SymbolInterpretations.GlobalObjectVariable; 
                                SymbolEntry entry;
                            .)
=

  (   var                 
  |   ref                 (.  type = SymbolInterpretations.GlobalReferenceVariable; .)
  )
  
  (   GlobalId<out id>    (.  primaryAlias = id; .)
      [ GlobalVariableAliasList<aliases> ]
  |   GlobalVariableAliasList<aliases>
                          (.  id = Engine.GenerateName("v"); .)
  )
                          (.
                                entry = new SymbolEntry(type,id, TargetModule.Name);
                              foreach(var alias in aliases)
                                  Symbols.Declare(alias, entry.ToSymbol());
                                DefineGlobalVariable(id,out vari);
                          .)
  [	lbrack  		    //Meta block for variables
    [   MetaAssignment<vari>
            {	semicolon
                [ MetaAssignment<vari> ]
        }
        ]
    rbrack
  ]                       (.  if(primaryAlias != null && !_suppressPrimarySymbol(vari))
                                    Symbols.Declare(primaryAlias, entry.ToSymbol());
                          .)
  [	                      (.  _pushLexerState(Lexer.Local); .)
      assign              (.  _PushScope(FunctionTargets[Application.InitializationId]);
                              AstExpr expr;
                          .)
    Expr<out expr>
                          (.  _popLexerState();
                              if(errors.count == 0)
                              {
                                AstGetSet complex = new AstGetSetSymbol(this, PCall.Set, 
                                                      new SymbolEntry(InterpretAsObjectVariable(type), id, TargetModule.Name));
                                complex.Arguments.Add(expr);
                                target.Ast.Add(complex);
                                                  TargetApplication._RequireInitialization();
                                Loader._EmitPartialInitializationCode();
                                          }
                              _PopScope(FunctionTargets[Application.InitializationId]);
                          .)
  ]
.

GlobalVariableAliasList<. IList<string> aliases .>
                            (.  string id; .)
=
    as GlobalId<out id>     (.  aliases.Add(id); .)
    {   comma
        [ GlobalId<out id>  (.  aliases.Add(id); .) 
        ]
    }
.

/* ---- Global declaration ---- */

SymbolPrefix<SymbolBuilder symbol, out bool canBeRef> 
                            (. canBeRef = true; .) // in order to avoid further errors when this production fails
= 
  ref                       (.  symbol.Dereference(); .)
| pointer                   (.  symbol.ReferenceTo(); canBeRef = false; .)
.

EntityFactory<. bool canBeRef, out Func<string,ModuleName,EntityRef> entityFactory .> 
                            (.  entityFactory = null; .)
= var                       (.  entityFactory = EntityRef.Variable.Global.Create; .)
| function                  (.  entityFactory = EntityRef.Function.Create; .)
| command                   (.  entityFactory = (id,_) => EntityRef.Command.Create(id); .)
| macro             
  ( function                (.  entityFactory = EntityRef.Function.Create; .)
  | command                 (.  entityFactory = (id,_) => EntityRef.MacroCommand.Create(id); .)
  | var                     (.  entityFactory = EntityRef.Variable.Global.Create; .)
  )
|                           (.  if(canBeRef) 
                                {
                                  entityFactory = EntityRef.Variable.Global.Create;
                                }
                                else
                                {
                                  // entityFactory already set to null
                                }                                
                            .)
.

Declaration2
                            (. ModuleName module = TargetModule.Name;
                               SymbolBuilder builder = new SymbolBuilder();
                               Func<string,ModuleName,EntityRef> entityFactory;
                               bool canBeRef = false;
                            .)
=
SYNC
  declare
    (   { SymbolPrefix<builder, out canBeRef> }
        EntityFactory<canBeRef, out entityFactory>
        ( colon
        |                   (.  Loader.ReportMessage(Message.Warning(
                                  Resources.Parser_DeclarationTypeShouldBeFollowedByColon,
                                  GetPosition(),
                                  MessageClasses.MissingColonInDeclaration));
                            .)
        )
        DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false>
        { comma [ DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:false> ] }
        semicolon
    |   lbrace
        [   uusing ModuleName<out module> ]
        {
          { SymbolPrefix<builder, out canBeRef> }
          EntityFactory<canBeRef, out entityFactory> 
          colon
          DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:true>
          { comma [ DeclarationInstance2<entityFactory,module,builder.Clone(),preventOverride:true> ] }
        }
        rbrace
    )
.

MessageDirective<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  MessageSeverity severity,
  bool preventOverride = false .> 
                            (.  string message;
                                string messageClass = null;
                                ISourcePosition position = GetPosition();
                                string file;
                                int line;
                                int column;
                            .)
  =
  lpar
  (null|String<out messageClass>) 
  [ colon
    ( null
    | String<out file> colon Integer<out line> colon Integer<out column>
                            (.  position = new SourcePosition(file,line,column); .)
    )
  ]
  comma
  String<out message>
  comma                     (.  builder.Messages.Add(Message.Create(severity,message,position,messageClass)); .)
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
  rpar
.

SymbolDirective<. Func<string,ModuleName,EntityRef> entityFactory, 
  [CanBeNull] ModuleName module, 
  SymbolBuilder builder,
  [CanBeNull] out string lhsId,
  bool preventOverride = false .>
                            (.  lhsId = null;  .)
=
  null                      (.  /* don't do anything */ .)
| ( ref                     (.  builder.Dereference(); .)
  | pointer                 (.  builder.ReferenceTo(); .)
  )
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
|	IF(isSymbolDirective("INFO"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Info,preventOverride:preventOverride>
|	IF(isSymbolDirective("WARN"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Warning,preventOverride:preventOverride>
|	IF(isSymbolDirective("ERROR"))
  id
  MessageDirective<entityFactory,module,builder, out lhsId,MessageSeverity.Error,preventOverride:preventOverride>
|                           (. ISourcePosition position = GetPosition(); .)
  Id<out lhsId>                
  [ div ModuleName<out module> 
                            (.  if(preventOverride) 
                                {
                                    Loader.ReportMessage(Message.Error(
                                      "Specification of module name illegal at this point.",
                                      position  ,
                                      MessageClasses.UnexpectedModuleName)); 
                                    // Let control fall through, this is not a fatal error,
                                    //  just an enforcement of a stylistic rule.
                                }
                            .)
  ]                         (.  if(entityFactory != null)
                                {
                                  builder.Entity = entityFactory(lhsId,module);
                                }
                            .)
.

DeclarationInstance2<.
  Func<string,ModuleName,EntityRef> entityFactory, 
  ModuleName module, 
  SymbolBuilder builder,
  bool preventOverride = false .>
                            (.  string lhsId;
                                string rhsId; 
                                ISourcePosition position = GetPosition(); 
                            .)
=		
  SymbolDirective<entityFactory,module,builder,out lhsId,preventOverride:preventOverride>
                            (.  rhsId = lhsId; .)
  [ as Id<out rhsId> ]
                            (.  
                                if(entityFactory == null) 
                                {
                                  // We are declaring an alias to an existing symbol
                                  Symbol existing;   
                                  if(lhsId == null)
                                  {
                                    if(rhsId == null)
                                    {
                                      Loader.ReportMessage(Message.Error(
                                        "This symbol declaration requires an alias (e.g., `as theAlias`)", 
                                        GetPosition(), 
                                        MessageClasses.SymbolAliasMissing));
                                      // Since there is no name involved, not acting on this
                                      //  statement will not cause further errors
                                    }
                                    else if(builder.IsTerminatedByError)
                                    {
                                      Symbols.Declare(rhsId, builder.WrapSymbol(null));
                                    }
                                    else
                                    {
                                      var msg = Message.Error(
                                        "Symbol name missing for declaration of alias. Warning and information message symbols need to wrap an existing symbol.", 
                                        GetPosition(), 
                                        MessageClasses.OnlyErrorStandalone);
                                      Loader.ReportMessage(msg);
                                      Symbols.Declare(rhsId, builder.WrapSymbol(MessageSymbol.Create(msg,null)));
                                    }
                                  }                             
                                  else if(Symbols.TryGet(lhsId,out existing)) 
                                  {
                                    // Declare $rhsId as an alias for the symbol that $lhsId points to
                                    Symbols.Declare(rhsId, builder.WrapSymbol(existing));
                                  } 
                                  else
                                  {
                                    var msg = Message.Error("Could not find previous declaration for symbol " + lhsId + ".",
                                                            position,MessageClasses.SymbolNotResolved);
                                    // We report the message AND store it as a message symbol.
                                    //  That way, the symbol is at least declared, avoiding a spurious 
                                    //  symbol not found message.
                                    Loader.ReportMessage(msg);
                                    Symbols.Declare(rhsId, MessageSymbol.Create(msg,null));                                      
                                  }
                                }
                                else
                                {
                                  
                                  if(lhsId == null)
                                  {
                                    // For instance `declare var error(...,null)` can get us here
                                    var msg = Message.Error("Entity name missing for declaration of a fresh symbol",
                                      GetPosition(),
                                      MessageClasses.EntityNameMissing);
                                    Loader.ReportMessage(msg);
                                    // Also create an error symbol for the alias (if one was declared)
                                    if(rhsId != null)
                                      Symbols.Declare(rhsId, MessageSymbol.Create(msg,null));
                                  }
                                  else
                                  {
                                    // Use the builder to create a new symbol.
                                    Symbols.Declare(rhsId, builder.ToSymbol());
                                  }                                  
                                }
                            .)
.

ModuleName<out ModuleName moduleName> 
                            (.  _pushLexerState(Lexer.YYINITIAL); //need global scope for Version
                                string id; 
                                Version version = null;
                            .)
=
    Id<out id>
    [   div
        Version<out version>    
    ]                       (.  _popLexerState();
                                moduleName = Loader.Cache[new ModuleName(id,version ?? new Version(0,0))];
                            .)
.

/* ---- Build Block ---- */

BuildBlock
=
  SYNC build                (.  PFunction func = TargetApplication.CreateFunction();
                                CompilerTarget buildBlockTarget = 
                                  Loader.CreateFunctionTarget(func, sourcePosition: GetPosition());
                                _PushScope(buildBlockTarget);
                                Loader.DeclareBuildBlockCommands(target);
                                _pushLexerState(Lexer.Local);                                
                            .)
  
  [ does ]	
  StatementBlock<target.Ast>
  
                            (.  _popLexerState();                                    
                                  _PopScope(buildBlockTarget);
                                  _compileAndExecuteBuildBlock(buildBlockTarget);
                            .)
.

/* ---- Global Code ---- */

GlobalCode				(.  PFunction func = TargetApplication._InitializationFunction;
                      CompilerTarget ft = FunctionTargets[func];
                      ISourcePosition position;
                      if(ft == null)
                          throw new PrexoniteException("Internal compilation error: InitializeFunction got lost.");
                  .)
=
                  (.	_PushScope(ft); 
                      _pushLexerState(Lexer.Local);
                  .)
  lbrace          (.  position = GetPosition(); .)
  { Statement<target.Ast> } 
  rbrace
                  (.
                     try {
                        if(errors.count == 0)
                        {
                          TargetApplication._RequireInitialization();
                          Loader._EmitPartialInitializationCode();
                        }
                                        } catch(Exception e) {
                                            Loader.ReportMessage(Message.Error(
                                              "Exception during compilation of initialization code.\n" + e,
                                              position,
                                              MessageClasses.ExceptionDuringCompilation));
                                        } finally {
                        //Symbols defined in this block are not available to further global code blocks
                        target.Symbols.ClearLocalDeclarations();
                        _PopScope(ft);
                        _popLexerState();
                    }
                  .)
.

/* ---- Function definition ---- */

FunctionAliasList<. IList<string> aliases .> 
                                    (.  String id; .)
=
    as Id<out id>                   (.  aliases.Add(id); .)
    {   comma 
        [   Id<out id>              (.  aliases.Add(id); .)
        ]
    }
.

FunctionDefinition<out PFunction func>
                                    (.  
                                        string primaryAlias = null;
                                        List<string> funcAliases = new List<string>();
                                        string id = null; //The logical id (given in the source code)
                                        string funcId; //The "physical" function id
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        bool isMacro = false;
                                        bool isLazy = false;
                                        PFunction derBody = null; //The derived (coroutine/lazy) body function (carries a different name)
                                        PFunction derStub = null; //The derived (coroutine/lazy) stub function (carries the name(s) specified)
                                        string derId; //The name of the derived stub
                                        CompilerTarget ct = null;   //The compiler target for the function (as mentioned in the source code)
                                        CompilerTarget cst = null;  //The compiler target for a stub (coroutine/lazy)
                                        SymbolEntry symEntry = null;

                                        bool missingArg = false; //Allow trailing comma, but not (,,) in formal arg list
                                    .)         
=	
  (   lazy [function]             (.  isLazy = true; .)
  |   function
  |   coroutine                   (.  isCoroutine = true; .)
  |   macro [function]            (.  isMacro = true; .)
  )
  (   Id<out id>                  (.  primaryAlias = id; .)
      [ FunctionAliasList<funcAliases> ]
  |   FunctionAliasList<funcAliases>
  )                               (.  
                                      funcId = id ?? Engine.GenerateName("f");
                                        if(Engine.StringsAreEqual(id, @"\init")) //Treat "\init" specially (that's the initialization code)
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                SemErr("Cannot define initialization code inside another function.");
                                            if(isCoroutine)
                                                SemErr("Cannot define initialization code as a coroutine.");
                                            if(isLazy)
                                                SemErr("Cannot define initialization code as a lazy function.");
                                            if(isMacro)
                                                SemErr("Cannot define initialization code as a macro function.");
                                        }
                                        else
                                        {
                                            var localId = id;
                                            
                                            if(isNested)
                                            {
                                                if(isMacro)
                                                    SemErr("Inner macros are illegal. Macros must be top-level.");
                                                    
                                                funcId = generateLocalId(id ?? "inner");
                                                
                                                if(string.IsNullOrEmpty(localId))
                                                {
                                                    //Create shadow name
                                                    localId = generateLocalId(id ?? "inner");
                                                }
                                                SmartDeclareLocal(localId, SymbolInterpretations.LocalReferenceVariable);
                                                foreach(var alias in funcAliases)
                                                        SmartDeclareLocal(alias, localId, SymbolInterpretations.LocalReferenceVariable, false);
                                                
                                            }
                                            
                                            //Add function to application
                                            if(TargetApplication.Functions.Contains(funcId) && !TargetApplication.Meta.GetDefault(Application.AllowOverridingKey,true))
                        SemErr(t,"Application " + TargetApplication.Id + " does not allow overriding of function " + funcId + ".");
                                            TargetApplication.Functions.Remove(funcId);

                                            func = TargetApplication.CreateFunction(funcId);
                                            
                                            if(isNested)
                                            {
                                                 func.Meta[PFunction.LogicalIdKey] = localId;
                                                 if(isLazy)
                                                    mark_as_let(target.Function,localId);
                                            }
                                            
                                            Loader.CreateFunctionTarget(func, target, GetPosition());
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        
                                        //Generate derived stub
                                        if(isCoroutine || isLazy)
                                        {
                                            derStub = func;
                                            
                                            //Create derived body function
                                            derId = ft.GenerateLocalId();
                                            derBody = TargetApplication.CreateFunction(derId);
                                            Loader.CreateFunctionTarget(derBody, ft, GetPosition());
                                            derBody.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                            if(isCoroutine)
                                            {
                                                derBody.Meta[PFunction.VolatileKey] = true;
                                                derBody.Meta[PFunction.DeficiencyKey] = "Coroutine body can only be executed by VM anyway.";
                                                derBody.Meta[Coroutine.IsCoroutineKey] = true;
                                            }

                                            //Swap compiler target references
                                            // -> Compile source code into derived body
                                            // -> Let derived stub have the physical function id
                                            ct = FunctionTargets[derBody];
                                            cst = ft;
                                        }
                                        
                                        if(isNested) //Link to parent in case of a nested function
                                        {                                           
                                            if(isLazy)
                                                ft = ct;
                                        }	                                    
                                  .)
    [   lpar
      [	FormalArg<ft> 
        {	comma               (.  if(missingArg)
                                        {
                                            SemErr("Missing formal argument (two consecutive commas).");
                                        } 
                                    .)
          (   FormalArg<ft>   (.  missingArg = false; .)
                |                   (.  missingArg = true; .)
                )
        }
      ]
      rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
  ]	                            (.  if(isNested && isLazy) // keep this assignment for maintainability
                                    // ReSharper disable RedundantAssignment
                                        ft = cst;
                                    // ReSharper restore RedundantAssignment
                                      
                                      if(target == null && 
                                          (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)) &&
                                          (!isNested))
                                      {
                                              //Add the name to the symbol table
                                                symEntry = 
                                                    new SymbolEntry(SymbolInterpretations.Function, func.Id, TargetModule.Name);
                                              foreach(var alias in funcAliases)	                                                
                                                  Symbols.Declare(alias, symEntry.ToSymbol());
                                              
                                              //Store the original (logical id, mentioned in the source code)
                                              func.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                      }
                                        else
                                        {
                                            primaryAlias = null;
                                        }
                                      
                                      //Target the derived (coroutine/lazy) body instead of the stub
                                        if(isCoroutine || isLazy)
                                            func = derBody;
                                  .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        [   MetaAssignment<func>
            {   semicolon
                [MetaAssignment<func>]
            }
        ]
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  
                                    
                                        if(primaryAlias != null && !_suppressPrimarySymbol(func))
                                            Symbols.Declare(primaryAlias, symEntry.ToSymbol());

                                        //Imprint certain meta keys from parent function
                                        if(isNested)
                                        {
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                        }

                                        //Copy stub parameters to body of lazy function
                                        if(isLazy && !isNested)
                                      {
                                          foreach(var kvp in cst.Symbols.LocalDeclarations)
                                          {
                                              var paramId = kvp.Key;
                                              var s = kvp.Value.ToSymbolEntry();
                                              //Lazy functions cannot have ref parameters
                                              if(s.Interpretation != SymbolInterpretations.LocalObjectVariable)
                                                  SemErr("Lazy functions can only have value parameters (ref is not allowed)");
                                              ct.Function.Parameters.Add(s.InternalId);
                                              ct.Symbols.Declare(paramId, kvp.Value);
                                          }
                                      }
                                    
                    if(isLazy || isCoroutine)
                    {
                      //Push the stub, because it is the lexical parent of the body
                      _PushScope(cst);
                    }
                                        _PushScope(FunctionTargets[func]);
                                        Debug.Assert(target != null); // Mostly to tell ReSharper that target is not null.
                                        _pushLexerState(Lexer.Local);
                                        if(isMacro)
                                            target.SetupAsMacro();
                                    .)
    (   [ does ]
        StatementBlock<target.Ast>
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        _PopScope(FunctionTargets[func]);
                    if(isLazy || isCoroutine)
                    {
                      _PopScope(cst);
                    }
                                        //Compile AST
                                        if(errors.count == 0)
                                        {
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                try {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of initialization code." + e);
                                                }
                                            }
                                            else
                                            {
                                                try {
                                                //Apply compiler hooks for all kinds of functions (lazy/coroutine/macro)
                        FunctionTargets[func].ExecuteCompilerHooks();
                        //Emit code for top-level block
                                                Ast[func].EmitCode(FunctionTargets[func], true, StackSemantics.Effect);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of function body of " + id + ". " + e);
                                                }
                                            }                                       
                                            
                      if(isCoroutine)
                      {
                                                try {
                            //Stub has to be returned into the physical slot mentioned in the source code
                            func = derStub;
                            //Generate code for the stub
                            AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
                            crcor.Expression = new AstCreateClosure(this, 
                                                        new SymbolEntry(SymbolInterpretations.Function, derBody.Id, 
                                                        derBody.ParentApplication.Module.Name));
                            AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
                            retst.Expression = crcor;
                            cst.Ast.Add(retst);
                            //Emit code for top-level block
                            cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                            cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of coroutine stub for " + id + ". " + e);
                                                }
                      }
                      else if(isLazy)
                      {
                          derStub.Meta[PFunction.LazyKey] = true;
                          derStub.Meta["strict"] = true;
                      
                          //Stub has to be returned into the physical slot mentioned in the source code
                          func = derStub;
                          
                          //Generate code for the stub
                          AstExpr retVal;										    
                            
                            if(isNested)
                            {
                                //Nested lazy functions need a stub to capture their environment by value (handled by NestedFunction)
                                
                                //Generate stub code
                                retVal = new AstCreateClosure(this,  new SymbolEntry(SymbolInterpretations.Function, ct.Function.Id, 
                                                ct.Function.ParentApplication.Module.Name));
                                
                                //Inject asthunk-conversion code into body
                                var inject = derStub.Parameters.Select(par => 
                                {
                                    var getParam =
                                        new AstGetSetSymbol(this, PCall.Get, 
                                                                SymbolEntry.LocalObjectVariable(par));
                                    var asThunkCall = 
                                      new AstGetSetSymbol(this, PCall.Get, 
                                                                SymbolEntry.Command(Engine.AsThunkAlias));
                                  asThunkCall.Arguments.Add(getParam);
                                  var setParam =
                                      new AstGetSetSymbol(this, PCall.Set, 
                                                                SymbolEntry.LocalObjectVariable(par));
                                  setParam.Arguments.Add(asThunkCall);
                                  return (AstNode) setParam;
                                });
                                ct.Ast.InsertRange(0,inject);
                            }
                            else
                            {										            
                                //Global lazy functions don't technically need a stub. Might be removed later on
                                var call = new AstGetSetSymbol(this, 
                                                        new SymbolEntry(SymbolInterpretations.Function, ct.Function.Id, TargetModule.Name));
                                
                                //Generate code for arguments (each wrapped in a `asThunk` command call)
                              foreach(var par in derStub.Parameters)
                              {
                                  var getParam = 
                                      new AstGetSetSymbol(this, PCall.Get, 
                                                                SymbolEntry.LocalObjectVariable(par));
                                  var asThunkCall = 
                                      new AstGetSetSymbol(this, PCall.Get, 
                                                                SymbolEntry.Command(Engine.AsThunkAlias));
                                  asThunkCall.Arguments.Add(getParam);
                                  call.Arguments.Add(asThunkCall);
                              }
                              
                              retVal = call;
                            }								    
                          
                          
                          //Assemble return statement
                          var ret = new AstReturn(this, ReturnVariant.Exit);
                          ret.Expression = retVal;
                          
                          cst.Ast.Add(ret);
                          
                                                try {
                          //Emit code for stub
                          cst.Ast.EmitCode(cst,true,StackSemantics.Effect);
                          cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy function stub for " + id + ". " + e);
                                                }
                      }                                        
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
=
  [ var | ref                     (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
  ]
  Id<out id>                      (.  
                                      //Note: lazy functions need to copy the
                                      //  parameters of the stub to the body!
                                      ft.Function.Parameters.Add(id); 
                                      ft.Symbols.Declare(id, new SymbolEntry(kind, id, null).ToSymbol());
                                  .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId  String<out id>           (.  id = cache(id); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   ns                              (.  StringBuilder buffer = new StringBuilder(t.val); buffer.Append('.'); .)
    {   ns                          (.  buffer.Append(t.val); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = cache(buffer.ToString()); .)
.
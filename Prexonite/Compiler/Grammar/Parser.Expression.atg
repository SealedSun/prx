/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


Expr<out AstExpr expr>		    (.	AstConditionalExpression cexpr = null; expr = null; .)
=	
	AtomicExpr<out expr>   
|										(.	bool isNegated = false; .)
	(	if
	|	unless							(.	isNegated = true; .)
	)
	lpar Expr<out expr> rpar			(.	cexpr = new AstConditionalExpression(this, expr, isNegated); .)
	Expr<out cexpr.IfExpression>
    else
    Expr<out cexpr.ElseExpression>      (.  expr = cexpr; .)
.


AtomicExpr<out AstExpr expr>
                                        (.  AstExpr outerExpr = null; .)
=
    AppendRightExpr<out expr>
    {
        then
        AppendRightExpr<out outerExpr>  (.  AstGetSetSymbol thenExpr = new AstGetSetSymbol(
                                                this, PCall.Get, SymbolEntry.Command(Engine.ThenAlias));
                                            thenExpr.Arguments.Add(expr);
                                            thenExpr.Arguments.Add(outerExpr);
                                            expr = thenExpr;
                                        .)
    }
.


AppendRightExpr<out AstExpr expr>
										(.	AstGetSet complex = null; .)
=
	KeyValuePairExpr<out expr>
	{	
		appendright
		GetCall<out complex>		    (.	complex.Arguments.RightAppend(expr); 
										    complex.Arguments.ReleaseRightAppend();
										    if(complex is AstGetSetSymbol 
                                                    && ((AstGetSetSymbol)complex).IsObjectVariable)
										        complex.Call = PCall.Set;
										    expr = complex;										    
									    .)
	}
.

KeyValuePairExpr<out AstExpr expr>
=
	OrExpr<out expr>
	[	colon							(.	AstExpr value; .)
		KeyValuePairExpr<out value>		(.	expr = new AstKeyValuePair(this, expr, value); .)
	]
.

OrExpr<out AstExpr expr>
										(. AstExpr lhs, rhs; .)
=
	AndExpr<out lhs>                    (.  expr = lhs; .)
    [   or OrExpr<out rhs>              (.  expr = new AstLogicalOr(this, lhs, rhs); .)
    ]

.

AndExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; .)
=
    BitOrExpr<out lhs>                  (.  expr = lhs; .)
    [   and AndExpr<out rhs>            (.  expr = new AstLogicalAnd(this, lhs, rhs); .)
    ]
.

BitOrExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; .)
=
    BitXorExpr<out lhs>                 (. expr = lhs; .)
    { bitOr BitXorExpr<out rhs>         (. expr = AstBinaryOperator.Create(this, expr, BinaryOperator.BitwiseOr, rhs); .)
    }
.

BitXorExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    BitAndExpr<out lhs>                 (.  expr = lhs; .)
    {   xor BitAndExpr<out rhs>
                                        (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.ExclusiveOr, rhs); .)
    }
.

BitAndExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    NotExpr<out lhs>                    (.  expr = lhs; .)
    {   bitAnd NotExpr<out rhs>
                                        (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.BitwiseAnd, rhs); .)
    }
.

NotExpr<out AstExpr expr>
                                        (. AstExpr lhs; bool isNot = false; .)
=
    [   not                             (.  isNot = true; .)
    ]
    EqlExpr<out lhs>                    (.  expr = isNot ? AstUnaryOperator._Create(this, UnaryOperator.LogicalNot, lhs) : lhs; .)
.

EqlExpr<out AstExpr expr>
                                        (. AstExpr lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    RelExpr<out lhs>                    (. expr = lhs; .)
    {   (   eq                          (.  op = BinaryOperator.Equality; .)
        |   ne                          (.  op = BinaryOperator.Inequality; .)    
        ) RelExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

RelExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; BinaryOperator op = BinaryOperator.None;  .)
=
    CoalExpr<out lhs>                   (.  expr = lhs; .)
    {   (   lt                          (.  op = BinaryOperator.LessThan;              .)
        |   le                          (.  op = BinaryOperator.LessThanOrEqual;       .)
        |   gt                          (.  op = BinaryOperator.GreaterThan;           .)
        |   ge                          (.  op = BinaryOperator.GreaterThanOrEqual;    .)
        ) CoalExpr<out rhs>             (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

CoalExpr<out AstExpr expr>
										(.	AstExpr lhs, rhs; AstCoalescence coal = new AstCoalescence(this); .)
=
	AddExpr<out lhs>					(.	expr = lhs; coal.Expressions.Add(lhs); .)
	{
		coalescence
		AddExpr<out rhs>				(.	expr = coal; coal.Expressions.Add(rhs); .)
	}
.										

AddExpr<out AstExpr expr>
                                        (.  AstExpr lhs,rhs; BinaryOperator op = BinaryOperator.None; .)
=
    MulExpr<out lhs>                    (.  expr = lhs; .)
    {   (   plus                        (.  op = BinaryOperator.Addition;      .)
        |   minus                       (.  op = BinaryOperator.Subtraction;   .) 
        ) MulExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

MulExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    PowExpr<out lhs>                    (.  expr = lhs; .)
    {   (   times                       (.  op = BinaryOperator.Multiply;      .)
        |   div                         (.  op = BinaryOperator.Division;        .)
        |   mod                         (.  op = BinaryOperator.Modulus;       .)
        ) PowExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

PowExpr<out AstExpr expr>
                                        (.  AstExpr lhs, rhs; .)
=
    AssignExpr<out lhs>                  (.  expr = lhs; .)
    {   pow AssignExpr<out rhs>          (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.Power, rhs); .)
    }
.

AssignExpr<out AstExpr expr>     (.  AstGetSet assignment; BinaryOperator setModifier = BinaryOperator.None;
                                            AstTypeExpr T;
                                        .)
=
    PostfixUnaryExpr<out expr>
    (IF(isAssignmentOperator())
                                       (.  assignment = expr as AstGetSet;
                                            if(assignment == null) 
                                            {
                                                SemErr(string.Format("Cannot assign to a {0}",
                                                    expr.GetType().Name));
                                                assignment = new AstGetSetSymbol(this, PCall.Get, 
                                                    SymbolEntry.LocalObjectVariable("SEMANTIC_ERROR")); //to prevent null references
                                            }
                                            assignment.Call = PCall.Set;
                                        .)
        (
            (   assign                  (.  setModifier = BinaryOperator.None; .)
	        |   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	        |   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	        |   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	        |   div assign              (.  setModifier = BinaryOperator.Division; .)
	        |   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	        |   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	        |	coalescence assign		(.	setModifier = BinaryOperator.Coalescence; .)
	        )   Expr<out expr>        //(.  expr = expr; .)
	        
	    |   (   tilde  assign           (.  setModifier = BinaryOperator.Cast; .)
	        )TypeExpr<out T>            (.  expr = T; .)
	    )                               
	                                    (.  assignment.Arguments.Add(expr); 
	                                        if(setModifier == BinaryOperator.None)
	                                            expr = assignment;
	                                        else
	                                            expr = AstModifyingAssignment.Create(this,setModifier, assignment);
                                        .)        
    |)
.

PostfixUnaryExpr<out AstExpr expr>
                                        (.  AstTypeExpr type = null; AstGetSet extension; bool isInverted = false; .)
=
    PrefixUnaryExpr<out expr>   
    {   tilde TypeExpr<out type>        (.  expr = new AstTypecast(this, expr, type); .)
    |   is	[ not						(.	isInverted = true; .) ]
    		 TypeExpr<out type>         (.  expr = new AstTypecheck(this, expr, type);
    										if(isInverted)
                                            {
                                                ((AstTypecheck)expr).IsInverted = true;
    											expr = AstUnaryOperator._Create(this, UnaryOperator.LogicalNot, expr);
                                            }
    									.)
    |   inc                             (.  expr = AstUnaryOperator._Create(this, UnaryOperator.PostIncrement, expr); .)
    |   dec                             (.  expr = AstUnaryOperator._Create(this, UnaryOperator.PostDecrement, expr); .)
    |   GetSetExtension<expr, out extension>
                                        (.  expr = extension; .)
    }
.

PrefixUnaryExpr<out AstExpr expr>
                                        (.  var prefixes = new Stack<UnaryOperator>(); .)
=
    {   plus
    |   minus                           (.  prefixes.Push(UnaryOperator.UnaryNegation); .)
    |   inc                             (.  prefixes.Push(UnaryOperator.PreIncrement); .)
    |   dec                             (.  prefixes.Push(UnaryOperator.PreDecrement); .)
    }    
    Primary<out expr>                   
                                        (.  while(prefixes.Count > 0)
                                                expr = AstUnaryOperator._Create(this, prefixes.Pop(), expr);
                                        .)
.

Primary<out AstExpr expr>
                                        (.  expr = null;
                                            AstGetSet complex = null; bool declared; .)
=
	(.  _pushLexerState(Lexer.Asm); .)	(.	AstBlock blockExpr = target.BeginBlock("asm"); .)
    asm lpar { AsmInstruction<blockExpr> } rpar
    (.  _popLexerState(); .)			(.	expr = blockExpr; 
											target.EndBlock(); 
										.)
|   Constant<out expr>
|   CoroutineCreation<out expr>
|   ListLiteral<out expr>
|	HashLiteral<out expr>
|	LoopExpr<out expr>
|	(. AstThrow th; .)
	ThrowExpression<out th>				(. expr = th; .)
|   IF(isLambdaExpression())
    LambdaExpression<out expr>
|   LazyExpression<out expr>
|   lpar Expr<out expr> rpar
|   IF(_isNotNewDecl()) ObjectCreation<out expr>
|   GetInitiator<out complex, out declared>
                                        (.  expr = complex; .)
|   LPopExpr lpar Expr<out expr>        (.  //This is a hack that makes string interpolation with expressions possible
                                            //The non-verbal token "LPopExpr" (has no character representation) is 
                                            //returned by the lexer if the parser has to treat an expression in a special
                                            //way. This includes notifying the lexer when the expression has been parsed, as
                                            //well as injecting the necessary plus operator.
                                            _popLexerState(); _inject(_plus); .)
    rpar
.

Constant<out AstExpr expr>
                                        (.  expr = null; int vi; double vr; bool vb; string vs; .)
=
        Integer<out vi>                 (.  expr = new AstConstant(this, vi); .)
    |   Real<out vr>                    (.  expr = new AstConstant(this, vr); .)
    |   Boolean<out vb>                 (.  expr = new AstConstant(this, vb); .)
    |   String<out vs>                  (.  expr = new AstConstant(this, vs); .)
    |   Null							(.  expr = new AstConstant(this, null); .)
.

ListLiteral<out AstExpr expr>
                                        (.  AstExpr iexpr = null; 
                                            AstListLiteral lst = new AstListLiteral(this);
                                            expr = lst;
                                            bool missingExpr = false;
                                        .)
=
    lbrack
    [   Expr<out iexpr>                 (.  lst.Elements.Add(iexpr); .)
        {   comma                       (.  if(missingExpr)
                                                SemErr("Missing expression in list literal (two consecutive commas).");
                                        .)
            (   Expr<out iexpr>         (.  lst.Elements.Add(iexpr); 
                                            missingExpr = false; 
                                        .)
            |                           (.  missingExpr = true; .)
            )
        }
    ]
    rbrack
.

HashLiteral<out AstExpr expr>
										(.	AstExpr iexpr = null; 
											AstHashLiteral hash = new AstHashLiteral(this);
											expr = hash;
                                            bool missingExpr = false;
										.)
=
	lbrace
	[	Expr<out iexpr>					(.	hash.Elements.Add(iexpr); .)
		{	comma                       (.  if(missingExpr)
                                                SemErr("Missing expression in list literal (two consecutive commas).");
                                        .)
            (   Expr<out iexpr>			(.	hash.Elements.Add(iexpr); 
                                            missingExpr = false;
                                        .)
            |                           (.  missingExpr = true; .)
            )
		}
	]
	rbrace
.

LoopExpr<out AstExpr expr>
										(.	AstBlock dummyBlock = target.BeginBlock("loopExpr");
										.)
=
	(	WhileLoop<dummyBlock>
	|	ForLoop<dummyBlock>
	|	ForeachLoop<dummyBlock>
	)									(.	expr = new AstLoopExpression(this, (AstLoop) dummyBlock.Statements[0]);
											target.EndBlock();
										.)
.										
											

ObjectCreation<out AstExpr expr>
                                        (.  AstTypeExpr type; expr = null;
                                            ArgumentsProxy args; .)
=
    new TypeExpr<out type>              (.  _fallbackObjectCreation(this, type, out expr, out args); .)
    Arguments<args>
.

CoroutineCreation<out AstExpr expr>
                                        (.  
                                            AstCreateCoroutine cor = new AstCreateCoroutine(this); 
                                            AstExpr iexpr;
                                            expr = cor;
                                        .)
=
    coroutine Expr<out iexpr>           (.  cor.Expression = iexpr; .)
    [ for Arguments<cor.Arguments> ]
.

LambdaExpression<out AstExpr expr>
                                        (.  expr = null;
                                            PFunction func = TargetApplication.CreateFunction(generateLocalId());                                             
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            Loader.CreateFunctionTarget(func, target, GetPosition());
                                            CompilerTarget ft = FunctionTargets[func];
                                        .)
=
(   FormalArg<ft>
|   lpar
    [	FormalArg<ft> 
	    {	comma
		    FormalArg<ft>
	    }
    ]
    rpar
)
                                        (.
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
implementation                                        
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)
                                        (.
                                            target = oldTarget;
                                            if(errors.count == 0)
                                            {
                                                try {
                                                    //Emit code for top-level block
                                                    Ast[func].EmitCode(FunctionTargets[func],true,StackSemantics.Effect);
                                                    FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lambda expression.\n" + e.ToString());
                                                }
                                            }
                                            
                                            expr = new AstCreateClosure(this, 
                                                new SymbolEntry(SymbolInterpretations.Function, func.Id, 
                                                func.ParentApplication.Module.Name));                                         
                                        .)
.

LazyExpression<out AstExpr expr>
                                        (.  expr = null;
                                            PFunction func = TargetApplication.CreateFunction(generateLocalId());
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            Loader.CreateFunctionTarget(func, new AstBlock(this), target, GetPosition());
                                            CompilerTarget ft = FunctionTargets[func];
                                            
                                            //Switch to nested target
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
=
lazy
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)                                       
                                        (.
                                            //Turn into capture by value
                                            var cap = ft.ToCaptureByValue(let_bindings(ft));
                                            
                                            //Restore parent target
                                            target = oldTarget;
                                            
                                            //Finish nested function
                                            if(errors.count == 0)
                                            {
                                                try {
                                                Ast[func].EmitCode(FunctionTargets[func],true,StackSemantics.Effect);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy expression.\n" + e.ToString());
                                                }
                                            }
                                            
                                            //Construct expr (appears in the place of lazy expression)
                                            var clo = new AstCreateClosure(this,  
                                                new SymbolEntry(SymbolInterpretations.Function, func.Id, 
                                                func.ParentApplication.Module.Name));
                                            var thunk = new AstGetSetSymbol(this, 
                                                SymbolEntry.Command(Engine.ThunkAlias));
                                            thunk.Arguments.Add(clo);
                                            thunk.Arguments.AddRange(cap(this)); //Add captured values
                                            expr = thunk;
                                        .)
.

ThrowExpression<out AstThrow th>		(.  th = new AstThrow(this); .)
=
    throw
    Expr<out th.Expression>
.

ExplicitTypeExpr<out AstTypeExpr type>     (.  type = null; .)
=
    tilde PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

TypeExpr<out AstTypeExpr type>             (.  type = null; .)
=
    PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

ClrTypeExpr<out AstTypeExpr type>          
                                        (.  string id; .)
=
                                        (.  StringBuilder typeId = new StringBuilder(); .)
    (   doublecolon
    |   ns                              (.  typeId.Append(t.val); typeId.Append('.'); .)
    )
    {   ns                              (.  typeId.Append(t.val); typeId.Append('.'); .)
    }
    Id<out id>                          (.  typeId.Append(id);
                                            type = new AstConstantTypeExpression(this, 
                                                "Object(\"" + StringPType.Escape(typeId.ToString()) + "\")");
                                        .)
.

PrexoniteTypeExpr<out AstTypeExpr type>
                                        (.  string id = null; type = null; .)
=
    ( Id<out id> | null                 (.  id = NullPType.Literal; .)                          
    )
                                        (.  AstDynamicTypeExpression dType = new AstDynamicTypeExpression(this, id); .)
    [   lt
        [   TypeExprElement<dType.Arguments>   
            { comma TypeExprElement<dType.Arguments> }
        ]
        gt
    ]
                                        (.  type = dType; .)
.

TypeExprElement<. List<AstExpr> args .>
                                        (.  AstExpr expr; AstTypeExpr type; .)
=
    Constant<out expr>                  (.  args.Add(expr); .)
|   ExplicitTypeExpr<out type>          (.  args.Add(type); .)
|   lpar Expr<out expr> rpar            (.  args.Add(expr); .)
.
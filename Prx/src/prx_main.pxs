// Prexonite
// 
// Copyright (c) 2011, Christian Klauser
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:
// 
//     Redistributions of source code must retain the above copyright notice, 
//          this list of conditions and the following disclaimer.
//     Redistributions in binary form must reproduce the above copyright notice, 
//          this list of conditions and the following disclaimer in the 
//          documentation and/or other materials provided with the distribution.
//     The names of the contributors may be used to endorse or 
//          promote products derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
//  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


build does require("prx_interactive.pxs", "prx_lib.pxs");

Name prx\main;
Description "prx main logic.";
Author SealedSun;
Version "1.2.3.0";

Entry prx\main;

declare function 
	displayHelp,
	prx\interactive;
    
Add Prexonite::Compiler to Import;
    
var targetPath;
var sourceFiles;

declare var app, ldr;
	
function printHead does println("** PREXONITE v" + asm(ldr.app).Meta["Version"].Text + " ** (Runtime version $(Prexonite::Engine.PrexoniteVersion))");

var originalArgs;

function prx\main(arguments)
{
    originalArgs = arguments;
    
	if(arguments == null or arguments.Length == 0)
	{
    	printHead;
		println("NO ARGUMENTS DETECTED.");
		displayHelp;	
		return;
	}
	
	//Define the states of the arguments parser
	var state\compile = 3;      //Just compiling the application
	var state\target = 4;       //Next argument defines the target
	var state\run = 5;          //Running the application after compilation
	var state\interactive = 6;  //Launching the interactive console after compilation
	var state\arg = 7;          //Gathering arguments for the application
	
	//Define default settings
	var state = state\run;      //Run the compiled application b default
	var sourceFiles = [];
	var verbose = false;
	var headerOnly = false;
	var debugging = false;
    var suppressWarnings = false;
    //supportsTabs is a global variable
	
	var scriptArgs = [];
	
	//Interpret arguments one by one
	foreach(var current in arguments)
	{
		if(current == null or current.Length == 0)
			continue;
		else if(state == state\arg) //ignore options after -a
			scriptArgs[] = current;
		else if(current.StartsWith("-"))
			if(current == "-c")         //  -c Compile
				state = state\compile;
			else if(current == "-t")    //  -t Target
				state = state\target;
			else if(current == "-i")    //  -i Interactive
				state = state\interactive;
			else if(current == "-r")    //  -r  Run
				state = state\run;
			else if(current == "-v")    //  -v  Verbose
			    verbose = true;
			else if(current == "-h")    //  -h  Header only
			    headerOnly = true;
			else if(current == "-a")    //  -a  Arguments
				state = state\arg;
		    else if(current == "-b")    //  -b  disable tab completion (for piped input)
		        supportsTabs = false;
		    else if(current == "-d")    //  -d  Debugging
		        debugging = true;
            else if(current == "-nowarn")
                suppressWarnings = true;
			else if(current == "-?")    //  -h  Help
			{
				displayHelp;
				return;
			}
			else
				red = () => println("Unknown option " + current + "."); //see *1*
		else if(state == state\compile Or state == state\run Or state == state\interactive)
			sourceFiles.Add = current;
		else if(state == state\target)
			targetPath = current;
	}
	
	//*1*: 'red' is a function that takes in another function/lambda expression
	// and executes it in a context where console output is printed in red.
	// See it's definition in 'prx_lib.pxs' for more details.
	
    if(state == state\arg)
        state = state\run;
    
	//'run' and 'compile' require source files. 'interactive' doesn't.
	if(sourceFiles.Count == 0)
	{
		printHead;
    	unless(state == state\interactive)
    	    red(() => println("No source files specified."));
	}
	
	//Assemble a default target path if necessary
	if(targetPath is null or targetPath.Length == 0)
		targetPath = 
            (unless(state == state\interactive || sourceFiles.Count == 0)
                System::IO::Path.GetFileNameWithoutExtension(sourceFiles[0]) 
             else
                @"prx_interactive_app"
            )+ ".c.pxs";
		
	//Report
	if(verbose)
	{
    	printHead;
        unless(state == state\interactive)
            println("Target:\n    " + targetPath + "\nSources:");
    }
    
    if(debugging)
        sourceFiles.Insert(0,@"psr\debug\debug.pxs");
    
    //Create a new application. The id extracted from the first source file's name is just decoration
	app = new ::Application(
        unless(state == state\interactive || sourceFiles.Count == 0)
            System::IO::Path.GetFileNameWithoutExtension(sourceFiles[0])
        else
            @"prx\interactive\app");
            
	//Create the loader (the compiler) for this application
	var options = new ::LoaderOptions(engine, app);
    options.StoreSourceInformation = debugging;
    
	ldr = new ::Loader(options);
	var exc = null; //<--- holds exceptions

	try
	{
		foreach(var sourceFile in sourceFiles)
		{
	    	if(verbose) 
	    	    println("  * " + sourceFile);
	    	    
	    	//The next call compiles 'sourceFile' into 'app'
			ldr.RequireFromFile(sourceFile); //require only loads files that haven't been loaded before.
		}
		if(verbose) 
		    println("Loading of sources done.");
	}
	catch(var exc)
	{
        green(() => println(exc));
	}
    
    //Display information
    if(debugging and ldr.Infos.Count > 0)
    {
        println("Information:");
        foreach(var info in ldr.Infos)
            println(info);
    }
    
    //Display warnings
    if(not suppressWarnings and ldr.Warnings.Count > 0)
    {
        yellow(() =>
            {
                println("Warnings: (disable with -nowarn)");
                foreach(var warning in ldr.Warnings)
                    println(warning);
            }
        );
    }
    
	//Compilation errors are not thrown as exceptions but held in 'ldr.Errors'
	if(ldr.Errors.Count != 0 Or exc is not null) 
	{
	    red(() =>
        	{    	
        		println("Compilation completed, but errors detected. ");
        		foreach(var err in ldr.Errors)
        			println(err);
        	});
        exc = null; 
    	if(debugging and state == state\interactive) //in debugging mode, allow the script to be examined
        {
            println("Entering interactive mode for debugging.");
    	    prx\interactive;
        }
        else
        {
            println("Aborting (Enable debugging for inspection of partial results in interactive mode)");
        }
        return;
	}
    
    //Decide what to do with the just compiled application
	if(state == state\interactive)
	{
    	//'prx\interactive' is defined in 'prx_interactive.pxs'
runInteractive:
        prx\interactive;
    }
	else if(state == state\run) // state\arg is synonymous
	{
    	//The application might not run in non-interactive mode
    	if(app.Meta["interactive"].Switch)
    	{
            //The application requires to be run in interactive mode.
            //Extract the id of the interactive entry function from the 
            // applications metadata...
            var intMainId = 
                if(app.Meta.ContainsKey("entry\\interactive"))
                    app.Meta["entry\\interactive"].Text 
                else
                    "main\\interactive"; //... or use a default name.
                    
            //If that function exists, execute it first
            if(app.Functions.Contains(intMainId))
                var intMain = app.Functions[intMainId].Run(engine, scriptArgs~Object<"Prexonite.PValue[]">);
            
            //before going into interactive mode.
            goto runInteractive;
    	}
    	else
    	{
            var mainId =
                if(app.Meta.ContainsKey(Prexonite::Application.EntryKey))
                    app.Meta[Prexonite::Application.EntryKey].Text
                else
                    Prexonite::Application.DefaultEntryFunction;
                    
            if(not app.Functions.Contains(mainId))
            {
                red(() => println("Cannot find entry function named `$mainId`."));
                return;
            }
            
        	//Run the application (run it's entry function).
        	// the script arguments have to be converted to a Prexonite.PValue[] first.
	        app.Run(engine, scriptArgs~Object<"Prexonite.PValue[]">);
        }
    }
	else
	{   //state = state\compile
    	//Store the compiled application in a file.
    	using(var writer = new System::IO::StreamWriter(targetPath, false))
    	{
        	if(headerOnly)
        	    ldr.StoreSymbols(writer);
        	else
    	        ldr.Store(writer);
        }
    }
}

function reboot does prx\main(originalArgs);

function displayHelp does print(
	"Usage:\n" + 
	"\tprx -c {sources...} (-t {target...} [-h] | -r | -i) [-v | -d | -a <arguments...> | -b]\n" +
	"\tprx -i\n" +
	"\tprx -?\n" +
	"\n" + 
	"List the required source files (*.pxs) after the -c switch.\n" + 
	"Define the name of the output file using -t.\n"+
	"\n"+
	"The default action is storing the compiled application in the target file.\n"+
	"Run the application instead by using the -r switch.\n"+
	"Enter interactive mode (with or without a compiled application) using the -i switch.\n"+
	"-v enables additional output.\n"+
	"-h extracts declarations (only with -c).\n"+
	"-b disables tab completion (tab completion only supported on windows).\n"+
	"-a forwards the rest of the arguments to the executing script.\n" + 
	"-d enables debugging mode\n" + 
    "-nowarn disables all warnings");
 
{  CompileToCil;  } 

#line 1 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME
/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
----------------------------------------------------------------------*/

#line default //END FRAME -->begin

//SOURCE ARRAY

#line 33 "Coco.atg" //SOURCE beg=1549,len=16,col=0
using System.IO;
#line default //END SOURCE
//END SOURCE ARRAY


#line 27 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

using System;


#line default //END FRAME -->namespace

namespace at.jku.ssw.Coco {


#line 30 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME


public partial class Parser {

#line default //END FRAME -->constants

	const int _EOF = 0;
	const int _ident = 1;
	const int _number = 2;
	const int _string = 3;
	const int _badString = 4;
	const int _char = 5;
	const int _filechg = 6;
	public enum Terminals
	{
		@EOF = 0,
		@ident = 1,
		@number = 2,
		@string = 3,
		@badString = 4,
		@char = 5,
		@filechg = 6,
	}
	const int maxT = 44;
	const int _ddtSym = 45;

#line 33 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

	const bool T = true;
	const bool x = false;
	const int minErrDist = 2;
	
	public Scanner scanner;
	public Errors  errors;

	public Token t;    // last recognized token
	public Token la;   // lookahead token
	int errDist = minErrDist;


#line default //END FRAME -->declarations

//SOURCE ARRAY

#line 56 "Coco.atg" //SOURCE beg=1607,len=429,col=0
const int id = 0;
	const int str = 1;
	
	public TextWriter trace;    // other Coco objects referenced in this ATG
	public Tab tab;
	public DFA dfa;
	public ParserGen pgen;

	bool   genScanner;
	string tokenString;         // used in declarations of literal tokens
	string noString = "-none-"; // used in declarations of literal tokens

/*-------------------------------------------------------------------------*/


#line default //END SOURCE
//END SOURCE ARRAY

#line 45 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME


	public Parser(Scanner scanner) {
		this.scanner = scanner;
		errors = new Errors();
	}

	void SynErr (int n) {
		if (errDist >= minErrDist) errors.SynErr(la.line, la.col, n);
		errDist = 0;
	}

	public void SemErr (string msg) {
		if (errDist >= minErrDist) errors.SemErr(t.line, t.col, msg);
		errDist = 0;
	}
	
	void Get () {
		for (;;) {
			t = la;
			la = scanner.Scan();
			if (la.kind <= maxT) { ++errDist; break; }

#line default //END FRAME -->pragmas

				if (la.kind == 45) {

#line 79 "Coco.atg" //SOURCE beg=2789,len=20,col=45
																																													tab.SetDDT(la.val); 
#line default //END SOURCE
				}

#line 67 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

			la = t;
		}
	}
	
	void Expect (int n) {
		if (la.kind==n) Get(); else { SynErr(n); }
	}
	
	bool StartOf (int s) {
		return set[s, la.kind];
	}
	
	void ExpectWeak (int n, int follow) {
		if (la.kind == n) Get();
		else {
			SynErr(n);
			while (!StartOf(follow)) Get();
		}
	}
	
	bool WeakSeparator (int n, int syFol, int repFol) {
		bool[] s = new bool[maxT+1];
		if (la.kind == n) { Get(); return true; }
		else if (StartOf(repFol)) return false;
		else {
			for (int i=0; i <= maxT; i++) {
				s[i] = set[syFol, i] || set[repFol, i] || set[0, i];
			}
			SynErr(n);
			while (!s[la.kind]) Get();
			return StartOf(syFol);
		}
	}
	

#line default //END FRAME -->productions

	void FilePragma() {

#line 92 "Coco.atg" //SOURCE beg=3066,len=88,col=36
																																				errors.WriteMessage("Found filechange(" + la.val + "), len="+la.val.Length.ToString()); 
#line default //END SOURCE
		Expect(_filechg);

#line 93 "Coco.atg" //SOURCE beg=3193,len=93,col=36
																																				ChangeVirtualFile(t.val == "#file:default#" ? null : t.val.Substring(6, t.val.Length -6-1)); 
#line default //END SOURCE
	}

	void Coco() {

#line 96 "Coco.atg" //SOURCE beg=3330,len=57,col=36
																																				Symbol sym; Graph g, g1, g2; string gramName; CharSet s; 
#line default //END SOURCE
		if (
#line 98 "Coco.atg" //SOURCE beg=3401,len=10,col=8
								isPragma()
#line default //END SOURCE
) {
			FilePragma();
		}
		if (la.kind == 42) {
			UsingDecl(
#line 100 "Coco.atg" //SOURCE beg=3444,len=19,col=15
															pgen.usingPositions
#line default //END SOURCE
);
		}
		if (la.kind == _filechg) {
			FilePragma();
		}
		Expect(7);

#line 104 "Coco.atg" //SOURCE beg=3523,len=85,col=36
																																				genScanner = true; 
                                   tab.ignored = new CharSet(); 
#line default //END SOURCE
		Expect(_ident);

#line 106 "Coco.atg" //SOURCE beg=3648,len=158,col=36
																																				gramName = t.val;
                                   int beg = la.pos;
                                   int vline = 1; 
                                 
#line default //END SOURCE
		if (
#line 110 "Coco.atg" //SOURCE beg=3816,len=10,col=7
							isPragma()
#line default //END SOURCE
) {
			FilePragma();
		}
		if (StartOf(1)) {

#line 111 "Coco.atg" //SOURCE beg=3876,len=26,col=36
																																				vline = GetVirtualLine(); 
#line default //END SOURCE
			Get();
			while (StartOf(1)) {
				Get();
			}

#line 113 "Coco.atg" //SOURCE beg=3975,len=146,col=36
																																				tab.semDeclPositions.Add(new Position(beg, la.pos-beg, 0, GetVirtualFile(), GetVirtualLine()));
                                   beg = la.pos; 
#line default //END SOURCE
		}
		while (la.kind == _filechg) {
			FilePragma();

#line 116 "Coco.atg" //SOURCE beg=4165,len=26,col=36
																																				vline = GetVirtualLine(); 
#line default //END SOURCE
			Get();
			while (StartOf(1)) {
				Get();
			}

#line 118 "Coco.atg" //SOURCE beg=4264,len=135,col=36
																																				tab.semDeclPositions.Add(new Position(beg, la.pos-beg, 0, GetVirtualFile(), vline));
                                   beg = la.pos; 
#line default //END SOURCE
		}
		if (la.kind == 8) {
			Get();

#line 121 "Coco.atg" //SOURCE beg=4443,len=23,col=36
																																				dfa.ignoreCase = true; 
#line default //END SOURCE
			if (la.kind == _filechg) {
				FilePragma();
			}
		}
		if (la.kind == 9) {
			Get();
			while (la.kind == _ident) {
				SetDecl();
			}
		}
		if (la.kind == 10) {
			Get();
			while (la.kind == _ident || la.kind == _string || la.kind == _char) {
				TokenDecl(
#line 125 "Coco.atg" //SOURCE beg=4562,len=6,col=27
																											Node.t
#line default //END SOURCE
);
			}
		}
		if (la.kind == 11) {
			Get();
			while (la.kind == _ident || la.kind == _string || la.kind == _char) {
				TokenDecl(
#line 126 "Coco.atg" //SOURCE beg=4600,len=7,col=27
																											Node.pr
#line default //END SOURCE
);
			}
		}
		while (la.kind == 12) {
			Get();

#line 127 "Coco.atg" //SOURCE beg=4648,len=21,col=36
																																				bool nested = false; 
#line default //END SOURCE
			Expect(13);
			TokenExpr(
#line 128 "Coco.atg" //SOURCE beg=4694,len=6,col=22
																						out g1
#line default //END SOURCE
);
			Expect(14);
			TokenExpr(
#line 129 "Coco.atg" //SOURCE beg=4723,len=6,col=20
																				out g2
#line default //END SOURCE
);
			if (la.kind == 15) {
				Get();

#line 130 "Coco.atg" //SOURCE beg=4767,len=15,col=36
																																				nested = true; 
#line default //END SOURCE
			}

#line 131 "Coco.atg" //SOURCE beg=4821,len=36,col=36
																																				dfa.NewComment(g1.l, g2.l, nested); 
#line default //END SOURCE
			if (la.kind == _filechg) {
				FilePragma();
			}
		}
		while (la.kind == 16) {
			Get();
			Set(
#line 134 "Coco.atg" //SOURCE beg=4901,len=5,col=18
																		out s
#line default //END SOURCE
);

#line 134 "Coco.atg" //SOURCE beg=4919,len=19,col=36
																																				tab.ignored.Or(s); 
#line default //END SOURCE
			if (la.kind == _filechg) {
				FilePragma();
			}
		}
		while (!(la.kind == _EOF || la.kind == 17)) {SynErr(45); Get();}
		Expect(17);

#line 139 "Coco.atg" //SOURCE beg=5011,len=130,col=36
																																				if (genScanner) dfa.MakeDeterministic();
                                   tab.DeleteNodes();
                                 
#line default //END SOURCE
		if (la.kind == _filechg) {
			FilePragma();
		}
		while (la.kind == _ident) {
			Get();

#line 143 "Coco.atg" //SOURCE beg=5196,len=747,col=36
																																				sym = tab.FindSym(t.val);
                                   bool undef = sym == null;
                                   if (undef) sym = tab.NewSym(Node.nt, t.val, t.line);
                                   else {
                                     if (sym.typ == Node.nt) {
                                       if (sym.graph != null) SemErr("name declared twice");
                                   	 } else SemErr("this symbol kind not allowed on left side of production");
                                   	 sym.line = t.line;
                                   }
                                   bool noAttrs = sym.attrPos == null;
                                   sym.attrPos = null;
                                 
#line default //END SOURCE
			if (la.kind == 25 || la.kind == 27) {
				AttrDecl(
#line 155 "Coco.atg" //SOURCE beg=5962,len=3,col=16
																sym
#line default //END SOURCE
);
			}

#line 155 "Coco.atg" //SOURCE beg=5982,len=235,col=36
																																				if (!undef)
                                     if (noAttrs != (sym.attrPos == null))
                                       SemErr("attribute mismatch between declaration and use of this symbol");
                                 
#line default //END SOURCE
			if (la.kind == 40) {
				SemText(
#line 159 "Coco.atg" //SOURCE beg=6235,len=14,col=15
															out sym.semPos
#line default //END SOURCE
);
			}
			ExpectWeak(18, 2);
			Expression(
#line 161 "Coco.atg" //SOURCE beg=6283,len=5,col=16
																out g
#line default //END SOURCE
);

#line 161 "Coco.atg" //SOURCE beg=6303,len=102,col=36
																																				sym.graph = g.l;
                                   tab.Finish(g);
                                 
#line default //END SOURCE
			ExpectWeak(19, 3);
			if (la.kind == _filechg) {
				FilePragma();
			}
		}
		Expect(20);
		Expect(_ident);

#line 167 "Coco.atg" //SOURCE beg=6509,len=1980,col=36
																																				if (gramName != t.val)
                                     SemErr("name does not match grammar name");
                                   tab.gramSy = tab.FindSym(gramName);
                                   if (tab.gramSy == null)
                                     SemErr("missing production for grammar name");
                                   else {
                                     sym = tab.gramSy;
                                     if (sym.attrPos != null)
                                       SemErr("grammar symbol must not have attributes");
                                   }
                                   tab.noSym = tab.NewSym(Node.t, "???", 0); // noSym gets highest number
                                   tab.SetupAnys();
                                   tab.RenumberPragmas();
                                   if (tab.ddt[2]) tab.PrintNodes();
                                   if (errors.count == 0) {
                                     errors.WriteMessage("checking");
                                     tab.CompSymbolSets();
                                     if (tab.ddt[7]) tab.XRef();
                                     if (tab.GrammarOk()) {
                                       string msg = "parser";
                                       pgen.WriteParser();
                                       if (genScanner) {
                                         msg += " + scanner";
                                         dfa.WriteScanner();
                                         if (tab.ddt[0]) dfa.PrintStates();
                                       }
                                       errors.WriteMessage(msg);
                                       if (tab.ddt[8]) pgen.WriteStatistics();
                                     }
                                   }
                                   if (tab.ddt[6]) tab.PrintSymbolTable();
                                 
#line default //END SOURCE
		Expect(19);
		if (la.kind == _filechg) {
			FilePragma();
		}
	}

	void UsingDecl(
#line 506 "Coco.atg" //SOURCE beg=22972,len=52,col=13
													System.Collections.Generic.List<Position> positions 
#line default //END SOURCE
) {

#line 506 "Coco.atg" //SOURCE beg=23063,len=21,col=36
																																				int vline = la.line; 
#line default //END SOURCE
		Expect(42);

#line 507 "Coco.atg" //SOURCE beg=23123,len=17,col=36
																																				int beg = t.pos; 
#line default //END SOURCE
		while (StartOf(4)) {
			Get();
		}
		Expect(43);

#line 508 "Coco.atg" //SOURCE beg=23179,len=17,col=36
																																				int end = t.pos; 
#line default //END SOURCE
		while (la.kind == 42) {
			Get();
			while (StartOf(4)) {
				Get();
			}
			Expect(43);

#line 509 "Coco.atg" //SOURCE beg=23235,len=13,col=36
																																				end = t.pos; 
#line default //END SOURCE
		}

#line 510 "Coco.atg" //SOURCE beg=23287,len=77,col=36
																																				positions.Add(new Position(beg, end - beg + 1, 0, GetVirtualFile(), vline)); 
#line default //END SOURCE
	}

	void SetDecl() {

#line 204 "Coco.atg" //SOURCE beg=8645,len=11,col=36
																																				CharSet s; 
#line default //END SOURCE
		Expect(_ident);

#line 206 "Coco.atg" //SOURCE beg=8698,len=212,col=36
																																				string name = t.val;
                                   CharClass c = tab.FindCharClass(name);
                                   if (c != null) SemErr("name declared twice");
                                 
#line default //END SOURCE
		Expect(18);
		Set(
#line 210 "Coco.atg" //SOURCE beg=8924,len=5,col=11
											out s
#line default //END SOURCE
);

#line 210 "Coco.atg" //SOURCE beg=8949,len=163,col=36
																																				if (s.Elements() == 0) SemErr("character set must not be empty");
                                   tab.NewCharClass(name, s);
                                 
#line default //END SOURCE
		Expect(19);
		if (la.kind == _filechg) {
			FilePragma();
		}
	}

	void TokenDecl(
#line 259 "Coco.atg" //SOURCE beg=11054,len=7,col=11
											int typ
#line default //END SOURCE
) {

#line 259 "Coco.atg" //SOURCE beg=11079,len=44,col=36
																																				string name; int kind; Symbol sym; Graph g; 
#line default //END SOURCE
		Sym(
#line 261 "Coco.atg" //SOURCE beg=11136,len=18,col=7
							out name, out kind
#line default //END SOURCE
);

#line 261 "Coco.atg" //SOURCE beg=11165,len=428,col=36
																																				sym = tab.FindSym(name);
                                   if (sym != null) SemErr("name declared twice");
                                   else {
                                     sym = tab.NewSym(typ, name, t.line);
                                     sym.tokenKind = Symbol.fixedToken;
                                   }
                                   tokenString = null;
                                 
#line default //END SOURCE
		while (!(StartOf(5))) {SynErr(46); Get();}
		if (la.kind == 18) {
			Get();
			TokenExpr(
#line 270 "Coco.atg" //SOURCE beg=11623,len=5,col=19
																			out g
#line default //END SOURCE
);
			Expect(19);

#line 270 "Coco.atg" //SOURCE beg=11640,len=737,col=36
																																				if (kind == str) SemErr("a literal must not be declared with a structure");
                                   tab.Finish(g);
                                   if (tokenString == null || tokenString.Equals(noString))
                                     dfa.ConvertToStates(g.l, sym);
                                   else { // TokenExpr is a single string
                                     if (tab.literals[tokenString] != null)
                                       SemErr("token string declared twice");
                                     tab.literals[tokenString] = sym;
                                     dfa.MatchLiteral(tokenString, sym);
                                   }
                                 
#line default //END SOURCE
		} else if (StartOf(6)) {

#line 281 "Coco.atg" //SOURCE beg=12416,len=144,col=36
																																				if (kind == id) genScanner = false;
                                   else dfa.MatchLiteral(sym.name, sym);
                                 
#line default //END SOURCE
		} else SynErr(47);
		if (la.kind == 40) {
			SemText(
#line 285 "Coco.atg" //SOURCE beg=12581,len=14,col=13
													out sym.semPos
#line default //END SOURCE
);

#line 285 "Coco.atg" //SOURCE beg=12604,len=64,col=36
																																				if (typ != Node.pr) SemErr("semantic action not allowed here"); 
#line default //END SOURCE
		}
		if (la.kind == _filechg) {
			FilePragma();
		}
	}

	void TokenExpr(
#line 409 "Coco.atg" //SOURCE beg=18670,len=11,col=11
											out Graph g
#line default //END SOURCE
) {

#line 409 "Coco.atg" //SOURCE beg=18695,len=10,col=36
																																				Graph g2; 
#line default //END SOURCE
		TokenTerm(
#line 411 "Coco.atg" //SOURCE beg=18724,len=5,col=13
													out g
#line default //END SOURCE
);

#line 411 "Coco.atg" //SOURCE beg=18747,len=19,col=36
																																				bool first = true; 
#line default //END SOURCE
		while (WeakSeparator(29,7,8) ) {
			TokenTerm(
#line 414 "Coco.atg" //SOURCE beg=18831,len=6,col=15
															out g2
#line default //END SOURCE
);

#line 414 "Coco.atg" //SOURCE beg=18852,len=149,col=36
																																				if (first) { tab.MakeFirstAlt(g); first = false; }
                                   tab.MakeAlternative(g, g2);
                                 
#line default //END SOURCE
		}
	}

	void Set(
#line 218 "Coco.atg" //SOURCE beg=9237,len=13,col=5
					out CharSet s
#line default //END SOURCE
) {

#line 218 "Coco.atg" //SOURCE beg=9268,len=12,col=36
																																				CharSet s2; 
#line default //END SOURCE
		SimSet(
#line 220 "Coco.atg" //SOURCE beg=9296,len=5,col=10
										out s
#line default //END SOURCE
);
		while (la.kind == 21 || la.kind == 22) {
			if (la.kind == 21) {
				Get();
				SimSet(
#line 221 "Coco.atg" //SOURCE beg=9319,len=6,col=16
																out s2
#line default //END SOURCE
);

#line 221 "Coco.atg" //SOURCE beg=9339,len=10,col=36
																																				s.Or(s2); 
#line default //END SOURCE
			} else {
				Get();
				SimSet(
#line 222 "Coco.atg" //SOURCE beg=9368,len=6,col=16
																out s2
#line default //END SOURCE
);

#line 222 "Coco.atg" //SOURCE beg=9388,len=16,col=36
																																				s.Subtract(s2); 
#line default //END SOURCE
			}
		}
	}

	void AttrDecl(
#line 293 "Coco.atg" //SOURCE beg=12799,len=10,col=10
										Symbol sym
#line default //END SOURCE
) {
		if (la.kind == 25) {
			Get();

#line 294 "Coco.atg" //SOURCE beg=12850,len=36,col=36
																																				int beg = la.pos; int col = la.col; 
#line default //END SOURCE
			while (StartOf(9)) {
				if (StartOf(10)) {
					Get();
				} else {
					Get();

#line 296 "Coco.atg" //SOURCE beg=12934,len=36,col=36
																																				SemErr("bad string in attributes"); 
#line default //END SOURCE
				}
			}
			Expect(26);

#line 298 "Coco.atg" //SOURCE beg=13014,len=142,col=36
																																				if (t.pos > beg)
                                     sym.attrPos = new Position(beg, t.pos - beg, col, GetVirtualFile(), GetVirtualLine()); 
#line default //END SOURCE
		} else if (la.kind == 27) {
			Get();

#line 300 "Coco.atg" //SOURCE beg=13195,len=36,col=36
																																				int beg = la.pos; int col = la.col; 
#line default //END SOURCE
			while (StartOf(11)) {
				if (StartOf(12)) {
					Get();
				} else {
					Get();

#line 302 "Coco.atg" //SOURCE beg=13279,len=36,col=36
																																				SemErr("bad string in attributes"); 
#line default //END SOURCE
				}
			}
			Expect(28);

#line 304 "Coco.atg" //SOURCE beg=13359,len=142,col=36
																																				if (t.pos > beg)
                                     sym.attrPos = new Position(beg, t.pos - beg, col, GetVirtualFile(), GetVirtualLine()); 
#line default //END SOURCE
		} else SynErr(48);
	}

	void SemText(
#line 494 "Coco.atg" //SOURCE beg=22445,len=16,col=9
									out Position pos
#line default //END SOURCE
) {
		Expect(40);

#line 495 "Coco.atg" //SOURCE beg=22502,len=66,col=36
																																				int beg = la.pos; int col = la.col; int vline = GetVirtualLine(); 
#line default //END SOURCE
		while (StartOf(13)) {
			if (StartOf(14)) {
				Get();
			} else if (la.kind == _badString) {
				Get();

#line 497 "Coco.atg" //SOURCE beg=22616,len=41,col=36
																																				SemErr("bad string in semantic action"); 
#line default //END SOURCE
			} else {
				Get();

#line 498 "Coco.atg" //SOURCE beg=22696,len=51,col=36
																																				SemErr("missing end of previous semantic action"); 
#line default //END SOURCE
			}
		}
		Expect(41);

#line 500 "Coco.atg" //SOURCE beg=22791,len=68,col=36
																																				pos = new Position(beg, t.pos - beg, col, GetVirtualFile(), vline); 
#line default //END SOURCE
	}

	void Expression(
#line 310 "Coco.atg" //SOURCE beg=13613,len=11,col=12
												out Graph g
#line default //END SOURCE
) {

#line 310 "Coco.atg" //SOURCE beg=13637,len=10,col=36
																																				Graph g2; 
#line default //END SOURCE
		Term(
#line 312 "Coco.atg" //SOURCE beg=13662,len=5,col=8
								out g
#line default //END SOURCE
);

#line 312 "Coco.atg" //SOURCE beg=13690,len=19,col=36
																																				bool first = true; 
#line default //END SOURCE
		while (WeakSeparator(29,15,16) ) {
			Term(
#line 315 "Coco.atg" //SOURCE beg=13769,len=6,col=10
										out g2
#line default //END SOURCE
);

#line 315 "Coco.atg" //SOURCE beg=13795,len=149,col=36
																																				if (first) { tab.MakeFirstAlt(g); first = false; }
                                   tab.MakeAlternative(g, g2);
                                 
#line default //END SOURCE
		}
	}

	void SimSet(
#line 228 "Coco.atg" //SOURCE beg=9517,len=13,col=8
								out CharSet s
#line default //END SOURCE
) {

#line 228 "Coco.atg" //SOURCE beg=9545,len=12,col=36
																																				int n1, n2; 
#line default //END SOURCE

#line 229 "Coco.atg" //SOURCE beg=9596,len=19,col=36
																																				s = new CharSet(); 
#line default //END SOURCE
		if (la.kind == _ident) {
			Get();

#line 230 "Coco.atg" //SOURCE beg=9654,len=169,col=36
																																				CharClass c = tab.FindCharClass(t.val);
                                   if (c == null) SemErr("undefined name"); else s.Or(c.set);
                                 
#line default //END SOURCE
		} else if (la.kind == _string) {
			Get();

#line 233 "Coco.atg" //SOURCE beg=9862,len=311,col=36
																																				string name = t.val;
                                   name = tab.Unescape(name.Substring(1, name.Length-2));
                                   foreach (char ch in name)
                                     if (dfa.ignoreCase) s.Set(char.ToLower(ch));
                                     else s.Set(ch); 
#line default //END SOURCE
		} else if (la.kind == _char) {
			Char(
#line 238 "Coco.atg" //SOURCE beg=10184,len=6,col=8
								out n1
#line default //END SOURCE
);

#line 238 "Coco.atg" //SOURCE beg=10212,len=11,col=36
																																				s.Set(n1); 
#line default //END SOURCE
			if (la.kind == 23) {
				Get();
				Char(
#line 239 "Coco.atg" //SOURCE beg=10241,len=6,col=15
															out n2
#line default //END SOURCE
);

#line 239 "Coco.atg" //SOURCE beg=10262,len=41,col=36
																																				for (int i = n1; i <= n2; i++) s.Set(i); 
#line default //END SOURCE
			}
		} else if (la.kind == 24) {
			Get();

#line 241 "Coco.atg" //SOURCE beg=10347,len=29,col=36
																																				s = new CharSet(); s.Fill(); 
#line default //END SOURCE
		} else SynErr(49);
	}

	void Char(
#line 248 "Coco.atg" //SOURCE beg=10487,len=9,col=6
						out int n
#line default //END SOURCE
) {
		Expect(_char);

#line 249 "Coco.atg" //SOURCE beg=10537,len=406,col=36
																																				string name = t.val; n = 0;
                                   name = tab.Unescape(name.Substring(1, name.Length-2));
                                   if (name.Length == 1) n = name[0];
                                   else SemErr("unacceptable character value");
                                   if (dfa.ignoreCase && (char)n >= 'A' && (char)n <= 'Z') n += 32;
                                 
#line default //END SOURCE
	}

	void Sym(
#line 464 "Coco.atg" //SOURCE beg=20987,len=29,col=5
					out string name, out int kind
#line default //END SOURCE
) {

#line 464 "Coco.atg" //SOURCE beg=21054,len=25,col=36
																																				name = "???"; kind = id; 
#line default //END SOURCE
		if (la.kind == _ident) {
			Get();

#line 465 "Coco.atg" //SOURCE beg=21118,len=25,col=36
																																				kind = id; name = t.val; 
#line default //END SOURCE
		} else if (la.kind == _string || la.kind == _char) {
			if (la.kind == _string) {
				Get();

#line 466 "Coco.atg" //SOURCE beg=21182,len=14,col=36
																																				name = t.val; 
#line default //END SOURCE
			} else {
				Get();

#line 467 "Coco.atg" //SOURCE beg=21235,len=57,col=36
																																				name = "\"" + t.val.Substring(1, t.val.Length-2) + "\""; 
#line default //END SOURCE
			}

#line 468 "Coco.atg" //SOURCE beg=21331,len=243,col=36
																																				kind = str;
                                   if (dfa.ignoreCase) name = name.ToLower();
                                   if (name.IndexOf(' ') >= 0)
                                     SemErr("literal tokens must not contain blanks"); 
#line default //END SOURCE
		} else SynErr(50);
	}

	void Term(
#line 323 "Coco.atg" //SOURCE beg=14055,len=11,col=6
						out Graph g
#line default //END SOURCE
) {

#line 323 "Coco.atg" //SOURCE beg=14085,len=38,col=36
																																				Graph g2; Node rslv = null; g = null; 
#line default //END SOURCE
		if (StartOf(17)) {
			if (la.kind == 38) {

#line 325 "Coco.atg" //SOURCE beg=14165,len=46,col=36
																																				rslv = tab.NewNode(Node.rslv, null, la.line); 
#line default //END SOURCE
				Resolver(
#line 326 "Coco.atg" //SOURCE beg=14228,len=12,col=14
														out rslv.pos
#line default //END SOURCE
);

#line 326 "Coco.atg" //SOURCE beg=14250,len=21,col=36
																																				g = new Graph(rslv); 
#line default //END SOURCE
			}
			Factor(
#line 328 "Coco.atg" //SOURCE beg=14289,len=6,col=10
										out g2
#line default //END SOURCE
);

#line 328 "Coco.atg" //SOURCE beg=14315,len=126,col=36
																																				if (rslv != null) tab.MakeSequence(g, g2);
                                   else g = g2;
                                 
#line default //END SOURCE
			while (StartOf(18)) {
				Factor(
#line 331 "Coco.atg" //SOURCE beg=14456,len=6,col=12
												out g2
#line default //END SOURCE
);

#line 331 "Coco.atg" //SOURCE beg=14480,len=25,col=36
																																				tab.MakeSequence(g, g2); 
#line default //END SOURCE
			}
		} else if (StartOf(19)) {

#line 333 "Coco.atg" //SOURCE beg=14549,len=47,col=36
																																				g = new Graph(tab.NewNode(Node.eps, null, 0)); 
#line default //END SOURCE
		} else SynErr(51);

#line 334 "Coco.atg" //SOURCE beg=14635,len=159,col=36
																																				if (g == null) // invalid start of Term
                                     g = new Graph(tab.NewNode(Node.eps, null, 0));
                                 
#line default //END SOURCE
	}

	void Resolver(
#line 398 "Coco.atg" //SOURCE beg=18206,len=16,col=10
										out Position pos
#line default //END SOURCE
) {
		Expect(38);
		Expect(31);

#line 399 "Coco.atg" //SOURCE beg=18267,len=36,col=37
																																					int beg = la.pos; int col = la.col; 
#line default //END SOURCE
		Condition();

#line 400 "Coco.atg" //SOURCE beg=18343,len=79,col=37
																																					pos = new Position(beg, t.pos - beg, col, GetVirtualFile(), GetVirtualLine()); 
#line default //END SOURCE
	}

	void Factor(
#line 341 "Coco.atg" //SOURCE beg=14902,len=11,col=8
								out Graph g
#line default //END SOURCE
) {

#line 341 "Coco.atg" //SOURCE beg=14930,len=137,col=36
																																				string name; int kind; Position pos; bool weak = false; 
                                   g = null;
                                 
#line default //END SOURCE
		switch (la.kind) {
		case _ident: case _string: case _char: case 30: {
			if (la.kind == 30) {
				Get();

#line 345 "Coco.atg" //SOURCE beg=15109,len=13,col=36
																																				weak = true; 
#line default //END SOURCE
			}
			Sym(
#line 347 "Coco.atg" //SOURCE beg=15137,len=18,col=7
							out name, out kind
#line default //END SOURCE
);

#line 347 "Coco.atg" //SOURCE beg=15166,len=1542,col=36
																																				Symbol sym = tab.FindSym(name);
                                   if (sym == null && kind == str)
                                     sym = tab.literals[name] as Symbol;
                                   bool undef = sym == null;
                                   if (undef) {
                                     if (kind == id)
                                       sym = tab.NewSym(Node.nt, name, 0);  // forward nt
                                     else if (genScanner) { 
                                       sym = tab.NewSym(Node.t, name, t.line);
                                       dfa.MatchLiteral(sym.name, sym);
                                     } else {  // undefined string in production
                                       SemErr("undefined string in production");
                                       sym = tab.eofSy;  // dummy
                                     }
                                   }
                                   int typ = sym.typ;
                                   if (typ != Node.t && typ != Node.nt)
                                     SemErr("this symbol kind is not allowed in a production");
                                   if (weak)
                                     if (typ == Node.t) typ = Node.wt;
                                     else SemErr("only terminals may be weak");
                                   Node p = tab.NewNode(typ, sym, t.line);
                                   g = new Graph(p);
                                 
#line default //END SOURCE
			if (la.kind == 25 || la.kind == 27) {
				Attribs(
#line 371 "Coco.atg" //SOURCE beg=16724,len=1,col=13
													p
#line default //END SOURCE
);

#line 371 "Coco.atg" //SOURCE beg=16747,len=62,col=36
																																				if (kind != id) SemErr("a literal must not have attributes"); 
#line default //END SOURCE
			}

#line 372 "Coco.atg" //SOURCE beg=16848,len=312,col=36
																																				if (undef)
                                     sym.attrPos = p.pos;  // dummy
                                   else if ((p.pos == null) != (sym.attrPos == null))
                                     SemErr("attribute mismatch between declaration and use of this symbol");
                                 
#line default //END SOURCE
			break;
		}
		case 31: {
			Get();
			Expression(
#line 377 "Coco.atg" //SOURCE beg=17181,len=5,col=18
																		out g
#line default //END SOURCE
);
			Expect(32);
			break;
		}
		case 33: {
			Get();
			Expression(
#line 378 "Coco.atg" //SOURCE beg=17210,len=5,col=18
																		out g
#line default //END SOURCE
);
			Expect(34);

#line 378 "Coco.atg" //SOURCE beg=17228,len=19,col=36
																																				tab.MakeOption(g); 
#line default //END SOURCE
			break;
		}
		case 35: {
			Get();
			Expression(
#line 379 "Coco.atg" //SOURCE beg=17268,len=5,col=18
																		out g
#line default //END SOURCE
);
			Expect(36);

#line 379 "Coco.atg" //SOURCE beg=17286,len=22,col=36
																																				tab.MakeIteration(g); 
#line default //END SOURCE
			break;
		}
		case 40: {
			SemText(
#line 380 "Coco.atg" //SOURCE beg=17322,len=7,col=11
											out pos
#line default //END SOURCE
);

#line 380 "Coco.atg" //SOURCE beg=17347,len=178,col=36
																																				Node p = tab.NewNode(Node.sem, null, 0);
                                   p.pos = pos;
                                   g = new Graph(p);
                                 
#line default //END SOURCE
			break;
		}
		case 24: {
			Get();

#line 384 "Coco.atg" //SOURCE beg=17564,len=163,col=36
																																				Node p = tab.NewNode(Node.any, null, 0);  // p.set is set in tab.SetupAnys
                                   g = new Graph(p);
                                 
#line default //END SOURCE
			break;
		}
		case 37: {
			Get();

#line 387 "Coco.atg" //SOURCE beg=17766,len=130,col=36
																																				Node p = tab.NewNode(Node.sync, null, 0);
                                   g = new Graph(p);
                                 
#line default //END SOURCE
			break;
		}
		default: SynErr(52); break;
		}

#line 390 "Coco.atg" //SOURCE beg=17935,len=161,col=36
																																				if (g == null) // invalid start of Factor
                                     g = new Graph(tab.NewNode(Node.eps, null, 0));
                                 
#line default //END SOURCE
	}

	void Attribs(
#line 478 "Coco.atg" //SOURCE beg=21686,len=6,col=9
									Node p
#line default //END SOURCE
) {
		if (la.kind == 25) {
			Get();

#line 479 "Coco.atg" //SOURCE beg=21733,len=66,col=36
																																				int beg = la.pos; int col = la.col; int vline = GetVirtualLine(); 
#line default //END SOURCE
			while (StartOf(9)) {
				if (StartOf(10)) {
					Get();
				} else {
					Get();

#line 481 "Coco.atg" //SOURCE beg=21848,len=36,col=36
																																				SemErr("bad string in attributes"); 
#line default //END SOURCE
				}
			}
			Expect(26);

#line 483 "Coco.atg" //SOURCE beg=21928,len=87,col=36
																																				if (t.pos > beg) p.pos = new Position(beg, t.pos - beg, col, GetVirtualFile(), vline); 
#line default //END SOURCE
		} else if (la.kind == 27) {
			Get();

#line 484 "Coco.atg" //SOURCE beg=22054,len=66,col=36
																																				int beg = la.pos; int col = la.col; int vline = GetVirtualLine(); 
#line default //END SOURCE
			while (StartOf(11)) {
				if (StartOf(12)) {
					Get();
				} else {
					Get();

#line 486 "Coco.atg" //SOURCE beg=22169,len=36,col=36
																																				SemErr("bad string in attributes"); 
#line default //END SOURCE
				}
			}
			Expect(28);

#line 488 "Coco.atg" //SOURCE beg=22249,len=87,col=36
																																				if (t.pos > beg) p.pos = new Position(beg, t.pos - beg, col, GetVirtualFile(), vline); 
#line default //END SOURCE
		} else SynErr(53);
	}

	void Condition() {
		while (StartOf(20)) {
			if (la.kind == 31) {
				Get();
				Condition();
			} else {
				Get();
			}
		}
		Expect(32);
	}

	void TokenTerm(
#line 422 "Coco.atg" //SOURCE beg=19117,len=11,col=11
											out Graph g
#line default //END SOURCE
) {

#line 422 "Coco.atg" //SOURCE beg=19142,len=10,col=36
																																				Graph g2; 
#line default //END SOURCE
		TokenFactor(
#line 424 "Coco.atg" //SOURCE beg=19173,len=5,col=15
															out g
#line default //END SOURCE
);
		while (StartOf(7)) {
			TokenFactor(
#line 425 "Coco.atg" //SOURCE beg=19197,len=6,col=17
																	out g2
#line default //END SOURCE
);

#line 425 "Coco.atg" //SOURCE beg=19216,len=25,col=36
																																				tab.MakeSequence(g, g2); 
#line default //END SOURCE
		}
		if (la.kind == 39) {
			Get();
			Expect(31);
			TokenExpr(
#line 428 "Coco.atg" //SOURCE beg=19283,len=6,col=19
																			out g2
#line default //END SOURCE
);

#line 428 "Coco.atg" //SOURCE beg=19300,len=112,col=36
																																				tab.SetContextTrans(g2.l); dfa.hasCtxMoves = true;
                                   tab.MakeSequence(g, g2); 
#line default //END SOURCE
			Expect(32);
		}
	}

	void TokenFactor(
#line 436 "Coco.atg" //SOURCE beg=19539,len=11,col=13
													out Graph g
#line default //END SOURCE
) {

#line 436 "Coco.atg" //SOURCE beg=19562,len=23,col=36
																																				string name; int kind; 
#line default //END SOURCE

#line 438 "Coco.atg" //SOURCE beg=19627,len=10,col=36
																																				g = null; 
#line default //END SOURCE
		if (la.kind == _ident || la.kind == _string || la.kind == _char) {
			Sym(
#line 439 "Coco.atg" //SOURCE beg=19647,len=18,col=7
							out name, out kind
#line default //END SOURCE
);

#line 439 "Coco.atg" //SOURCE beg=19676,len=888,col=36
																																				if (kind == id) {
                                     CharClass c = tab.FindCharClass(name);
                                     if (c == null) {
                                       SemErr("undefined name");
                                       c = tab.NewCharClass(name, new CharSet());
                                     }
                                     Node p = tab.NewNode(Node.clas, null, 0); p.val = c.n;
                                     g = new Graph(p);
                                     tokenString = noString;
                                   } else { // str
                                     g = tab.StrToGraph(name);
                                     if (tokenString == null) tokenString = name;
                                     else tokenString = noString;
                                   }
                                 
#line default //END SOURCE
		} else if (la.kind == 31) {
			Get();
			TokenExpr(
#line 454 "Coco.atg" //SOURCE beg=20584,len=5,col=17
																	out g
#line default //END SOURCE
);
			Expect(32);
		} else if (la.kind == 33) {
			Get();
			TokenExpr(
#line 455 "Coco.atg" //SOURCE beg=20612,len=5,col=17
																	out g
#line default //END SOURCE
);
			Expect(34);

#line 455 "Coco.atg" //SOURCE beg=20631,len=19,col=36
																																				tab.MakeOption(g); 
#line default //END SOURCE
		} else if (la.kind == 35) {
			Get();
			TokenExpr(
#line 456 "Coco.atg" //SOURCE beg=20670,len=5,col=17
																	out g
#line default //END SOURCE
);
			Expect(36);

#line 456 "Coco.atg" //SOURCE beg=20689,len=22,col=36
																																				tab.MakeIteration(g); 
#line default //END SOURCE
		} else SynErr(54);

#line 457 "Coco.atg" //SOURCE beg=20750,len=132,col=36
																																				if (g == null) // invalid start of TokenFactor
                                     g = new Graph(tab.NewNode(Node.eps, null, 0)); 
#line default //END SOURCE
	}


#line 102 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME


	public void Parse() {
		la = new Token();
		la.val = "";		
		Get();

#line default //END FRAME -->parseRoot

		Coco();

#line 108 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

    Expect(0);
	}
	
	bool[,] set = {

#line default //END FRAME -->initialization

		{T,T,x,T, x,T,T,x, x,x,x,T, T,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x},
		{x,T,T,T, T,T,x,T, x,x,x,x, x,T,T,T, x,x,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x},
		{T,T,x,T, x,T,T,x, x,x,x,T, T,x,x,x, T,T,T,T, x,x,x,x, T,x,x,x, x,T,T,T, x,T,x,T, x,T,T,x, T,x,x,x, x,x},
		{T,T,x,T, x,T,T,x, x,x,x,T, T,x,x,x, T,T,T,x, T,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,x, T,x},
		{T,T,x,T, x,T,T,x, x,x,x,T, T,x,x,x, T,T,T,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x},
		{x,T,x,T, x,T,T,x, x,x,x,T, T,x,x,x, T,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x},
		{x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,T,x,T, x,x,x,x, x,x,x,x, x,x},
		{x,x,x,x, x,x,T,x, x,x,x,x, T,x,T,T, T,T,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x},
		{x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,x,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x},
		{x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,x,T,T, T,x},
		{x,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,x,T,T, T,x},
		{x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, T,x,x,x, x,T,T,T, T,T,T,T, T,T,T,x, T,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,x,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x},
		{x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,T, x,T,x,T, x,T,T,x, T,x,x,x, x,x},
		{x,T,x,T, x,T,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, T,x,x,x, x,x,T,T, x,T,x,T, x,T,x,x, T,x,x,x, x,x},
		{x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,x, x,x,x,T, x,x,x,x, x,x,x,x, x,T,x,x, T,x,T,x, T,x,x,x, x,x,x,x, x,x},
		{x,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, T,T,T,T, x,T,T,T, T,T,T,T, T,T,T,T, T,x}

#line 113 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

	};
} // end Parser


public partial class Errors {
	public int count = 0;                                    // number of errors detected
    public Action<string> WriteMessage = delegate(string text) { Console.WriteLine(text); };
    public Action<string> WriteError = delegate(string text) { Console.Error.WriteLine(text); };
    public string errMsgFormat = "({0},{1}){3}::{2}"; // 0=line, 1=column, 2=text, 3=file
  
	public void SynErr (int line, int col, int n) {
		string s;
		switch (n) {

#line default //END FRAME -->errors

			case 0: s = "EOF expected"; break;
			case 1: s = "ident expected"; break;
			case 2: s = "number expected"; break;
			case 3: s = "string expected"; break;
			case 4: s = "badString expected"; break;
			case 5: s = "char expected"; break;
			case 6: s = "filechg expected"; break;
			case 7: s = "\"COMPILER\" expected"; break;
			case 8: s = "\"IGNORECASE\" expected"; break;
			case 9: s = "\"CHARACTERS\" expected"; break;
			case 10: s = "\"TOKENS\" expected"; break;
			case 11: s = "\"PRAGMAS\" expected"; break;
			case 12: s = "\"COMMENTS\" expected"; break;
			case 13: s = "\"FROM\" expected"; break;
			case 14: s = "\"TO\" expected"; break;
			case 15: s = "\"NESTED\" expected"; break;
			case 16: s = "\"IGNORE\" expected"; break;
			case 17: s = "\"PRODUCTIONS\" expected"; break;
			case 18: s = "\"=\" expected"; break;
			case 19: s = "\".\" expected"; break;
			case 20: s = "\"END\" expected"; break;
			case 21: s = "\"+\" expected"; break;
			case 22: s = "\"-\" expected"; break;
			case 23: s = "\"..\" expected"; break;
			case 24: s = "\"ANY\" expected"; break;
			case 25: s = "\"<\" expected"; break;
			case 26: s = "\">\" expected"; break;
			case 27: s = "\"<.\" expected"; break;
			case 28: s = "\".>\" expected"; break;
			case 29: s = "\"|\" expected"; break;
			case 30: s = "\"WEAK\" expected"; break;
			case 31: s = "\"(\" expected"; break;
			case 32: s = "\")\" expected"; break;
			case 33: s = "\"[\" expected"; break;
			case 34: s = "\"]\" expected"; break;
			case 35: s = "\"{\" expected"; break;
			case 36: s = "\"}\" expected"; break;
			case 37: s = "\"SYNC\" expected"; break;
			case 38: s = "\"IF\" expected"; break;
			case 39: s = "\"CONTEXT\" expected"; break;
			case 40: s = "\"(.\" expected"; break;
			case 41: s = "\".)\" expected"; break;
			case 42: s = "\"using\" expected"; break;
			case 43: s = "\";\" expected"; break;
			case 44: s = "??? expected"; break;
			case 45: s = "this symbol not expected in Coco"; break;
			case 46: s = "this symbol not expected in TokenDecl"; break;
			case 47: s = "invalid TokenDecl"; break;
			case 48: s = "invalid AttrDecl"; break;
			case 49: s = "invalid SimSet"; break;
			case 50: s = "invalid Sym"; break;
			case 51: s = "invalid Term"; break;
			case 52: s = "invalid Factor"; break;
			case 53: s = "invalid Attribs"; break;
			case 54: s = "invalid TokenFactor"; break;

#line 127 "F:\DotNetProjects\Prexonite\PxCoco\Parser.frame" //FRAME

			default: s = "error " + n; break;
		}
        WriteError(String.Format(errMsgFormat, GetVirtualLine(line), col, s, GetVirtualFile()));
		count++;
	}

	public void SemErr (int line, int col, string s) {
        WriteError(String.Format(errMsgFormat, GetVirtualLine(line), col, s, GetVirtualFile())); ;
		count++;
	}
	
	public void SemErr (string s) {
        WriteError(String.Format(errMsgFormat, 0, 0, s, realFile)); ;
		count++;
	}
	
	public void Warning (int line, int col, string s) {
        WriteMessage(String.Format(errMsgFormat, GetVirtualLine(line), col, s, GetVirtualFile()));
	}
	
	public void Warning(string s) {
        WriteMessage(s);
	}
} // Errors


public class FatalError: Exception {
	public FatalError(string m): base(m) {}
}


#line default //END FRAME $$$

}
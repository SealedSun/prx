is psr_ast_pxs_open;
is compiler_loaded;

Import
{
    System,
    Prexonite,
    Prexonite::Types,
    Prexonite::Compiler,
    Prexonite::Compiler::Ast
};

function ast(type) [is compiler;]
{
    var args;
    var targs = args >> skip(1);

    return 
        asm(ldr.eng)
        .CreatePType("Object(\"Prexonite.Compiler.Ast.Ast$(type)\")")
        .Construct((["--COMPILER-HOOK--",-1,-1]+(targs >> all))~Object<"Prexonite.PValue[]">)
        .self;
}

function subBlocks(block) [is compiler;] =
    if(block.\implements("Prexonite.Compiler.Ast.IAstHasBlocks"))   
        ~List.CreateFromList(block~::IAstHasBlocks.Blocks)
    else
        [];

var uniqueIdCounter [is compiler;];
build does uniqueIdCounter =  0;
function uniqueId(verb) [is compiler;] = "hook\\" + verb + uniqueIdCounter++;

function isFunctionCall(id, node)[is compiler;] =
        node is ::AstGetSetSymbol And
        node.Interpretation~Int == ::SymbolInterpretations.$Function~Int And
        node.Id.ToLowerInvariant == id.ToString.ToLowerInvariant;
        
function isMemberAccess(id, node)[is compiler;] =
        node is ::AstGetSetMemberAccess And
        node.Id.ToLowerInvariant == id.ToString.ToLowerInvariant;
        
function localMeta(key, context)[is compiler;] =
    if(context.Meta.ContainsKey(key))
        context.Meta[key]
    else
        context.ParentApplication.Meta[key];
        
var SI [is compiler;];
function create_SI [is compiler;]
{
    SI = new Structure;
    SI.\("lvar") = ::SymbolInterpretations.LocalObjectVariable;
    SI.\("lref") = ::SymbolInterpretations.LocalReferenceVariable;
    SI.\("gvar") = ::SymbolInterpretations.GlobalObjectVariable;
    SI.\("gref") = ::SymbolInterpretations.GlobalReferenceVariable;
    SI.\("func") = ::SymbolInterpretations.$Function;
    SI.\("cmd") = ::SymbolInterpretations.$Command;
    SI.\\("eq") = (this, l, r) => l~Int == r~Int;
    SI.\\("is_lvar") = (this, s) => s~Int == this.lvar~Int;
    SI.\\("is_lref") = (this, s) => s~Int == this.lref~Int;
    SI.\\("is_gvar") = (this, s) => s~Int == this.gvar~Int;
    SI.\\("is_gref") = (this, s) => s~Int == this.gref~Int;
    SI.\\("is_func") = (this, s) => s~Int == this.func~Int;
    SI.\\("is_cmd") = (this, s) => s~Int == this.cmd~Int;
    SI.\\("is_obj") = (this, s) => this.is_lvar(s) || this.is_gvar(s);
    SI.\\("is_ref") = (this, s) => this.is_lref(s) || this.is_gref(s);
    SI.\\("is_global") = (this, s) => this.is_gvar(s) || this.is_gref(s);
    SI.\\("is_local") = (this, s) => this.is_lvar(s) || this.is_lref(s);
    SI.\\("make_global") = (this, s) => 
        if(this.is_obj(s))
            this.gvar
        else if(this.is_ref(s))
            this.gref
        else
            throw "$s cannot be made global.";            
    SI.\\("make_local") = (this, s) => 
        if(this.is_obj(s))
            this.lvar
        else if(this.is_ref(s))
            this.lref
        else
            throw "$s cannot be made local.";
    SI.\\("make_obj") = (this, s) =>
        if(this.is_local(s))
            this.lvar
        else if(this.is_global(s))
            this.gvar
        else
            throw "$s cannot be made object.";
    SI.\\("make_ref") = (this, s) =>
        if(this.is_local(s))
            this.lref
        else if(this.is_global(s))
            this.gref
        else
            throw "$s cannot be made reference.";
}
build does create_SI;

var _stmt_hooks [is compiler;];
build does _stmt_hooks = [];

function hook_impl(t) [ is compiler; ]
{
    if(_stmt_hooks.Count == 0)
        return;
        
    //Allocate variables for each stmt_hook
    var stores = {};
    foreach(var fhook in _stmt_hooks)
    {
        var lst = [];        
        for(var i = 0; i < fhook.Value; i++)
            lst[] = new Prexonite::PVariable;
        stores[fhook.Key] = lst;
    }
    
    
    var hooks = _stmt_hooks >> all;
            
    function process(block)
    {
        for(var i = 0; i < block.Count; i++)
        {
            foreach(var fhook in hooks)
            {
                var hook = fhook.Key;
                if(call(hook, t, block[i], ->i, stores[hook]))
                    hooks.Remove(hook);
                if(i >= block.Count Or i < 0)
                    break;
            }
        }
        
        //Recursively process statements in sub block
        foreach(var subBlock in subBlocks(block))
            process(subBlock);
    }
    
    //Process top-level block
    process(t.Ast);
}

//SIGNATURE OF STMT_HOOKS:
//
//  (t, stmt, ref i, ref customVariable1, ..., ref customVariableN) => true Or false
//
//  t => CompilerTarget
//  stmt => the current statement
//  ref i => the index
//  custom variable objects are passed to the function depending on your setting for the stmt_hook.

var _stmt_hook_active [is compiler;];
build does _stmt_hook_active = false;

function mk_hook(fhook) [is compiler;] = if(Not fhook is Prexonite::Types::PValueKeyValuePair)
                              (fhook: 0)
                          else
                              fhook;
                              
function not_null(arg) [is compiler;] = Not arg is Null;

//Add a statement hook to the shared compiler hook
//  Usage:
//      stmt_hook
//          ( 
//              (t,stmt,ref i, ref v1, ref v2) => {...} : 2,
//              (t,stmt,ref i, ref v1, ref v2, ref v3, ref v4) => {...} : 4,
//              (t,stmt,ref i) => {...} : 0,
//              (t,stmt) => {...}
//          )
//
//  The value in the key-value pair indictaes the number of per function variables to create
//  If no key is provided, 0 is assumed.
function stmt_hook() [ is compiler; ] does
{
    (var args)
    >> where(->not_null)
    >> map(->mk_hook)    
    >> where(fhook => Not _stmt_hooks.Contains(fhook))
    >> each( fhook => _stmt_hooks[] = fhook);
    if(not _stmt_hook_active)
    {
        declare command hook;
        hook(->hook_impl);
        _stmt_hook_active = true;
    }
}
     
function remove_stmt_hook() [ is compiler; ] = 
    (var args)
    >> where(->not_null)
    >> map(->mk_hook)
    >> each( fhook => _stmt_hooks.Remove(fhook));
   
//
//  Removal of compiler related functions and variables from the final application
//

function unload_compiler()
{
    //unload_compiler removes itself and is thus not marked [is compiler;]
    //  Note: to simplify things, TRY NOT TO USE INNER FUNCTIONS HERE.
    declare command GetLoader;
    var app = GetLoader.ParentApplication;
    
    //Variables
    var comp_vars = [];
    foreach(var kvp in app.Variables)
        if(kvp.Value.Meta["compiler"].Switch)
            comp_vars[] = kvp.Key;
            
    foreach(var comp_var in comp_vars)
        app.Variables.Remove(comp_var);        
    
    //Functions
    var ordinalIc = System::StringComparison.OrdinalIgnoreCase;
    var comp_funcs = [];
    //Recursively mark all compiler functions and their inner functions
    function mark_comp_func(func)
    {
        var fid = func.Id;
        foreach(var inner in app.Functions)
            if(inner.Meta["ParentFunction"].Text.Equals(fid,ordinalIc) and 
              not inner.Meta["compiler"].Switch)
            {
                inner.Meta["compiler"] = true;
                comp_funcs[] = inner;
                mark_comp_func(inner);
            }        
    }
    
    //Mark and collect    
    foreach(var func in app.Functions)
        if(func.Meta["compiler"].Switch)
        {
            comp_funcs[] = func;
            mark_comp_func(func);
        }
            
    //Remove functions
    foreach(var comp_func in comp_funcs)
        app.Functions.Remove(comp_func);
        
    app.Functions.Remove(->unload_compiler);
    app.Functions.Remove(->mark_comp_func);
    app.Meta["compiler_loaded"] = false;
}
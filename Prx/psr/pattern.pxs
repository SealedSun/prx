
build does require(@"psr\macro.pxs", @"psr\struct.pxs", @"psr\prop.pxs");

coroutine zip(xs,ys)
{
	using(var xsE = xs.GetEnumerator)
	using(var ysE = ys.GetEnumerator)
		while(xsE.MoveNext and ysE.MoveNext)
			yield xsE.Current : ysE.Current;
}

function repeatable(xs)
{

    var rep = [];

    coroutine tee\cor
    {
        foreach(var x in xs)
        {
            yield rep[] = x;            
        }
    }
    
    var tee = tee\cor();

    function GetEnumerator(this) 
    {
        return (append(rep,tee)).GetEnumerator;
    }
    
    function ToString = "repeatable $xs";
    
    return struct;
}

macro pattern\construct(desc)
{
    desc = macro\unpack(desc);
    
	var targets = var args >> skip(1) >> map(a => {optimize\ref(context,->a); return a;}) >> all;
	var dynamicCall = ast\invoke_macro(desc.construct, SI.m.func);
	dynamicCall.Arguments.AddRange(targets); 
    return dynamicCall;
}

macro pattern\deconstruct(desc)
{    
    desc = macro\unpack(desc);
    
    var args;
	var targets = var args >> range(1,args.Count-2) >> map(a => {optimize\ref(context,->a); return a;}) >> all;
	var the_object = args[args.Count - 1];
    
	var block = ast("BlockExpression");
	
	//Temporary variable used to hold RHS, if RHS is not an object variable itself
	var tempV;
	var useTemp;
	if(the_object is Prexonite::Compiler::Ast::AstGetSetSymbol and SI.is_obj(the_object.Interpretation))
    {
        useTemp = false;
        tempV = the_object.Id;
    }        
    else
    {
        useTemp = true;
        tempV = tempalloc;       
    
        var assignTmp = ast\lvar(SI.set, tempV);
        assignTmp.Arguments.Add(the_object);
        block.Add(assignTmp);
    }
	
	foreach(var bpt in zip(desc.bindings,targets))
	{
		var binding = bpt.Key;
		var bindingTarget = bpt.Value;
		var binding_name = binding.Name;
		if(not bindingTarget.\implements("Prexonite.Compiler.Ast.AstGetSet"))
            throw "The target $binding_name of $(desc.name) must be assignable.";
        if(not SI.eq(bindingTarget.Call,SI.get))
            throw "The target $binding_name of $(desc.name) must not be a set-call";	
    
        //var dynamicMacroCall = code(call\macro(binding.getValue~String,[tempV]));
        //var tempVListLit = ast("ListLiteral");
        //tempVListLit.Elements.Add(ast\const(tempV));
        //var dynamicMacroCall = ast\macro(call\macro(ast\const(binding.getValue~String), tempVListLit));
        var dynamicMacroCall = ast\invoke_macro(binding.getValue, SI.m.func);
        dynamicMacroCall.Arguments.Add(ast\const(tempV));
            
    	var setTarget = bindingTarget.GetCopy();
    	setTarget.Call = SI.set;
    	setTarget.Arguments.Add(dynamicMacroCall);
    	block.Add(setTarget);
	}
	
	//Behave like a proper set-call and return the RHS
	block.Expression = ast\lvar(SI.get, tempV);
    
	//Free temporary variable, if necessary
    if(useTemp)
        tempfree(tempV);
        
    return block;
}

function create_binding_desc(kvp) [is compiler;]
{
	if(kvp is not Prexonite::Types::PValueKeyValuePair)
		throw "Signature: create_binding(name: obj_var_id => deconstruct)";
	var _name = kvp.Key;
	var _getValue = kvp.Value;
    
    if(_getValue is Prexonite::PFunction)
        _getValue = _getValue.Id;
        
    _getValue ~= String;
	
	function name = _name;
	function getValue = _getValue;
    function ToString = "$name(->$getValue)";
	
	return struct;
}

function create_pat_desc(_name, _bindings, _construct) [is compiler;]
{	
	if(_name is not String)
		throw "Pattern needs a name.";
	
	_bindings = _bindings >> map(->create_binding_desc) >> repeatable;
    
    if(_construct is Prexonite::PFunction)
        _construct = _construct.Id;        
    _construct ~= String;
    
	function name = _name;	
	function bindings = _bindings;
	function construct = _construct;
    function ToString(this) = "data $name = $name(" + foldl((a,b) => a + " " + b.ToString,"", this.bindings) + " );";
	
	return struct;
}

macro pattern\gen(desc)
{
    var result;
    var args = args >> skip(1);
    
    if(SI.eq(context.Call,SI.get))
    {
        //construct value
        result = call\macro([pattern\construct(desc)], args);
    }
    else
    {
        //deconstruct value
        result = call\macro([pattern\deconstruct(desc)], args);
    }
   
    return result;
}

macro kvp\decon\key(tempV)
{
    var tempV = ast\read(context, tempV);
    return ast\member(ast\lvar(SI.get, tempV), SI.get,"Key");
}

macro kvp\decon\value(tempV)
{
    return ast\member(ast\lvar(SI.get, ast\read(context, tempV)), SI.get,"Value");
}

macro kvp\con(key, value)
{
    return ast("KeyValuePair",key,value);
}

macro kvp
{    
    var desc = create_pat_desc("KeyValuePair",
            [ "key": macro\reference(kvp\decon\key)
            , "value": macro\reference(kvp\decon\value)
            ]
        , macro\reference(kvp\con)
        );
    var args;
    return call\macro([pattern\gen(ast\const(macro\pack(desc))),false,context.Call], var args);
}
is psr_ast_pxs_open;
is compiler_loaded;

Import
{
    System,
    Prexonite,
    Prexonite::Types,
    Prexonite::Compiler,
    Prexonite::Compiler::Ast
};

function ast\withPos(type, file, line, column) [is compiler;]
{
    var args;
    var targs = args >> skip(4);

    file ??= "--COMPILER-HOOK--";
    line ??= -1;
    column ??= -1;
    
    return 
        asm(ldr.eng)
        .CreatePType("Object(\"Prexonite.Compiler.Ast.Ast$(type)\")")
        .Construct(([file,line,column]+(targs >> all))~Object<"Prexonite.PValue[]">)
        .self;
}

function ast\simple as ast(type) [is compiler;]
{
    call(->ast\withPos,[type,null,null,null] + (var args >> skip(1) >> all));
}

function subBlocks(block) [is compiler;] =
    if(block.\implements("Prexonite.Compiler.Ast.IAstHasBlocks"))   
        ~List.CreateFromList(block~::IAstHasBlocks.Blocks)
    else
        [];

var uniqueIdCounter [is compiler;];
build does uniqueIdCounter =  0;
function uniqueId(verb) [is compiler;] = "hook\\" + verb + uniqueIdCounter++;

function isFunctionCall(id, node)[is compiler;] =
        node is ::AstGetSetSymbol And
        node.Interpretation~Int == ::SymbolInterpretations.$Function~Int And
        node.Id.ToLowerInvariant == id.ToString.ToLowerInvariant;
        
function isMemberAccess(id, node)[is compiler;] =
        node is ::AstGetSetMemberAccess And
        node.Id.ToLowerInvariant == id.ToString.ToLowerInvariant;
        
function localMeta(key, context)[is compiler;] =
    if(context.Meta.ContainsKey(key))
        context.Meta[key]
    else
        context.ParentApplication.Meta[key];
        
var SI [is compiler;];
function create_SI [is compiler;]
{
    SI = new Structure;
    SI.\("lvar") = ::SymbolInterpretations.LocalObjectVariable;
    SI.\("lref") = ::SymbolInterpretations.LocalReferenceVariable;
    SI.\("gvar") = ::SymbolInterpretations.GlobalObjectVariable;
    SI.\("gref") = ::SymbolInterpretations.GlobalReferenceVariable;
    SI.\("func") = ::SymbolInterpretations.$Function;
    SI.\("cmd") = ::SymbolInterpretations.$Command;
    SI.\("get") = Prexonite::Types::PCall.Get;
    SI.\("set") = Prexonite::Types::PCall.Set;
    SI.\\("eq") = (this, l, r) => l~Int == r~Int;
    SI.\\("is_lvar") = (this, s) => s~Int == this.lvar~Int;
    SI.\\("is_lref") = (this, s) => s~Int == this.lref~Int;
    SI.\\("is_gvar") = (this, s) => s~Int == this.gvar~Int;
    SI.\\("is_gref") = (this, s) => s~Int == this.gref~Int;
    SI.\\("is_func") = (this, s) => s~Int == this.func~Int;
    SI.\\("is_cmd") = (this, s) => s~Int == this.cmd~Int;
    SI.\\("is_obj") = (this, s) => this.is_lvar(s) || this.is_gvar(s);
    SI.\\("is_ref") = (this, s) => this.is_lref(s) || this.is_gref(s);
    SI.\\("is_global") = (this, s) => this.is_gvar(s) || this.is_gref(s);
    SI.\\("is_local") = (this, s) => this.is_lvar(s) || this.is_lref(s);
    SI.\\("make_global") = (this, s) => 
        if(this.is_obj(s))
            this.gvar
        else if(this.is_ref(s))
            this.gref
        else
            throw "$s cannot be made global.";            
    SI.\\("make_local") = (this, s) => 
        if(this.is_obj(s))
            this.lvar
        else if(this.is_ref(s))
            this.lref
        else
            throw "$s cannot be made local.";
    SI.\\("make_obj") = (this, s) =>
        if(this.is_local(s))
            this.lvar
        else if(this.is_global(s))
            this.gvar
        else
            throw "$s cannot be made object.";
    SI.\\("make_ref") = (this, s) =>
        if(this.is_local(s))
            this.lref
        else if(this.is_global(s))
            this.gref
        else
            throw "$s cannot be made reference.";
}
build does create_SI;
   
//
//  Removal of compiler related functions and variables from the final application
//

function unload_compiler()
{
    //unload_compiler removes itself and is thus not marked [is compiler;]
    //  Note: to simplify things, TRY NOT TO USE INNER FUNCTIONS HERE.
    declare command GetLoader;
    var app = GetLoader.ParentApplication;
    
    //Variables
    var comp_vars = [];
    foreach(var kvp in app.Variables)
        if(kvp.Value.Meta["compiler"].Switch)
            comp_vars[] = kvp.Key;
            
    foreach(var comp_var in comp_vars)
        app.Variables.Remove(comp_var);        
    
    //Functions
    var ordinalIc = System::StringComparison.OrdinalIgnoreCase;
    var comp_funcs = [];
    //Recursively mark all compiler functions and their inner functions
    function mark_comp_func(func)
    {
        var fid = func.Id;
        foreach(var inner in app.Functions)
            if(inner.Meta["ParentFunction"].Text.Equals(fid,ordinalIc) and 
              not inner.Meta["compiler"].Switch)
            {
                inner.Meta["compiler"] = true;
                comp_funcs[] = inner;
                mark_comp_func(inner);
            }        
    }
    
    //Mark and collect    
    foreach(var func in app.Functions)
        if(func.Meta["compiler"].Switch)
        {
            comp_funcs[] = func;
            mark_comp_func(func);
        }
            
    //Remove functions
    foreach(var comp_func in comp_funcs)
        app.Functions.Remove(comp_func);
        
    app.Functions.Remove(->unload_compiler);
    app.Functions.Remove(->mark_comp_func.$Function.Id);
    app.Meta["compiler_loaded"] = false;
}
//Misc.

build does require
(
    "struct.pxs"
);

function roundTo(x,r) does
    r~= Real; and
    x~= Real; and return
    round( x/r ) * r;

function cmp(a,b) =
    if(a > b)
        -1
    else if(b > a)
        1
    else 
        0;
        
function cmp_values(a,b,ccmp) = (ccmp ?? ->cmp).(a.Value,b.Value);

function cmp_keys(a,b,ccmp) = (ccmp ?? ->cmp).(a.Key,b.Key);

function cmpWith(f,ccmp) 
{
    ccmp ??= ->cmp;
    return (a,b) => ccmp.(f.(a),f.(b));
}

function cmpr(a,b,ccmp) = (ccmp ?? ->cmp).(b,a);

function ieq(a,b) = a~Int == b~Int;
function ieq_any(a) = 
    var args >> skip(1) >> exists( b => ieq(a,b) );
            
    
//Creates a wrapper around an object that intercepts calls to dispose.
function create_terminator (obj, termination)
{
    function Call(this,id)
    {
        var args;
        if(args.Count < 2) //invalid call
            return null;
            
        if(id.ToUpper == "DISPOSE")
        {
            termination.();
            return null;
        }
        else
        {
            args.RemoveAt(0,1);
            return call\member(obj,id,args);
        }
    }
    
    return struct;   
}

function create_lazy(factory)
{
    var _computed = false;
    var _value;
    function computed = computed;
    function value 
    {
        if(_computed)
        {
            return _value;
        }
        else
        {
            _computed = true;
            return _value = factory.();
        }
    }
    
   function lazy(this,f) = create_lazy(() => f.(this.value));
            
    return struct;            
}

//Misc.

build does require
(
    @"psr\struct.pxs"
);

function cmp(a,b) =
    if(a > b)
        -1
    else if(b > a)
        1
    else 
        0;
        
function cmp_values(a,b,ccmp) = (ccmp ?? ->cmp).(a.Value,b.Value);

function cmp_keys(a,b,ccmp) = (ccmp ?? ->cmp).(a.Key,b.Key);

function cmp_with as cmpWith(f,ccmp) 
{
    ccmp ??= cmp(?,?);
    return (a,b) => ccmp.(f.(a),f.(b));
}

function cmp_then
{ 
    var fs = var args;
    return (a,b) =>
    {
        var r = 0;
        foreach(var f in fs)
        {
            r = f.(a,b);
            if(r != 0)
                return r;
        }
        return r;
    };
}

function cmpr(a,b,ccmp) = (ccmp ?? ->cmp).(b,a);

function ieq(a,b) = a~Int == b~Int;
function ieq_any(a) = 
    var args >> skip(1) >> exists( b => ieq(a,b) );
function ieq_all(a) =
    var args >> skip(1) >> forall( b => ieq(a,b) );
    
function refeq(a,b) = System::Object.ReferenceEquals(a,b);
function nrefeq(a,b) = not System::Object.ReferenceEquals(a,b);

function on (f,selector) => (a,b) => f.(selector.(a),selector.(b));
                
//Creates a wrapper around an object that intercepts calls to dispose.
function create_terminator (obj, termination)
{
    function Call(this,id)
    {
        var args;
        if(args.Count < 2) //invalid call
            return null;
            
        if(id.ToUpper == "DISPOSE")
        {
            termination.();
            return null;
        }
        else
        {
            args.RemoveAt(0,1);
            return call\member(obj,id,args);
        }
    }
    
    return struct;   
}

function create_lazy\impl(factory) = lazy factory.();
macro create_lazy()
{
    macro\report_warning("create_lazy is deprecated, use the lazy keyword instead.");
    var f = ast\func(->create_lazy\impl.Id);
    f.Arguments.AddRange(var args);
    return f;
}

macro swap(x,y)
{
    if(not (ast_is_GetSet(x) and ast_is_GetSet(y)))
    {
        macro\report_error("Can only swap between two assignable expressions");
        return;
    }
    
    var tempV = tempalloc;
    
    var assignTemp = ast\lvar(SI.Set, tempV);
    assignTemp.Call = SI.set;  
    
    var assignY = y.GetCopy;
    assignY.Call = SI.set;
    
    var assignX = x.GetCopy;
    assignX.Call = SI.set;
    
    var overAssign;
    var finalAssign;
    var varA;
    var varB;
    
    if(SI.eq(context.Call,SI.get))
    {
        //Make sure, "x" is returned
        varA = x;
        varB = y;
        overAssign = assignX;
        finalAssign = assignY;
    }
    else 
    {
        varA = y;
        varB = x;
        overAssign = assignY;
        finalAssign = assignX;
    }
    
    assignTemp.Arguments.Add(varA);
    overAssign.Arguments.Add(varB);
    finalAssign.Arguments.Add(ast\lvar(tempV));
    
    context.Block.Add(assignTemp);
    context.Block.Add(overAssign);
    context.Block.Expression = finalAssign;
    
    tempfree(tempV);
}

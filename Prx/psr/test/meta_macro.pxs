// Prexonite
// 
// Copyright (c) 2011, Christian Klauser
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:
// 
//     Redistributions of source code must retain the above copyright notice, 
//          this list of conditions and the following disclaimer.
//     Redistributions in binary form must reproduce the above copyright notice, 
//          this list of conditions and the following disclaimer in the 
//          documentation and/or other materials provided with the distribution.
//     The names of the contributors may be used to endorse or 
//          promote products derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
//  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


build does require(@"..\test.pxs");

test\plugins {};

build
{
    var app = asm(ldr.app);
    app.Meta[@"test\plugins"] = app.Meta[@"test\plugins"].AddToList([app.Module.Name.ToMetaEntry()]~Object<"Prexonite.MetaEntry[]">);
}

function test\execute_single_macro as execute_single_macro(ldr, testMacro)
[Import {System, Prexonite, Prexonite::Types, Prexonite::Compiler, Prexonite::Compiler::Ast}]
{
    var eng = ldr.ParentEngine;
    var app = ldr.ParentApplication;
    
    var hostFuncId = @"test\run_single_macro\hostFuncId";
    var hostFunc = app.CreateFunction(hostFuncId);
    var funcTar;
    try
    {
        //Setup function hosting the macro invocation
        var fakeFile = @"psr\test\meta_macro.pxs\test\run_single_macro\anonymous";
        var block = new ::AstBlock(fakeFile,-1,-1);
        app.Functions.Add(hostFunc);
        funcTar = ldr.CreateFunctionTarget(hostFunc, block);
        
        //Setup invocation of test macro
        //TODO: extract module from testMacro
        var invocation = new ::AstMacroInvocation(fakeFile,-1,-1,
            new ::SymbolEntry(::SymbolInterpretations.Function,testMacro.Id, testMacro.ParentApplication.Module.Name));
        block.Add(invocation);
        
        //Compile host function
        block.EmitCode(funcTar, true, ::StackSemantics.Effect);
        funcTar.FinishTarget(); 
        //technically, finishing the host function isn't necessary (the test macro has already been executed)
        //  but some error might only be detected during finishing.
    }
    finally
    {
        if(app.Functions.Contains(hostFuncId))
            app.Functions.Remove(hostFuncId);
        foreach(var ct in ldr.FunctionTargets)
        {
            if(app.Functions.Contains(ct.Function.Id))
                app.Functions.Remove(ct.Function);
        }
    }
}

function test\run_single_macro as run_single_macro(testMacro)
[
    Add Prexonite to Imports;
    Add Prexonite::Types to Imports;
    Add Prexonite::Compiler to Imports;
    Add Prexonite::Compiler::Ast to Imports;
]
{
    while(testMacro is Structure)
        testMacro = testMacro.self;
        
    if(testMacro is not Prexonite::PFunction)
        throw "test\\run_single_macro expects a macro function, and not $(boxed(testMacro)).";
    if(not testMacro.IsMacro)
        throw "test\\run_single_macro expects a macro function. $testMacro is not a macro.";
        
    var app = asm(ldr.app);
    var eng = asm(ldr.eng);
    
    var ldr = new ::Loader(eng, app);
    
    execute_single_macro(ldr, testMacro);
    
    ldr.Warnings >> each(println(?));
    if(ldr.Errors.Count > 0)
        throw ldr.Errors[0].ToString;
}

function test\create_macro_function_wrapper as create_macro_function_wrapper(testMacroFunc)
{
    var s = new Structure;
    s.\("self") = testMacroFunc;
    s.\\("Call") = (self,id) => call\member(self.self,id,var args >> skip(2));
    s.\\("IndirectCall") = (self) => run_single_macro(self.self);
    
    return s;
}

function test\macro_filter as macro_filter(testFunc)
{
    if(testFunc.IsMacro)
        return new macro_function_wrapper(testFunc);
    else
        return testFunc;
}

function test_meta_macro_init()
{    
}

{
    test_filters[] = macro_filter(?);
}
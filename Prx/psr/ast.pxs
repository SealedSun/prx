// Prexonite
// 
// Copyright (c) 2011, Christian Klauser
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without modification, 
//  are permitted provided that the following conditions are met:
// 
//     Redistributions of source code must retain the above copyright notice, 
//          this list of conditions and the following disclaimer.
//     Redistributions in binary form must reproduce the above copyright notice, 
//          this list of conditions and the following disclaimer in the 
//          documentation and/or other materials provided with the distribution.
//     The names of the contributors may be used to endorse or 
//          promote products derived from this software without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND 
//  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED 
//  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
//  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, 
//  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
//  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
//  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, 
//  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING 
//  IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

is psr_ast_pxs_open;
is compiler_loaded;

Import
{
    System,
    Prexonite,
    Prexonite::Types,
    Prexonite::Compiler,
    Prexonite::Compiler::Ast
};

function ast\withPos(type, file, line, column) [is compiler;]
{
    var args;
    var targs = args >> skip(4);

    file ??= "--COMPILER-HOOK--";
    file ~= String;
    
    line ??= -1;
    line ~= Int;
    
    column ??= -1;
    column~= Int;
    
    return 
        asm(ldr.eng)
        .CreatePType("Object(\"Prexonite.Compiler.Ast.Ast$(type)\")")
        .Construct(([file,line,column]+(targs >> all))~Object<"Prexonite.PValue[]">)
        .self;
}

function ast\simple as ast(type) [is compiler;]
{
    call(->ast\withPos,[type,null,null,null] + (var args >> skip(1) >> all));
}

function subBlocks(block) [is compiler;] =
    if(block.\implements("Prexonite.Compiler.Ast.IAstHasBlocks"))   
        ~List.CreateFromList(block~::IAstHasBlocks.Blocks)
    else
        [];

function uniqueIdCounter(x)[compiler]
{
    static var counter ??= 0;
    if((var args).Count > 0)
        counter = x;
    return counter;
}
function uniqueId(verb) [is compiler;] = "uniq\\" + verb + uniqueIdCounter++;

function isFunctionCall(id, node)[is compiler;] =
        node is ::AstGetSetSymbol And
        node.Implementation.Interpretation~Int == ::SymbolInterpretations.Function~Int And
        Prexonite::Engine.StringsAreEqual(node.Implementation.InternalId, id.ToString);
        
function isMemberAccess(id, node)[is compiler;] =
        node is ::AstGetSetMemberAccess And
        Prexonite::Engine.StringsAreEqual(node.Id, id.ToString);
        
function localMeta(key, context)[is compiler;] =
    if(context.Meta.ContainsKey(key))
        context.Meta[key]
    else
        context.ParentApplication.Meta[key];
        
function create_SI [is compiler;]
{
    //Note: don't use struct here, because struct.pxs depends on ast.pxs!
    var SI = new Structure;
    var si_lvar = ::SymbolInterpretations.LocalObjectVariable;
    var si_lref = ::SymbolInterpretations.LocalReferenceVariable;
    var si_gvar = ::SymbolInterpretations.GlobalObjectVariable;
    var si_gref = ::SymbolInterpretations.GlobalReferenceVariable;
    var si_func = ::SymbolInterpretations.Function;
    var si_cmd = ::SymbolInterpretations.Command;
    var si_mcmd = ::SymbolInterpretations.MacroCommand;
    SI.\\("lvar") = (_,id) => if(id is null) 
            si_lvar
        else 
            ::SymbolEntry.LocalObjectVariable(id);
    SI.\\("lref") = (_,id) => if(id is null) 
            si_lref
        else 
            ::SymbolEntry.LocalReferenceVariable(id);
    SI.\\("gvar") = (self,id,m) =>
        if(id is ::SymbolEntry)
            if(self.is_gvar(id.Interpretation))
                id
            else
                throw "Supplied symbol entry ($id) is not a global object variable, but was used in SI.gvar."
        else if(var args.Count >= 3 and id is String)
            new ::SymbolEntry(si_gvar, id, m)
        else if(var args.Count == 1)
            si_gvar
        else
            throw "Global variable symbol entry requires a module name.";
    SI.\\("gref") = (self,id,m) => 
        if(id is ::SymbolEntry)
            if(self.is_gref(id.Interpretation))
                id
            else
                throw "Supplied symbol entry ($id) is not a global reference variable, but was used in SI.gref."
        else if(var args.Count >= 3 and id is String)
            new ::SymbolEntry(si_gref, id, m)
        else if(var args.Count == 1)
            si_gref
        else
            throw "Global variable symbol entry requires a module name.";;
    SI.\\("func") = (self,func,m) => 
        if(func is ::PFunction)
            //TODO: figure out how to get hold of the module
            new ::SymbolEntry(si_func, func.Id, null)
        else if(func is ::SymbolEntry)
            if(self.is_func(func.Interpretation))
                func
            else
                throw "Supplied symbol entry ($func) is not a function, but was used in SI.func."
        else if(var args.Count >= 3 and func is String)
            new ::SymbolEntry(si_func, func, m)
        else
            si_func;
    SI.\\("cmd") =  (_,id) => if(id is null) 
            si_cmd
        else 
            ::SymbolEntry.Command(id);
    SI.\\("mcmd") = (_,id) => if(id is null) 
            si_mcmd
        else 
            ::SymbolEntry.MacroCommand(id);
    SI.\("get") = Prexonite::Types::PCall.Get;
    SI.\("set") = Prexonite::Types::PCall.Set;
	SI.\("ret\\exit") = Prexonite::Compiler::Ast::ReturnVariant.Exit;
	SI.\("ret\\set") = Prexonite::Compiler::Ast::ReturnVariant.Set;
	SI.\("ret\\continue") = Prexonite::Compiler::Ast::ReturnVariant.Continue;
	SI.\("ret\\break") = Prexonite::Compiler::Ast::ReturnVariant.Break;
    SI.\\("eq") = (this, l, r) => l~Int == r~Int;
    SI.\\("is_lvar") = (this, s) => s~Int == this.lvar~Int;
    SI.\\("is_lref") = (this, s) => s~Int == this.lref~Int;
    SI.\\("is_gvar") = (this, s) => s~Int == this.gvar~Int;
    SI.\\("is_gref") = (this, s) => s~Int == this.gref~Int;
    SI.\\("is_func") = (this, s) => s~Int == this.func~Int;
    SI.\\("is_cmd") = (this, s) => s~Int == this.cmd~Int;
    SI.\\("is_mcmd") = (this, s) => s~Int == this.mcmd~Int;
    SI.\\("is_obj") = (this, s) => this.is_lvar(s) || this.is_gvar(s);
    SI.\\("is_ref") = (this, s) => this.is_lref(s) || this.is_gref(s);
    SI.\\("is_global") = (this, s) => this.is_gvar(s) || this.is_gref(s);
    SI.\\("is_local") = (this, s) => this.is_lvar(s) || this.is_lref(s);
    SI.\\("make_global") = (this, s) => 
        if(this.is_obj(s))
            this.gvar
        else if(this.is_ref(s))
            this.gref
        else
            throw "$s cannot be made global.";            
    SI.\\("make_local") = (this, s) => 
        if(this.is_obj(s))
            this.lvar
        else if(this.is_ref(s))
            this.lref
        else
            throw "$s cannot be made local.";
    SI.\\("make_obj") = (this, s) =>
        if(this.is_local(s))
            this.lvar
        else if(this.is_global(s))
            this.gvar
        else
            throw "$s cannot be made object.";
    SI.\\("make_ref") = (this, s) =>
        if(this.is_local(s))
            this.lref
        else if(this.is_global(s))
            this.gref
        else
            throw "$s cannot be made reference.";
            
    //Macro specific
    //Internal
    function create_i(p)
    {
        var i = new Structure;
        i.\("parent") = p;
        i.\\("gvar") = (self,id) =>
            if(id is not string)
                "SI.i.gvar(id) requires an id~String, and not $(boxed(id))"
            else 
                self.parent.gvar(id,null);
        i.\\("gref") = (self,id) =>
            if(id is not string)
                "SI.i.gref(id) requires an id~String, and not $(boxed(id))"
            else 
                self.parent.gref(id,null);
        i.\\("func") = (self,id) =>
            if(id is not string)
                "SI.i.func(id) requires an id~String, and not $(boxed(id))"
            else 
                self.parent.func(id,null);
        return i;
    }
    SI.\("i") = new i(SI); 
    
    var m = new Structure;
    m.\\("func") = SI.func(?1,?2); //skip self argument
    m.\\("cmd")  = SI.mcmd(?1);
    m.\\("is_func") = (this, s) => s~Int == this.func~Int;
    m.\\("is_cmd") = (this, s) => s~Int == this.cmd~Int;
    m.\("i") = new i(m);
    SI.\("m") = m;
    
           
    
    return SI;
}

function SI(x)[compiler]
{
    static var field ??= new SI;
    return field;
}
   
//
//  Removal of compiler related functions and variables from the final application
//

function unload_compiler(GetLoader\cmd)
{
    //unload_compiler removes itself and is thus not marked [is compiler;]
    //  Note: to simplify things, TRY NOT TO USE INNER FUNCTIONS HERE.
    declare command GetLoader;
    GetLoader\cmd ??= ->GetLoader;
    ref GetLoader = GetLoader\cmd;
    var app = GetLoader.ParentApplication;
    
    //Variables
    var comp_vars = [];
    foreach(var kvp in app.Variables)
        if(kvp.Value.Meta["compiler"].Switch)
            comp_vars[] = kvp;
            
    //Functions
    var ordinalIc = System::StringComparison.OrdinalIgnoreCase;
    var comp_funcs = [];
    
    //Build graph
    var graph = {};
    foreach(var func in app.Functions)
        graph[func.Id.ToUpperInvariant] = [];
    
    var parentFunctionKey = Prexonite::PFunction.ParentFunctionKey;
    foreach(var func in app.Functions)
        if(func.Meta.ContainsKey(parentFunctionKey) and graph.ContainsKey((var parentId = func.Meta[parentFunctionKey].Text.ToUpperInvariant)))
            graph[parentId][] = func;
            
    //Recursively mark all compiler functions and their inner functions
    function mark_comp_func(func)
    {
        var fid = func.Id.ToUpperInvariant;    
        comp_funcs[] = func;
                
        foreach(var inner in graph[fid] ?? [])
            mark_comp_func(inner);
    }
    
    //Mark and collect    
    foreach(var func in app.Functions)
        if(func.Meta["compiler"].Switch)
        {
            comp_funcs[] = func;
            mark_comp_func(func);
        }
            
    //Remove symbols
    var revSet = {};
    var revRefSet = {};
    foreach(var comp_func in comp_funcs)
        revSet.Add(comp_func.Id: SI.func);
    foreach(var comp_var in comp_vars)
    {
        revSet.Add(comp_var.Key:  SI.gvar);
        revRefSet.Add(comp_var.Key: SI.gref);
    }   
    function get_symbols(reverseSet) =
        GetLoader.Symbols >> where(kvp => SI.eq(reverseSet[kvp.Value.Id],kvp.Value.Interpretation)) >> map(?.Key);
    var comp_syms = append(get_symbols(revSet), get_symbols(revRefSet)) >> all;
    var ldrSyms = GetLoader.Symbols;
    foreach(var comp_sym in comp_syms)
        ldrSyms.Remove(comp_sym);
    ldrSyms.Remove("unload_compiler");
    
    //Remove physical functions and variables
    foreach(var comp_func in comp_funcs)
        app.Functions.Remove(comp_func);
    foreach(var comp_var in comp_vars)
        app.Variables.Remove(comp_var.Key);
        
    app.Functions.Remove(->unload_compiler);
    app.Functions.Remove(->mark_comp_func.Function.Id);
    app.Functions.Remove(->get_symbols.Function.Id);
    app.Meta["compiler_loaded"] = false;
    }
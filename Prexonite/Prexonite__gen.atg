//-- GENERATED BY PxCoco -merge --//
//-- make sure to modify the source files instead of this one! --//

#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Header.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

//A comment
using System.IO;
using Prexonite;
using System.Collections.Generic;
using System.Linq;
using FatalError = Prexonite.Compiler.FatalCompilerException;
using StringBuilder = System.Text.StringBuilder;
using Prexonite.Compiler.Ast;
using Prexonite.Types;

COMPILER Prexonite

/*-- Global scope --*/



#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Scanner.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/*---- SCANNER ------*/
/* Interface version */

IGNORECASE
	
TOKENS
		//Basic token
		id
		anyId
		lid
        ns
		
  /*--------------------------------------------------------------------------------*/
        integer
  /*--------------------------------------------------------------------------------*/
        real
  /*--------------------------------------------------------------------------------*/
        string
        
  /*--------------------------------------------------------------------------------*/
    bitAnd // &
	assign // =
	comma  // ,
	dec    // --
	div    // /
	dot    // .
	eq     // ==
	gt     // >
	ge     // >=
	inc    // ++
	lbrace // {
	lbrack // [
	lpar   // (
	lt     // <
	le     // <=
	minus  // -
	ne     // !=
	bitOr  // |
	plus   // +
	pow    // ^
	rbrace // }
    rbrack // ]
    rpar   // )
    tilde  // ~
    times  // *
    semicolon // ;
	colon  // :
	doublecolon // ::
	coalescence	//??
	question // ?
	pointer// ->
	implementation // =>
	at     // @
	appendleft // <<
	appendright // >>
	

    //Handled by the scanner:
    var
    ref
    true
	false

    //Handled by keyword check
    BEGINKEYWORDS
    mod
	is
	as
	not
	enabled
	disabled
	function
	command	
	asm	
	declare
	build
	return
	in
	to
	add
	continue
	break
	yield
	or
	and
	xor
	label
	goto
	static	
	null	
	if
	unless
	else
	new
	coroutine
	from
	do
	does
	while
	until
	for
	foreach
	try
	catch
	finally
	throw
    then
	uusing //Coco/R does not accept "using" as a token name.
	macro
	lazy
	let
	ENDKEYWORDS
	
    //SPECIAL
    LPopExpr //has no textual representation.

IGNORE '\r' + '\n' + '\t'

/*------------------------------*/
/*---- Parser ------------------*/
PRODUCTIONS
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Parser.Assembler.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

/* ---- Assembler Language ---- */

AsmStatementBlock<AstBlock block>
=
	lbrace
	{
	    AsmInstruction<block>        
	}
	rbrace
|   AsmInstruction<block> semicolon     
.

AsmInstruction<AstBlock block>          (.  int arguments = 0;
                                            string id = null;
                                            double dblArg = 0.0;
                                            string insbase = null; string detail = null;
                                            bool bolArg = false;
                                            OpCode code;
                                            bool justEffect = false;
                                            int values = 0;
                                            int rotations = 0;
                                            int index = 0;
                                        .)
=
    //VARIABLE DECLARATION              
                                        (. SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
    ( var | ref                         (. kind = SymbolInterpretations.LocalReferenceVariable; .)
    )
    AsmId<out id>
                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            target.Symbols.Add(id, new SymbolEntry(kind, id));
                                        .)
    {   comma
        AsmId<out id>                                        
                                        (.  //Store variable
                                            target.Function.Variables.Add(id);
                                            target.Symbols.Add(id, new SymbolEntry(kind, id));
                                        .)
    }
|   //OP ALIAS INSTRUCTIONS
    IF(isInOpAliasGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  addOpAlias(block, insbase, detail); .)
|   //NULL INSTRUCTIONS
    IF(isInNullGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code));
                                        .)
                                        
|   //LABEL
    IF( isAsmInstruction("label",null) )
    AsmId<out insbase>
    
    //Enter label
    AsmId<out id>
                                        (. addLabel(block, id); .)
|   //NOP/DATA INSTRUCTION
    IF(isAsmInstruction("nop", null))
    AsmId<out insbase>                  (.  Instruction ins = new Instruction(OpCode.nop); .)
    [  plus AsmId<out id>               (.  ins.Id = id; .)
    ]
                                        (.  addInstruction(block, ins); .)
    
|   //ROTATE INSTRUCTION
    IF(isAsmInstruction("rot", null))
    AsmId<out insbase>
    dot Integer<out rotations>
    comma Integer<out values>    
                                        //Create rot instruction
                                        (.  addInstruction(block, Instruction.CreateRotate(rotations, values)); .)
   
|	//INDIRECT LOCAL CALL BY INDEX
	IF(isAsmInstruction("indloci", null))
	[ at                                (.  justEffect = true; .)
	]
	AsmId<out insbase>
	dot Integer<out arguments>
	Integer<out index>
										//Create indloci instruction
										(.	addInstruction(block, Instruction.CreateIndLocI(index, arguments, justEffect)); .)    
|   //EXCHANGE INSTRUCTION
    IF(isAsmInstruction("swap", null))
    AsmId<out insbase>
                                        (.  addInstruction(block, Instruction.CreateExchange()); .)
   
    
|   //LOAD CONSTANT . REAL
    IF(isAsmInstruction("ldc", "real"))
    AsmId<out insbase>
    dot
    AsmId<out detail>    
    SignedReal<out dblArg>                    
                                        (.  addInstruction(block, Instruction.CreateConstant(dblArg)); .)
    

|   //LOAD CONSTANT . BOOL    
    IF(isAsmInstruction("ldc", "bool"))
    AsmId<out insbase>
    dot
    AsmId<out detail>
    Boolean<out bolArg>     
                                        (.  addInstruction(block, Instruction.CreateConstant(bolArg)); .)
    
    
|   //INTEGER INSTRUCTIONS
    IF(isInIntegerGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    SignedInteger<out arguments>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments));
                                        .)
                                        
|   //JUMP INSTRUCTIONS
    IF(isInJumpGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
                                        (.  Instruction ins = null;
                                            code = getOpCode(insbase, detail);
                                        .)
    //Symbolic:
    (   AsmId<out id>
                                        (.  
                                            ins = new Instruction(code, -1, id);
                                        .)
    |   Integer<out arguments>          (.  ins = new Instruction(code, arguments); .)
    )                                   (.  addInstruction(block, ins); .)
    

|   //ID INSTRUCTIONS
    IF(isInIdGroup())
    AsmId<out insbase>
    [ dot AsmId<out detail> ]
    AsmId<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, id));
                                        .)
    

|   //ID+ARG INSTRUCTIONS
    IF(isInIdArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmId<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)
 
 |   //ARG INSTRUCTIONS
    IF(isInArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, null, justEffect));
                                        .)   

|   //QUALID+ARG INSTRUCTIONS
    IF(isInQualidArgGroup())
    [ at                                (.  justEffect = true; .)
    ]
    AsmId<out insbase>
    (   dot Integer<out arguments>
    |                                   (.  arguments = 0; .)
    )
    AsmQualid<out id>
                                        (.  code = getOpCode(insbase, detail);
                                            addInstruction(block, new Instruction(code, arguments, id, justEffect));
                                        .)

|   //ERROR PRODUCTION: INVALID INSTRUCTION
    AsmId<out insbase>                  (.  SemErr("Invalid assembler instruction \"" + insbase + "\" (" + t + ")."); .)
        
.

AsmId<out string id>        (.  id = "\\NoId\\"; .)
=
    String<out id>
|   Id<out id>
|   (   mod
    |   is
    |   not
    //  enabled
    //  disabled
    //  build
    |   return
    |   in
    |   to
    //  add
    |   continue
    |   break
    |   or
    |   and
    |   xor
    |   goto
    |   null
    |   else
    |   if
    |   unless
    |   new
    |   while
    |   until
    |   for
    |   foreach
    |   command
    |   as
    |	try
    |	throw
    )                       (.  id = cache(t.val); .)
.

AsmQualid<out string qualid>
                            (.   .)
=
    AsmId<out qualid>
.
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Parser.Expression.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */


Expr<out IAstExpression expr>		    (.	AstConditionalExpression cexpr = null; expr = null; .)
=	
	AtomicExpr<out expr>   
|										(.	bool isNegated = false; .)
	(	if
	|	unless							(.	isNegated = true; .)
	)
	lpar Expr<out expr> rpar			(.	cexpr = new AstConditionalExpression(this, expr, isNegated); .)
	Expr<out cexpr.IfExpression>
    else
    Expr<out cexpr.ElseExpression>      (.  expr = cexpr; .)
.


AtomicExpr<out IAstExpression expr>
                                        (.  IAstExpression outerExpr = null; .)
=
    AppendRightExpr<out expr>
    {
        then
        AppendRightExpr<out outerExpr>  (.  AstGetSetSymbol thenExpr = new AstGetSetSymbol(this, PCall.Get, Engine.ThenAlias, SymbolInterpretations.Command);
                                            thenExpr.Arguments.Add(expr);
                                            thenExpr.Arguments.Add(outerExpr);
                                            expr = thenExpr;
                                        .)
    }
.


AppendRightExpr<out IAstExpression expr>
										(.	AstGetSet complex = null; .)
=
	KeyValuePairExpr<out expr>
	{	
		appendright
		GetCall<out complex>		    (.	complex.Arguments.RightAppend(expr); 
										    complex.Arguments.ReleaseRightAppend();
										    if(complex is AstGetSetSymbol && ((AstGetSetSymbol)complex).IsVariable)
										        complex.Call = PCall.Set;
										    expr = complex;										    
									    .)
	}
.

KeyValuePairExpr<out IAstExpression expr>
=
	OrExpr<out expr>
	[	colon							(.	IAstExpression value; .)
		KeyValuePairExpr<out value>		(.	expr = new AstKeyValuePair(this, expr, value); .)
	]
.

OrExpr<out IAstExpression expr>
										(. IAstExpression lhs, rhs; .)
=
	AndExpr<out lhs>                    (.  expr = lhs; .)
    [   or OrExpr<out rhs>              (.  expr = new AstLogicalOr(this, lhs, rhs); .)
    ]

.

AndExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitOrExpr<out lhs>                  (.  expr = lhs; .)
    [   and AndExpr<out rhs>            (.  expr = new AstLogicalAnd(this, lhs, rhs); .)
    ]
.

BitOrExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; .)
=
    BitXorExpr<out lhs>                 (. expr = lhs; .)
    { bitOr BitXorExpr<out rhs>         (. expr = AstBinaryOperator.Create(this, expr, BinaryOperator.BitwiseOr, rhs); .)
    }
.

BitXorExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    BitAndExpr<out lhs>                 (.  expr = lhs; .)
    {   xor BitAndExpr<out rhs>
                                        (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.ExclusiveOr, rhs); .)
    }
.

BitAndExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    NotExpr<out lhs>                    (.  expr = lhs; .)
    {   bitAnd NotExpr<out rhs>
                                        (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.BitwiseAnd, rhs); .)
    }
.

NotExpr<out IAstExpression expr>
                                        (. IAstExpression lhs; bool isNot = false; .)
=
    [   not                             (.  isNot = true; .)
    ]
    EqlExpr<out lhs>                    (.  expr = isNot ? AstUnaryOperator.Create(this, UnaryOperator.LogicalNot, lhs) : lhs; .)
.

EqlExpr<out IAstExpression expr>
                                        (. IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    RelExpr<out lhs>                    (. expr = lhs; .)
    {   (   eq                          (.  op = BinaryOperator.Equality; .)
        |   ne                          (.  op = BinaryOperator.Inequality; .)    
        ) RelExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

RelExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None;  .)
=
    CoalExpr<out lhs>                   (.  expr = lhs; .)
    {   (   lt                          (.  op = BinaryOperator.LessThan;              .)
        |   le                          (.  op = BinaryOperator.LessThanOrEqual;       .)
        |   gt                          (.  op = BinaryOperator.GreaterThan;           .)
        |   ge                          (.  op = BinaryOperator.GreaterThanOrEqual;    .)
        ) CoalExpr<out rhs>             (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

CoalExpr<out IAstExpression expr>
										(.	IAstExpression lhs, rhs; AstCoalescence coal = new AstCoalescence(this); .)
=
	AddExpr<out lhs>					(.	expr = lhs; coal.Expressions.Add(lhs); .)
	{
		coalescence
		AddExpr<out rhs>				(.	expr = coal; coal.Expressions.Add(rhs); .)
	}
.										

AddExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs,rhs; BinaryOperator op = BinaryOperator.None; .)
=
    MulExpr<out lhs>                    (.  expr = lhs; .)
    {   (   plus                        (.  op = BinaryOperator.Addition;      .)
        |   minus                       (.  op = BinaryOperator.Subtraction;   .) 
        ) MulExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

MulExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; BinaryOperator op = BinaryOperator.None; .)
=
    PowExpr<out lhs>                    (.  expr = lhs; .)
    {   (   times                       (.  op = BinaryOperator.Multiply;      .)
        |   div                         (.  op = BinaryOperator.Division;        .)
        |   mod                         (.  op = BinaryOperator.Modulus;       .)
        ) PowExpr<out rhs>              (.  expr = AstBinaryOperator.Create(this, expr, op, rhs); .)
    }
.

PowExpr<out IAstExpression expr>
                                        (.  IAstExpression lhs, rhs; .)
=
    AssignExpr<out lhs>                  (.  expr = lhs; .)
    {   pow AssignExpr<out rhs>          (.  expr = AstBinaryOperator.Create(this, expr, BinaryOperator.Power, rhs); .)
    }
.

AssignExpr<out IAstExpression expr>     (.  AstGetSet assignment; BinaryOperator setModifier = BinaryOperator.None;
                                            IAstType T;
                                        .)
=
    PostfixUnaryExpr<out expr>
    (IF(isAssignmentOperator())
                                       (.  assignment = expr as AstGetSet;
                                            if(assignment == null) 
                                            {
                                                SemErr(string.Format("Cannot assign to a {0}",
                                                    expr.GetType().Name));
                                                assignment = new AstGetSetSymbol(this, PCall.Get, "SEMANTIC_ERROR",
                                                    SymbolInterpretations.LocalObjectVariable); //to prevent null references
                                            }
                                            assignment.Call = PCall.Set;
                                        .)
        (
            (   assign                  (.  setModifier = BinaryOperator.None; .)
	        |   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	        |   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	        |   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	        |   div assign              (.  setModifier = BinaryOperator.Division; .)
	        |   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	        |   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	        |	coalescence assign		(.	setModifier = BinaryOperator.Coalescence; .)
	        )   Expr<out expr>        //(.  expr = expr; .)
	        
	    |   (   tilde  assign           (.  setModifier = BinaryOperator.Cast; .)
	        )TypeExpr<out T>            (.  expr = T; .)
	    )                               
	                                    (.  assignment.Arguments.Add(expr); 
	                                        if(setModifier == BinaryOperator.None)
	                                            expr = assignment;
	                                        else
	                                            expr = AstModifyingAssignment.Create(this,setModifier, assignment);
                                        .)        
    |)
.

PostfixUnaryExpr<out IAstExpression expr>
                                        (.  IAstType type = null; AstGetSet extension; bool isInverted = false; .)
=
    PrefixUnaryExpr<out expr>   
    {   tilde TypeExpr<out type>        (.  expr = new AstTypecast(this, expr, type); .)
    |   is	[ not						(.	isInverted = true; .) ]
    		 TypeExpr<out type>         (.  expr = new AstTypecheck(this, expr, type);
    										if(isInverted)
                                            {
                                                ((AstTypecheck)expr).IsInverted = true;
    											expr = AstUnaryOperator.Create(this, UnaryOperator.LogicalNot, expr);
                                            }
    									.)
    |   inc                             (.  expr = AstUnaryOperator.Create(this, UnaryOperator.PostIncrement, expr); .)
    |   dec                             (.  expr = AstUnaryOperator.Create(this, UnaryOperator.PostDecrement, expr); .)
    |   GetSetExtension<expr, out extension>
                                        (.  expr = extension; .)
    }
.

PrefixUnaryExpr<out IAstExpression expr>
                                        (.  var prefixes = new Stack<UnaryOperator>(); .)
=
    {   plus
    |   minus                           (.  prefixes.Push(UnaryOperator.UnaryNegation); .)
    |   inc                             (.  prefixes.Push(UnaryOperator.PreIncrement); .)
    |   dec                             (.  prefixes.Push(UnaryOperator.PreDecrement); .)
    }    
    Primary<out expr>                   
                                        (.  while(prefixes.Count > 0)
                                                expr = AstUnaryOperator.Create(this, prefixes.Pop(), expr);
                                        .)
.

Primary<out IAstExpression expr>
                                        (.  expr = null;
                                            AstGetSet complex = null; bool declared; .)
=
	(.  _pushLexerState(Lexer.Asm); .)	(.	AstBlockExpression blockExpr = new AstBlockExpression(this); .)
    asm lpar { AsmInstruction<blockExpr> } rpar
    (.  _popLexerState(); .)			(.	expr = blockExpr; .)
|   Constant<out expr>
|   CoroutineCreation<out expr>
|   ListLiteral<out expr>
|	HashLiteral<out expr>
|	LoopExpr<out expr>
|	(. AstThrow th; .)
	ThrowExpression<out th>				(. expr = th; .)
|   IF(isLambdaExpression())
    LambdaExpression<out expr>
|   LazyExpression<out expr>
|   lpar Expr<out expr> rpar
|   IF(_isNotNewDecl()) ObjectCreation<out expr>
|   GetInitiator<out complex, out declared>
                                        (.  expr = complex; .)
|   LPopExpr lpar Expr<out expr>        (.  //This is a hack that makes string interpolation with expressions possible
                                            //The non-verbal token "LPopExpr" (has no character representation) is 
                                            //returned by the lexer if the parser has to treat an expression in a special
                                            //way. This includes notifying the lexer when the expression has been parsed, as
                                            //well as injecting the necessary plus operator.
                                            _popLexerState(); _inject(_plus); .)
    rpar
.

Constant<out IAstExpression expr>
                                        (.  expr = null; int vi; double vr; bool vb; string vs; .)
=
        Integer<out vi>                 (.  expr = new AstConstant(this, vi); .)
    |   Real<out vr>                    (.  expr = new AstConstant(this, vr); .)
    |   Boolean<out vb>                 (.  expr = new AstConstant(this, vb); .)
    |   String<out vs>                  (.  expr = new AstConstant(this, vs); .)
    |   Null							(.  expr = new AstConstant(this, null); .)
.

ListLiteral<out IAstExpression expr>
                                        (.  IAstExpression iexpr = null; 
                                            AstListLiteral lst = new AstListLiteral(this);
                                            expr = lst;
                                        .)
=
    lbrack
    [   Expr<out iexpr>                 (.  lst.Elements.Add(iexpr); .)
        {   comma
            Expr<out iexpr>             (.  lst.Elements.Add(iexpr); .)
        }
    ]
    rbrack
.

HashLiteral<out IAstExpression expr>
										(.	IAstExpression iexpr = null; 
											AstHashLiteral hash = new AstHashLiteral(this);
											expr = hash;
										.)
=
	lbrace
	[	Expr<out iexpr>					(.	hash.Elements.Add(iexpr); .)
		{	comma
			Expr<out iexpr>				(.	hash.Elements.Add(iexpr); .)
		}
	]
	rbrace
.

LoopExpr<out IAstExpression expr>
										(.	AstBlock dummyBlock = new AstBlock(this);
										.)
=
	(	WhileLoop<dummyBlock>
	|	ForLoop<dummyBlock>
	|	ForeachLoop<dummyBlock>
	)									(.	expr = new AstLoopExpression(this, (AstLoop) dummyBlock.Statements[0]); .)
.										
											

ObjectCreation<out IAstExpression expr>
                                        (.  IAstType type; expr = null;
                                            ArgumentsProxy args; .)
=
    new TypeExpr<out type>              (.  _fallbackObjectCreation(this, type, out expr, out args); .)
    Arguments<args>
.

CoroutineCreation<out IAstExpression expr>
                                        (.  
                                            AstCreateCoroutine cor = new AstCreateCoroutine(this); 
                                            IAstExpression iexpr;
                                            expr = cor;
                                        .)
=
    coroutine Expr<out iexpr>           (.  cor.Expression = iexpr; .)
    [ for Arguments<cor.Arguments> ]
.

LambdaExpression<out IAstExpression expr>
                                        (.  expr = null;
                                            PFunction func = new PFunction(TargetApplication, generateLocalId());                                             
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            TargetApplication.Functions.Add(func);
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            CompilerTarget ft = FunctionTargets[func];
                                            ft.ParentTarget = target;
                                        .)
=
(   FormalArg<ft>
|   lpar
    [	FormalArg<ft> 
	    {	comma
		    FormalArg<ft>
	    }
    ]
    rpar
)
                                        (.
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
implementation                                        
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)
                                        (.
                                            target = oldTarget;
                                            if(errors.count == 0)
                                            {
                                                try {
                                                    //Emit code for top-level block
                                                    Ast[func].EmitCode(FunctionTargets[func],true);
                                                    FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lambda expression.\n" + e.ToString());
                                                }
                                            }
                                            
                                            expr = new AstCreateClosure(this, func.Id);                                         
                                        .)
.

LazyExpression<out IAstExpression expr>
                                        (.  expr = null;
                                            PFunction func = new PFunction(TargetApplication, generateLocalId());
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                            func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                            TargetApplication.Functions.Add(func);
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            CompilerTarget ft = FunctionTargets[func];
                                            ft.ParentTarget = target;
                                            
                                            //Switch to nested target
                                            CompilerTarget oldTarget = target;
                                            target = ft;
                                        .)
=
lazy
(   lbrace
    { Statement<ft.Ast> }
    rbrace
|                                       (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
    Expr<out ret.Expression>            (.  ft.Ast.Add(ret); .)
)                                       
                                        (.
                                            //Turn into capture by value
                                            var cap = ft.ToCaptureByValue(let_bindings(ft));
                                            
                                            //Restore parent target
                                            target = oldTarget;
                                            
                                            //Finish nested function
                                            if(errors.count == 0)
                                            {
                                                try {
                                                Ast[func].EmitCode(FunctionTargets[func],true);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy expression.\n" + e.ToString());
                                                }
                                            }
                                            
                                            //Construct expr (appears in the place of lazy expression)
                                            var clo = new AstCreateClosure(this, func.Id);
                                            var thunk = new AstGetSetSymbol(this, Engine.ThunkAlias, SymbolInterpretations.Command);
                                            thunk.Arguments.Add(clo);
                                            thunk.Arguments.AddRange(cap(this)); //Add captured values
                                            expr = thunk;
                                        .)
.

ThrowExpression<out AstThrow th>		(.  th = new AstThrow(this); .)
=
    throw
    Expr<out th.Expression>
.

ExplicitTypeExpr<out IAstType type>     (.  type = null; .)
=
    tilde PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

TypeExpr<out IAstType type>             (.  type = null; .)
=
    PrexoniteTypeExpr<out type>
|   ClrTypeExpr<out type>
.

ClrTypeExpr<out IAstType type>          
                                        (.  string id; .)
=
                                        (.  StringBuilder typeId = new StringBuilder(); .)
    (   doublecolon
    |   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    )
    {   Ns<out id>                      (.  typeId.Append(id); typeId.Append('.'); .)
    }
    Id<out id>                          (.  typeId.Append(id);
                                            type = new AstConstantTypeExpression(this, 
                                                "Object(\"" + StringPType.Escape(typeId.ToString()) + "\")");
                                        .)
.

PrexoniteTypeExpr<out IAstType type>
                                        (.  string id = null; type = null; .)
=
    ( Id<out id> | null                 (.  id = NullPType.Literal; .)                          
    )
                                        (.  AstDynamicTypeExpression dType = new AstDynamicTypeExpression(this, id); .)
    [   lt
        [   TypeExprElement<dType.Arguments>   
            { comma TypeExprElement<dType.Arguments> }
        ]
        gt
    ]
                                        (.  type = dType; .)
.

TypeExprElement<. List<IAstExpression> args .>
                                        (.  IAstExpression expr; IAstType type; .)
=
    Constant<out expr>                  (.  args.Add(expr); .)
|   ExplicitTypeExpr<out type>          (.  args.Add(type); .)
|   lpar Expr<out expr> rpar            (.  args.Add(expr); .)
.
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Parser.GlobalScope.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Prexonite	
                            (.  PFunction func; .)				
=
    {	[   GlobalVariableDefinition
        |   Declaration
        |   MetaAssignment<TargetApplication>
        ]   SYNC semicolon
    |	GlobalCode
    |   BuildBlock
    |	FunctionDefinition<out func>
    }
    EOF
.

/*---- Meta information ----*/

MetaAssignment<IHasMetaTable target>	(. string key = null; MetaEntry entry = null; .)
=
(	is  					(. entry = true; .)
	[not					(. entry = false; .)
	]
	GlobalId<out key>
|
	GlobalId<out key>
	( enabled				(. entry = true; .)
	| disabled  			(. entry = false; .)
	| MetaExpr<out entry>
	)
|   add                     (. MetaEntry subEntry; .)
    MetaExpr<out subEntry>  (. if(!subEntry.IsList) subEntry = (MetaEntry) subEntry.List; .)
    to
    GlobalId<out key>       (.  if(target.Meta.ContainsKey(key))
                                {
                                    entry = target.Meta[key];
                                    entry = entry.AddToList(subEntry.List);
                                }
                                else
                                {
                                   entry = subEntry;
                                }
                            .)
)							(. if(entry == null || key == null) 
                                    SemErr("Meta assignment did not generate an entry.");
                               else 
                                    target.Meta[key] = entry; 
                            .)	
.

MetaExpr<out MetaEntry entry>
							(. bool sw; int i; double r; entry = null; string str; .)
=							
	Boolean<out sw>			(. entry = sw; .)
|	Integer<out i>			(. entry = i.ToString(); .)
|	Real<out r>				(. entry = r.ToString(); .)
|   String<out str>         (. entry = str; .)
|   GlobalQualifiedId<out str>       (. entry = str; .)
|   lbrace                  (. List<MetaEntry> lst = new List<MetaEntry>(); MetaEntry subEntry; .)
    [   MetaExpr<out subEntry> (.  lst.Add(subEntry); .)
        {   WEAK comma
            MetaExpr<out subEntry> (. lst.Add(subEntry); .)
        }
    ]
    rbrace                  (. entry = (MetaEntry) lst.ToArray(); .)
.

/* ---- Global variable definition --- */

GlobalVariableDefinition	(.  
                                string id = null; 
                                List<string> aliases = new List<string>();
                                PVariable vari; 
                                SymbolInterpretations type = SymbolInterpretations.GlobalObjectVariable; 
                            .)
=

	(   var                 
	|   ref                 (.  type = SymbolInterpretations.GlobalReferenceVariable; .)
	)
	
	(   GlobalId<out id>    (.  aliases.Add(id); .)
	    [ GlobalVariableAliasList<aliases> ]
	|   GlobalVariableAliasList<aliases>
	                        (.  id = Engine.GenerateName("v"); .)
	)
	                        (.
	                            foreach(var alias in aliases)
	                                Symbols[alias] = new SymbolEntry(type, id);
	                            if(TargetApplication.Variables.ContainsKey(id))
	                                vari = TargetApplication.Variables[id];
	                            else
	                            {
	                                vari = new PVariable(id);
	                                TargetApplication.Variables[id] = vari;
	                            }
	                        .)
	[	lbrack  		    //Meta block for variables
		{	MetaAssignment<vari> SYNC semicolon
		}
		rbrack
	]
	[	                    (.  _pushLexerState(Lexer.Local); .)
	    assign              (.  CompilerTarget lastTarget = target;
                                target=FunctionTargets[Application.InitializationId];
                                IAstExpression expr;
                            .)
		Expr<out expr>
		                    (.  _popLexerState();
								if(errors.count == 0)
								{
									AstGetSet complex = new AstGetSetSymbol(this, PCall.Set, id, InterpretAsObjectVariable(type));
									complex.Arguments.Add(expr);
									target.Ast.Add(complex);
									vari.Meta[Application.InitializationId] = TargetApplication._RegisterInitializationUpdate().ToString();
									Loader._EmitPartialInitializationCode();
		                        }
		                        target = lastTarget;
		                    .)
	]
.

GlobalVariableAliasList<. IList<string> aliases .>
                            (.  string id = "\\NoId_In_GlobalVariableAliasList_\\"; .)
=
    as GlobalId<out id>     (.  aliases.Add(id); .)
    {   comma
        GlobalId<out id>    (.  aliases.Add(id); .)
    }
.

/* ---- Global declaration ---- */

Declaration
                            (. SymbolInterpretations type = SymbolInterpretations.Undefined; .)
=
SYNC
	declare
	[	var 		        (. type = SymbolInterpretations.GlobalObjectVariable; .)
	|   ref                 (. type = SymbolInterpretations.GlobalReferenceVariable; .)
	|	function			(. type = SymbolInterpretations.Function; .)
	|   command             (. type = SymbolInterpretations.Command; .)
	]
	DeclarationInstance<type>
	{WEAK comma DeclarationInstance<type>}
.
	
DeclarationInstance<SymbolInterpretations type>
                            (.  string id; string aId; .)
=			
	Id<out id>              (.  aId = id; .)
	[ as Id<out aId> ]
	                        (.  SymbolEntry inferredType;
	                            if(target == null) //global symbol
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                            else
	                            {
	                                if(type == SymbolInterpretations.Undefined)
	                                    if(target.Symbols.TryGetValue(id, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else if(target.Symbols.TryGetValue(aId, out inferredType))
	                                        type = inferredType.Interpretation;
	                                    else
	                                        SemErr("Interpretation of symbol " + id + " as " + aId + " cannot be inferred.");
	                                target.Symbols[aId] = new SymbolEntry(type, id);
	                            }
	                        .)
.

/* ---- Build Block ---- */

BuildBlock
=
	SYNC build                  (.  PFunction func = new PFunction(TargetApplication);
                                    CompilerTarget lastTarget = target; 
                                    target = Loader.CreateFunctionTarget(func, new AstBlock(this));
                                    Loader.DeclareBuildBlockCommands(target);
                                    _pushLexerState(Lexer.Local);                                
                                .)
	
	[ does ]	
	StatementBlock<target.Ast>
	
                                (.  
	                                _popLexerState();
                                    if(errors.count > 0)
                                    {
                                        SemErr("Cannot execute build block. Errors detected");
                                        return;
                                    }
                                    
                                    //Emit code for top-level build block
                                    try {
                                        target.Ast.EmitCode(target, true);
                                    
                                        target.Function.Meta["File"] = scanner.File;
                                        target.FinishTarget();	                                
                                        target = lastTarget;
                                        //Run the build block 
                                        FunctionContext fctx = func.CreateFunctionContext(ParentEngine, new PValue[] {}, new PVariable[] {}, true);
                                    
                                        try
                                        {
                                            TargetApplication._SuppressInitialization = true;
                                            Loader.BuildCommandsEnabled = true;
                                            ParentEngine.Process(fctx);
                                        }
                                        finally
                                        {
                                            Loader.BuildCommandsEnabled = false;
                                            TargetApplication._SuppressInitialization = false;
                                        }
                                    } catch(Exception e) {
                                        SemErr("Exception during compilation and execution of build block.\n" + e.ToString());
                                    }
	                            .)
.

/* ---- Global Code ---- */

GlobalCode							(.
										PFunction func = TargetApplication._InitializationFunction;
										CompilerTarget ft = FunctionTargets[func];
										if(ft == null)
										    throw new PrexoniteException("Internal compilation error: InitializeFunction got lost.");
									.)
=
									(.	
										target = ft; 
                                        _pushLexerState(Lexer.Local);
                                    .)
	lbrace 
	{ Statement<target.Ast> } 
	rbrace
									(.
                                        try {
										    if(errors.count == 0)
										    {
											    TargetApplication._RequireInitialization();
											    Loader._EmitPartialInitializationCode();
										    }
                                        } catch(Exception e) {
                                            SemErr("Exception during compilation of initialization code.\n" + e.ToString());
                                        } finally {
										    //Symbols defined in this block are not available to further global code blocks
										    target.Symbols.Clear();
										    target = null;
										    _popLexerState();
                                        }
									.)
.

/* ---- Function definition ---- */

FunctionAliasList<. IList<string> aliases .> 
                                    (.  String id; .)
=
    as Id<out id>                   (.  aliases.Add(id); .)
    [   comma Id<out id>            (.  aliases.Add(id); .)
    ]
.

FunctionDefinition<out PFunction func>
                                    (.  
                                        func = null; 
                                        List<string> funcAliases = new List<string>();
                                        string id = null; //The logical id (given in the source code)
                                        string funcId; //The "physical" function id
                                        bool isNested = target != null; 
                                        bool isCoroutine = false;
                                        bool isMacro = false;
                                        bool isLazy = false;
                                        PFunction derBody = null; //The derived (coroutine/lazy) body function (carries a different name)
                                        PFunction derStub = null; //The derived (coroutine/lazy) stub function (carries the name(s) specified)
                                        string derId = null; //The name of the derived stub
                                        CompilerTarget ct = null;   //The compiler target for the function (as mentioned in the source code)
                                        CompilerTarget cst = null;  //The compiler target for a stub (coroutine/lazy)
                                    .)         
=	
	(   lazy [function]             (.  isLazy = true; .)
	|   function
	|   coroutine                   (.  isCoroutine = true; .)
	|   macro [function]            (.  isMacro = true; .)
	)
	(   Id<out id>                  (.  funcAliases.Add(id); .)
	    [ FunctionAliasList<funcAliases> ]
	|   FunctionAliasList<funcAliases>
	)                               (.  
	                                    funcId = id ?? Engine.GenerateName("f");
                                        if(Engine.StringsAreEqual(id, @"\init")) //Treat "\init" specially (that's the initialization code)
                                        {
                                            func = TargetApplication._InitializationFunction;
                                            if(isNested)
                                                SemErr("Cannot define initialization code inside another function.");
                                            if(isCoroutine)
                                                SemErr("Cannot define initialization code as a coroutine.");
                                            if(isLazy)
                                                SemErr("Cannot define initialization code as a lazy function.");
                                            if(isMacro)
                                                SemErr("Cannot define initialization code as a macro function.");
                                        }
                                        else
                                        {
                                            var localId = id;
                                            
                                            if(isNested)
                                            {
                                                if(isMacro)
                                                    SemErr("Inner macros are illegal. Macros must be top-level.");
                                                    
                                                funcId = generateLocalId(id ?? "inner");
                                                
                                                if(string.IsNullOrEmpty(localId))
                                                {
                                                    //Create shadow name
                                                    localId = generateLocalId(id ?? "inner");
                                                }
                                                SmartDeclareLocal(localId, SymbolInterpretations.LocalReferenceVariable);
                                                foreach(var alias in funcAliases)
                                                        SmartDeclareLocal(alias, localId, SymbolInterpretations.LocalReferenceVariable, false);
                                                
                                            }
                                            
                                            func = new PFunction(TargetApplication, funcId);
                                            
                                            if(isNested)
                                            {
                                                 func.Meta[PFunction.LogicalIdKey] = localId;
                                                 if(isLazy)
                                                    mark_as_let(target.Function,localId);
                                            }
                                            
                                            Loader.CreateFunctionTarget(func, new AstBlock(this));
                                            
                                            //Add function to application
                                            if(TargetApplication.Functions.Contains(func.Id) && !TargetApplication.Meta.GetDefault(Application.AllowOverridingKey,true))
												SemErr(t,"Application " + TargetApplication.Id + " does not allow overriding of function " + func.Id + ".");
                                            TargetApplication.Functions.AddOverride(func);
                                        }
                                        CompilerTarget ft = FunctionTargets[func];
                                        
                                        //Generate derived stub
                                        if(isCoroutine || isLazy)
                                        {
                                            derStub = func;
                                            
                                            //Create derived body function
                                            derId = ft.GenerateLocalId();
                                            derBody = new PFunction(TargetApplication, derId);
                                            Loader.CreateFunctionTarget(derBody, new AstBlock(this));
                                            TargetApplication.Functions.Add(derBody);
                                            derBody.Meta[PFunction.LogicalIdKey] = id ?? funcId;
                                            if(isCoroutine)
                                            {
                                                derBody.Meta[PFunction.VolatileKey] = true;
                                                derBody.Meta[PFunction.DeficiencyKey] = "Coroutine body can only be executed by VM anyway.";
                                            }

                                            //Swap compiler target references
                                            // -> Compile source code into derived body
                                            // -> Let derived stub have the physical function id
                                            ct = FunctionTargets[derBody];
                                            cst = ft;
                                            ct.ParentTarget = cst;
                                        }
                                        
                                        if(isNested) //Link to parent in case of a nested function
                                        {
                                            ft.ParentTarget = target;	                                           
                                            if(isLazy)
                                                ft = ct;
                                        }	                                    
	                                .)
    [   lpar
	    [	FormalArg<ft> 
		    {	[comma]
			    FormalArg<ft>
		    }
	    ]
	    rpar
    |   FormalArg<ft>
        {   [comma]
            FormalArg<ft>
        }
	]	                            (.  
		                                if(isNested && isLazy)
		                                    ft = cst;
	                                    
	                                    if(target == null && 
	                                        (!object.ReferenceEquals(func, TargetApplication._InitializationFunction)) &&
	                                        (!isNested))
	                                    {
	                                            //Add the name to the symboltable
	                                            foreach(var alias in funcAliases)	                                                
	                                                Symbols[alias] = new SymbolEntry(SymbolInterpretations.Function, func.Id);
	                                            
	                                            //Store the original (logical id, mentioned in the source code)
	                                            if((!string.IsNullOrEmpty(id)))
	                                                func.Meta[PFunction.LogicalIdKey] = id ?? funcId;
	                                    }
	                                    
	                                    //Target the derived (coroutine/lazy) body instead of the stub
                                        if(isCoroutine || isLazy)
                                            func = derBody;
	                                .)
    [                               (.  _pushLexerState(Lexer.YYINITIAL); .)
        lbrack
        {   MetaAssignment<func> SYNC semicolon
        }
                                    (.  _popLexerState(); .)
        rbrack
    ]
                                    (.  
                                    
                                        //Imprint certain meta key from parent function
                                        if(isNested)
                                        {
                                            func.Meta[Application.ImportKey] = target.Function.Meta[Application.ImportKey];
                                        }

                                        //Copy stub parameters to body of lazy function
                                        if(isLazy && !isNested)
	                                    {
	                                        foreach(var kvp in ft.LocalSymbols)
	                                        {
	                                            var paramId = kvp.Key;
	                                            var s = kvp.Value;
	                                            //Lazy functions cannot have ref parameters
	                                            if(s.Interpretation != SymbolInterpretations.LocalObjectVariable)
	                                                SemErr("Lazy functions can only have value parameters (ref is not allowed)");
	                                            ct.Function.Parameters.Add(s.Id);
	                                            ct.Symbols.Add(paramId, s);
	                                        }
	                                    }
                                    
                                        CompilerTarget lastTarget = target;
                                        target = FunctionTargets[func]; 
                                        _pushLexerState(Lexer.Local);
                                        if(isMacro)
                                            target.SetupAsMacro();
                                    .)
    (   [ does ]
        StatementBlock<target.Ast>
    |   IF(isFollowedByStatementBlock())
        implementation
        StatementBlock<target.Ast>
    |   ( assign | implementation ) (.  AstReturn ret = new AstReturn(this, ReturnVariant.Exit); .)
        Expr<out ret.Expression>    (.  target.Ast.Add(ret); .)
        semicolon
    )                               (.  _popLexerState();
                                        target = lastTarget; 
                                        //Compile AST
                                        if(errors.count == 0)
                                        {
                                            if(Engine.StringsAreEqual(func.Id, @"\init"))
                                            {
                                                try {
                                                TargetApplication._RequireInitialization();
                                                Loader._EmitPartialInitializationCode();
                                                //Initialize function gets finished at the end of Loader.Load
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of initialization code." + e.Message);
                                                }
                                            }
                                            else
                                            {
                                                try {
                                                //Apply compiler hooks for all kinds of functions (lazy/coroutine/macro)
												FunctionTargets[func].ExecuteCompilerHooks();
												//Emit code for top-level block
                                                Ast[func].EmitCode(FunctionTargets[func], true);
                                                FunctionTargets[func].FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of function body of " + id + "." + e.Message);
                                                }
                                            }                                       
                                            
											if(isCoroutine)
											{
                                                try {
												    //Stub has to be returned into the physical slot mentioned in the source code
												    func = derStub;
												    //Generate code for the stub
												    AstCreateCoroutine crcor = new AstCreateCoroutine(this);                                            
												    crcor.Expression = new AstCreateClosure(this,derBody.Id);
												    AstReturn retst = new AstReturn(this, ReturnVariant.Exit);
												    retst.Expression = crcor;
												    cst.Ast.Add(retst);
												    //Emit code for top-level block
												    cst.Ast.EmitCode(cst,true);
												    cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of coroutine stub for " + id + ". " + e.Message);
                                                }
											}
											else if(isLazy)
											{
											    derStub.Meta[PFunction.LazyKey] = true;
											    derStub.Meta["strict"] = true;
											
											    //Stub has to be returned into the physical slot mentioned in the source code
											    func = derStub;
											    
											    //Generate code for the stub
											    IAstExpression retVal;										    
										        
										        if(isNested)
										        {
										            //Nested lazy functions need a stub to capture their environment by value (handled by NestedFunction)
										            
										            //Generate stub code
										            retVal = new AstCreateClosure(this, ct.Function.Id);
										            
										            //Inject asthunk-conversion code into body
										            var inject = derStub.Parameters.Select(par => 
										            {
										                var getParam =
										                    new AstGetSetSymbol(this, PCall.Get, par, SymbolInterpretations.LocalObjectVariable);
										                var asThunkCall = 
											                new AstGetSetSymbol(this, PCall.Get, Engine.AsThunkAlias, SymbolInterpretations.Command);
											            asThunkCall.Arguments.Add(getParam);
											            var setParam =
											                new AstGetSetSymbol(this, PCall.Set, par, SymbolInterpretations.LocalObjectVariable);
											            setParam.Arguments.Add(asThunkCall);
											            return (AstNode) setParam;
										            });
										            ct.Ast.InsertRange(0,inject);
										        }
										        else
										        {										            
										            //Global lazy functions don't technically need a stub. Might be removed later on
										            var call = new AstGetSetSymbol(this, ct.Function.Id, SymbolInterpretations.Function);
										            
										            //Generate code for arguments (each wrapped in a `asThunk` command call)
											        foreach(var par in derStub.Parameters)
											        {
											            var getParam = 
											                new AstGetSetSymbol(this, PCall.Get, par, SymbolInterpretations.LocalObjectVariable);
											            var asThunkCall = 
											                new AstGetSetSymbol(this, PCall.Get, Engine.AsThunkAlias, SymbolInterpretations.Command);
											            asThunkCall.Arguments.Add(getParam);
											            call.Arguments.Add(asThunkCall);
											        }
											        
											        retVal = call;
										        }								    
											    
											    
											    //Assemble return statement
											    var ret = new AstReturn(this, ReturnVariant.Exit);
											    ret.Expression = retVal;
											    
											    cst.Ast.Add(ret);
											    
                                                try {
											    //Emit code for stub
											    cst.Ast.EmitCode(cst,true);
											    cst.FinishTarget();
                                                } catch(Exception e) {
                                                    SemErr("Exception during compilation of lazy function stub for " + id + ". " + e.Message);
                                                }
											}                                        
                                        }
                                    .)
.

FormalArg<CompilerTarget ft>        (.  string id; SymbolInterpretations kind = SymbolInterpretations.LocalObjectVariable; .)
=
	[ var | ref                     (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
	]
	Id<out id>                      (.  
	                                    //Note: lazy functions need to copy the
	                                    //  parameters of the stub to the body!
	                                    ft.Function.Parameters.Add(id); 
	                                    ft.Symbols.Add(id, new SymbolEntry(kind, id));
	                                .)
.

GlobalId<out string id>             (.  id = "...no freaking id..."; .)
=
    id                              (.  id = cache(t.val); .)
|   anyId                           (.  id = cache(t.val.Substring(1)); .)
.

GlobalQualifiedId<out string id>    (. id = "\\NoId\\"; .)  
=
    GlobalId<out id>
|   Ns<out id>                      (.  StringBuilder buffer = new StringBuilder(id); buffer.Append('.'); .)
    {   Ns<out id>                 (.  buffer.Append(id); buffer.Append('.'); .)
    }
    GlobalId<out id>                (.  buffer.Append(id); .)
                                    (.  id = buffer.ToString(); .)
.
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Parser.Helper.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

Id<out string id>               (.  id = "\\NoId\\"; .) //<-- should never surface. this is for debugging purposes
=
    GlobalId<out id>
|   (   enabled
    |   disabled
    |   build
    |   add
    )                           (.  id = cache(t.val); .)
.

Ns<out string ns>               (. ns = "\\NoId\\"; .)
=
    ns                          (. ns = cache(t.val); .)
.

Boolean<out bool value>         (.  value = true; .)
=                   
	true          
|	false                       (.  value = false; .)
.

Integer<out int value>
=
	integer                     (.  if(!TryParseInteger(t.val, out value))
	                                    SemErr(t, "Cannot recognize integer " + t.val);
	                            .)
.

SignedInteger<out int value>    (. int modifier = 1; .)
=
    [   plus
    |   minus                   (. modifier = -1; .)
    ]   Integer<out value>      (. value = modifier * value; .)
.

Real<out double value>  
=
	real            
	/*
	[   e                       (.  real += "e"; .)
	    [   plus     
	    |   minus               (.  real += "-"; .)
	    ]
	    real                    (.   real += t.val; .)
	] */
	                            (.  string real = t.val;
	                                if(!TryParseReal(real, out value))
	                                    SemErr(t, "Cannot recognize real " + real);
	                            .)
.

SignedReal<out double value>    (. value = 0.0; double modifier = 1.0; int ival; .)
=
    [   plus
    |   minus                   (. modifier = -1.0; .)
    ]   ( Real<out value> 
        | Integer<out ival>     (. value = ival; .)
        )
                                (. value = modifier * value; .)
.

String<out string value>
=
    string                      (. value = cache(t.val); .)
.

Null = null .
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Parser.Statement.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

StatementBlock<AstBlock block>
=
	Statement<block>
.

Statement<AstBlock block>
=
(
		IF( isLabel() )
			ExplicitLabel<block>  
	|   [ SimpleStatement<block> ] semicolon
	|   StructureStatement<block>
)
{	and Statement<block> 
}
.

SimpleStatement<AstBlock block>
=
	ExplicitGoTo<block>
|   Declaration
|   IF ( isVariableDeclaration() ) 
        VariableDeclarationStatement<block>
|   GetSetComplex<block>
|   Return<block>
|   Throw<block>
|   LetBindingStmt<block>
.

StructureStatement<AstBlock block>
=
    (.  _pushLexerState(Lexer.Asm); .)
    asm AsmStatementBlock<block>
    (.  _popLexerState(); .)
|   Condition<block>
|   WhileLoop<block>
|   ForLoop<block>
|   ForeachLoop<block>
|   NestedFunction<block>
|   TryCatchFinally<block>
|   Using<block>
|	lbrace
	{
		Statement<block>
	}
	rbrace
.

GetSetComplex<AstBlock block>
                                        (.  AstGetSet complex = null; 
                                            AstGetSetSymbol symbol = null;
                                            bool isDeclaration = false;
                                            AstNode node = null;
                                        .)
=
//GetSet Initiator
GetInitiator<out complex, out isDeclaration>

//GetSet Extensions
    {   GetSetExtension<complex, out complex>
    }
//GetSet Terminator
(                                       (.  block.Add(complex); .)
|   inc                                 (.  block.Add(AstUnaryOperator.Create(this, UnaryOperator.PostIncrement, complex)); .)
|   dec                                 (.  block.Add(AstUnaryOperator.Create(this, UnaryOperator.PostDecrement, complex)); .)
|   Assignment<complex, out node>       (.  symbol = node as AstGetSetSymbol;
                                            if(symbol != null && InterpretationIsVariable(symbol.Interpretation) && isDeclaration)
                                                symbol.Interpretation = InterpretAsObjectVariable(symbol.Interpretation);
                                            block.Add(node);
                                        .)
|	AppendRightTermination<ref complex>
	{	AppendRightTermination<ref complex>
	}
										(.	block.Add(complex);  .)  
)
.

AppendRightTermination<ref AstGetSet complex>
		                                (.	AstGetSet actualComplex; .)
=
	appendright
	GetCall<out actualComplex>			(.	actualComplex.Arguments.RightAppend(complex);
											actualComplex.Arguments.ReleaseRightAppend();
											if(actualComplex is AstGetSetSymbol && ((AstGetSetSymbol)actualComplex).IsVariable)
										        actualComplex.Call = PCall.Set;
										    complex = actualComplex;
										.)
.

GetSetExtension<IAstExpression subject, out AstGetSet extension>
                                        (.  extension = null; string id;
											if(subject == null)
											{
												SemErr("Member access not preceded by a proper expression.");
												subject = new AstConstant(this,null);
											}
                                        .)
                                        
=
    IF( isIndirectCall() )
    dot                                 (.  extension = new AstIndirectCall(this, PCall.Get, subject); .)
    Arguments<extension.Arguments>
|   dot
    Id<out id>                          (.  extension = new AstGetSetMemberAccess(this, PCall.Get, subject, id); .)
    Arguments<extension.Arguments> 
|                                       (.  
                                            IAstExpression expr; 
                                            extension = new AstGetSetMemberAccess(this, PCall.Get, subject, ""); 
                                        .)
    lbrack [
            Expr<out expr>              (.  extension.Arguments.Add(expr); .)  
            { WEAK comma Expr<out expr>   (.  extension.Arguments.Add(expr); .)
            }
        ]                                             
    rbrack                                                                      
.

GetInitiator<out AstGetSet complex, out bool isDeclaration>
                                        (.  complex = null; 
                                            AstGetSetSymbol symbol = null;
                                            AstGetSetStatic staticCall = null;
                                            AstGetSet member = null;
                                            IAstExpression expr;
                                            List<IAstExpression> args = new List<IAstExpression>();
                                            isDeclaration = false;                                            
                                            string id;
                                            int placeholderIndex = -1;
                                        .)
=
    //Actual value
    (   IF( isLikeFunction() || isUnknownId() ) 
        Function<out complex>
    |   Variable<out complex, out isDeclaration>
    |   StaticCall<out staticCall>
    |	lpar Expr<out expr>				(.	args.Add(expr); .)
		{	comma Expr<out expr>		(.	args.Add(expr); .) //multiple expressions can only be used as arguments
		}
		rpar
		(	GetSetExtension<expr, out member>
										(.	if(args.Count > 1)
												SemErr("A member access cannot have multiple subjects. (Did you mean '>>'?)");
										.)
		|	appendright
			GetCall<out complex>		(.	complex.Arguments.RightAppend(args);
											complex.Arguments.ReleaseRightAppend();
											if(complex is AstGetSetSymbol && ((AstGetSetSymbol)complex).IsVariable)
										        complex.Call = PCall.Set;
											member = complex;
										.)
		)
    )
                                        (.  complex = 
												(AstGetSet)symbol ?? 
												(AstGetSet)staticCall ?? 
												(AstGetSet)member ??
												complex; 
										.)
    //Reference
|   IF( isDeDereference() )
    pointer pointer Id<out id>          (.  SymbolEntry s = target.Symbols[id];
                                            SymbolInterpretations kind;
                                            if(s == null)
                                            {   
                                                SemErr("The symbol " + id + " is not defined"); 
                                                s = new SymbolEntry(SymbolInterpretations.LocalObjectVariable, id);
                                                kind = s.Interpretation;
                                            }
                                            else
                                            {
                                                kind = s.Interpretation;
                                                if(s.Interpretation == SymbolInterpretations.LocalReferenceVariable)
                                                    kind = SymbolInterpretations.LocalObjectVariable;
                                                else if(s.Interpretation == SymbolInterpretations.GlobalReferenceVariable)
                                                    kind = SymbolInterpretations.GlobalObjectVariable;
                                                else
                                                    SemErr("Only reference variables can be dereferenced twice.");
                                            }
                                            complex = new AstGetSetReference(this, s.Id, kind);
                                        .)
|   pointer Id<out id>                  (.  SymbolEntry s = target.Symbols[id];
                                            if(s == null)
                                            {   
                                                SemErr("The symbol " + id + " is not defined"); 
                                                s = new SymbolEntry(SymbolInterpretations.LocalObjectVariable, id);
                                            }
                                            else if(InterpretationIsVariable(s.Interpretation))
                                            {
                                                if(isOuterVariable(s.Id))
                                                    target.RequireOuterVariable(s.Id);
                                            }
                                            complex = new AstGetSetReference(this, s.Id, s.Interpretation);
                                        .)
|   question
    [   Integer<out placeholderIndex> ] (.  complex = new AstPlaceholder(this, 0 <= placeholderIndex ? (int?)placeholderIndex : null); .)
.

VariableDeclaration<out AstGetSet variable, bool isNewDecl>
                                        (.  variable = null; 
                                            string staticId = null; 
                                            string id = null;
                                            bool isOverrideDecl = false;
                                        .)
=                                       (.  SymbolInterpretations kind = SymbolInterpretations.Undefined; .)
(   (  var                              (.  kind = SymbolInterpretations.LocalObjectVariable; .)
    |  ref                              (.  kind = SymbolInterpretations.LocalReferenceVariable; .)
    )
    [   new                             (.  isOverrideDecl = true; .)
    ]
    Id<out id>                          (.  
                                            SmartDeclareLocal(id, kind, isOverrideDecl);
                                            staticId = id; 
                                        .)
|   static                              (.  kind = SymbolInterpretations.GlobalObjectVariable; .)
    [   var
    |   ref                             (.  kind = SymbolInterpretations.GlobalReferenceVariable; .)
    ]
    Id<out id>                          (.  staticId = target.Function.Id + "\\static\\" + id;
                                            target.Declare(kind, id, staticId);
                                            if(!target.Loader.Options.TargetApplication.Variables.ContainsKey(staticId))
                                                target.Loader.Options.TargetApplication.Variables.Add(staticId, new PVariable(staticId));
                                        .)
)                                       (.  variable = InterpretationIsObjectVariable(kind) ?
												new AstGetSetSymbol(this, PCall.Get, staticId, kind)
											:
												new AstGetSetReference(this, PCall.Get, staticId, InterpretAsObjectVariable(kind)); 
                                                
                                            if(isNewDecl)
                                                variable = new AstGetSetNewDecl(this)
                                                {
                                                    Expression = variable,
                                                    Id = staticId
                                                };
                                        .)
.

Variable<out AstGetSet complex, out bool isDeclared>
                                        (.  string id; 
                                            isDeclared = false; 
                                            complex = null; 
                                            bool isNewDecl = false;
                                        .)
=
    [   new                             (.  isNewDecl = true; .)
    ]
    VariableDeclaration<out complex, isNewDecl>    (. isDeclared = true; .)
|   Id<out id>                          (.  
                                            if(target.Symbols.ContainsKey(id))
                                            {
                                                SymbolEntry varSym = target.Symbols[id];
                                                if(InterpretationIsVariable(varSym.Interpretation))
                                                {
                                                    if(isOuterVariable(id))
                                                        target.RequireOuterVariable(id);                                                    
                                                }
                                                else
                                                {
                                                    SemErr(t.line, t.col, "Variable name expected but was " + 
                                                        Enum.GetName(typeof(SymbolInterpretations),varSym.Interpretation));
                                                }
                                                complex = new AstGetSetSymbol(this, varSym.Id, varSym.Interpretation);;
                                            }
                                            else
                                            {
                                                //Unknown symbols are treated as functions. See production Function for details.
                                                SemErr(t.line, t.col, "Internal compiler error. Did not catch unknown identifier.");
                                                complex = new AstGetSetSymbol(this, "Not a Variable Id", SymbolInterpretations.LocalObjectVariable);
                                            }
                                        .)
.

VariableDeclarationStatement<AstBlock block>
=                                       (.  AstGetSet variable;
                                            bool isNewDecl = false;
                                        .)
    [ new                               (.  isNewDecl = true; .)
    ]
    VariableDeclaration<out variable, isNewDecl>
                                        (.  if(isNewDecl)
                                            {
                                                block.Add(variable);
                                            }
                                            else
                                            {
                                                //No additional action is required. This is just a platform
                                                //  for variable declarations without assignment.
                                            }
                                        .)
.

Function<out AstGetSet function>
                                (.  function = null; string id; .)
=
    Id<out id>                  (.  if(!target.Symbols.ContainsKey(id))
                                    {
                                        function = new AstUnresolved(this, id);
                                    }
                                    else
                                    {
                                        if(isOuterVariable(id))
                                            target.RequireOuterVariable(id);
                                        SymbolEntry sym = target.Symbols[id];
                                        if(isKnownMacro(sym)) 
                                        {
                                            function = new AstMacroInvocation(this, sym.Id);
                                        } 
                                        else
                                        {
                                            function = new AstGetSetSymbol(this, sym.Id, sym.Interpretation);
                                        }
                                    }
                                .)
    Arguments<function.Arguments>    
.

StaticCall<out AstGetSetStatic staticCall>
                                (.  IAstType typeExpr;
                                    string memberId;
                                    staticCall = null;
                                .)
=
    ExplicitTypeExpr<out typeExpr>
    dot Id<out memberId>        (.  staticCall = new AstGetSetStatic(this, PCall.Get, typeExpr, memberId); .)
    Arguments<staticCall.Arguments>
.

/*
StaticCall<out AstGetSetStatic staticCall>
                                (.  string id = "";
                                    System.Text.StringBuilder idBuilder = new System.Text.StringBuilder();
                                    bool staticPrefix = false;
                                .)
=

    [   doublecolon             (.  staticPrefix = true; .)
    ]   Ns<out id>              (.  idBuilder.Append(id); .)
    {   Ns<out id>              (.  idBuilder.Append("."+id); .)
    }
    Id<out id>                  (.  staticCall = createStaticCall(idBuilder.ToString(), id, staticPrefix); .)
    Arguments<staticCall.Arguments> 
. // */
                                    //Fallback in case of a syntax error to avoid NullReferenceExceptions
ExplicitLabel<AstBlock block>   (.  string id = "--\\NotAnId\\--"; .)
=
    (   Id<out id> colon
    |   lid                     (.  id = cache(t.val.Substring(0,t.val.Length-1)); .)
    )                           (.  block.Statements.Add(new AstExplicitLabel(this, id)); .)
.

ExplicitGoTo<AstBlock block>    (.  string id; .)
=
    goto
    Id<out id>                  (.  block.Statements.Add(new AstExplicitGoTo(this, id)); .)
.

Assignment<AstGetSet lvalue, out AstNode node>
                                (.  IAstExpression expr = null;
									BinaryOperator setModifier = BinaryOperator.None;
									IAstType T;
									node = lvalue;
								.)
=
(
	(   ( assign /*| appendleft*/ ) (.  setModifier = BinaryOperator.None; .)
	|   plus assign             (.  setModifier = BinaryOperator.Addition; .)
	|   minus assign            (.  setModifier = BinaryOperator.Subtraction; .)
	|   times assign            (.  setModifier = BinaryOperator.Multiply; .)
	|   div assign              (.  setModifier = BinaryOperator.Division; .)
	|   bitAnd assign           (.  setModifier = BinaryOperator.BitwiseAnd; .)
	|   bitOr assign            (.  setModifier = BinaryOperator.BitwiseOr; .)
	|	coalescence assign		(.	setModifier = BinaryOperator.Coalescence; .)
	)   Expr<out expr>        //(.	expr = expr; .)
	
|	(	tilde assign			(.	setModifier = BinaryOperator.Cast; .)
	)	TypeExpr<out T>			(.	expr = T; .)
)								
								(.  lvalue.Arguments.Add(expr);
									lvalue.Call = PCall.Set; 
									if(setModifier != BinaryOperator.None)
									    node = AstModifyingAssignment.Create(this,setModifier,lvalue);
								.)
.

Condition<AstBlock block>
                                (. IAstExpression expr = null; bool isNegative = false; .)
=
    (   if                      (.  isNegative = false; .)
    |   unless                  (.  isNegative = true; .)
    )
    
    lpar Expr<out expr> rpar    (.  AstCondition cond = new AstCondition(this, expr, isNegative);
                                    target.BeginBlock(cond.IfBlock);
                                .)
    
    StatementBlock<cond.IfBlock> 
                                (.  target.EndBlock(); .)

    
    [   else                    (.  target.BeginBlock(cond.ElseBlock); .)
        StatementBlock<cond.ElseBlock> 
                                (.  target.EndBlock(); .)
    ]                           (.  block.Add(cond); .)
.

WhileLoop<AstBlock block>
                                (.  AstWhileLoop loop = null;
                                    bool isPositive = true; 
                                .)
=
(   (   while  | until          (.  isPositive = false; .)    
    )                           (.  loop = new AstWhileLoop(this, true, isPositive); .)
    lpar Expr<out loop.Condition> rpar
                                (.  target.BeginBlock(loop.Block); .)
    StatementBlock<loop.Block> 
    
|   do                          (.  AstLoopBlock loopBody = new AstLoopBlock(this, null, "while"); 
                                    target.BeginBlock(loopBody);
                                .)
    StatementBlock<loopBody>
    (   while  | until          (.  isPositive = false; .)    
    )                           (.  loop = new AstWhileLoop(this, false, isPositive); 
                                    loop.Block = loopBody;
                                .)
    lpar Expr<out loop.Condition> rpar
)                               (.  target.EndBlock(); block.Add(loop); .)
.

ForLoop<AstBlock block>         (.  AstForLoop loop;
                                .)
=
    for                         (.  loop = new AstForLoop(this); target.BeginBlock(loop.Block); .)
    lpar StatementBlock<loop.Initialize>
    (
		do StatementBlock<loop.NextIteration> 
                                (.  loop.IsPrecondition = false; .)
        (   while
        |   until               (.  loop.IsPositive = false; .)
        )
        Expr<out loop.Condition>
    |   [   while
        |   until               (.  loop.IsPositive = false; .)
        ]       
        Expr<out loop.Condition> 
        semicolon
        SimpleStatement<loop.NextIteration>
    )
    rpar
    StatementBlock<loop.Block>  (.  target.EndBlock(); block.Add(loop); .) // */
.

ForeachLoop<AstBlock block>
=
    foreach                      (.  AstForeachLoop loop = new AstForeachLoop(this);
                                     target.BeginBlock(loop.Block);
                                 .)
    lpar
    GetCall<out loop.Element> 
    in 
    Expr<out loop.List> 
    rpar
    StatementBlock<loop.Block>
                                (.  target.EndBlock();
                                    block.Add(loop); 
                                .) 
.

GetCall<out AstGetSet complex>
                                (.  AstGetSet getMember = null; bool isDeclaration; .)
=
    GetInitiator<out complex, out isDeclaration>
    { GetSetExtension<complex, out getMember> }
    
                                (.  if(getMember != null) 
                                    {
                                        complex = getMember; 
                                    }
                                    else
                                    {
                                        AstGetSetSymbol symbol = complex as AstGetSetSymbol;
                                        if(symbol != null && InterpretationIsVariable(symbol.Interpretation) && isDeclaration)
                                        {
                                            symbol.Interpretation = InterpretAsObjectVariable(symbol.Interpretation);
                                            complex = symbol;
                                        }                                        
                                    } .)
.

Return<AstBlock block>          (.  AstReturn ret = null; 
                                    AstExplicitGoTo jump = null; 
                                    IAstExpression expr = null; 
                                    AstLoopBlock bl = target.CurrentLoopBlock;
                                .)
=
(   
    (
        return                  (.  ret = new AstReturn(this, ReturnVariant.Exit); .)
    |   yield                   (.  ret = new AstReturn(this, ReturnVariant.Continue); .)
    )
    [   Expr<out expr>          (.  ret.Expression = expr; .)
    |   assign                  (.  ret.ReturnVariant = ReturnVariant.Set; .)
        Expr<out expr>          (.  ret.Expression = expr; .)
                                (.  SemErr("Return value assignment is no longer supported. You must use local variables instead."); .)
    ]
|   break                       (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Break); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.BreakLabel);
                                .)
|   continue                    (.  if(bl == null)
                                        ret = new AstReturn(this, ReturnVariant.Continue); 
                                    else
                                        jump = new AstExplicitGoTo(this, bl.ContinueLabel);
                                .)
)                               (.  block.Add((AstNode)ret ?? (AstNode)jump); .)
.

NestedFunction<AstBlock block>
                                (.  PFunction func; .)
=
    FunctionDefinition<out func>
                                (.  
                                    string logicalId = func.Meta[PFunction.LogicalIdKey];
                                    func.Meta[PFunction.ParentFunctionKey] = target.Function.Id;
                                    string physicalId = func.Id;
                                    
                                    CompilerTarget ft = FunctionTargets[func];
                                    AstGetSetSymbol setVar = new AstGetSetSymbol(this, PCall.Set, logicalId, SymbolInterpretations.LocalObjectVariable);
                                    if(func.Meta[PFunction.LazyKey].Switch)
                                    {
                                        //Capture environment by value                                        
                                        var ps = ft.ToCaptureByValue(let_bindings(ft));
                                        ft._DetermineSharedNames(); //Need to re-determine shared names since
                                                                    // ToCaptureByValue does not automatically modify shared names
                                        var clos = new AstCreateClosure(this, func.Id);
                                        var callStub = new AstIndirectCall(this, clos);
                                        callStub.Arguments.AddRange(ps(this));
                                        setVar.Arguments.Add(callStub);
                                    }
                                    else if(ft.OuterVariables.Count > 0)
                                    {                                        
                                        setVar.Arguments.Add( new AstCreateClosure(this, physicalId) );                                        
                                    }
                                    else
                                    {
                                        setVar.Arguments.Add( new AstGetSetReference(this, physicalId, SymbolInterpretations.Function) );
                                    }
                                    block.Add(setVar);
                                .)
.

LetBindingStmt<AstBlock block>
=
    let LetBinder<block> { comma LetBinder<block> }
.

LetBinder<AstBlock block>
                                (.  string id = null;
                                    IAstExpression thunk;
                                .)
=
    Id<out id>                  (.  //Declare local "let" variable
                                    SmartDeclareLocal(id, SymbolInterpretations.LocalObjectVariable);
                                    mark_as_let(target.Function, id);
                                    if(la.kind == _assign)
                                        _inject(_lazy,"lazy"); 
                                .)
    [   assign                      
        LazyExpression<out thunk>   
                                (.  
                                    //Assign thunk to that variable
                                    var assign = new AstGetSetSymbol(this, PCall.Set, id, SymbolInterpretations.LocalObjectVariable);
                                    assign.Arguments.Add(thunk);
                                    block.Add(assign);
                                .)
    ]
.

TryCatchFinally<AstBlock block>
                                (.  AstTryCatchFinally a = new AstTryCatchFinally(this); .)
=
    try                         (.  target.BeginBlock(a.TryBlock); .)
    lbrace
    {   Statement<a.TryBlock>
    }
    rbrace                      (. target.EndBlock(); .)
    [	catch                   (. target.BeginBlock(a.CatchBlock); .)
		(   lpar
			GetCall<out a.ExceptionVar>
			rpar
	    |                       (.  SemErr(la,"catch-clauses that don't store the exception are illegal."); .)
		)
		lbrace
		{   Statement<a.CatchBlock>
		}
		rbrace		            (.  target.EndBlock(); .)
	    
		[
			finally             (.  target.BeginBlock(a.FinallyBlock); .)
			lbrace
			{   Statement<a.FinallyBlock>
			}
			rbrace              (.  target.EndBlock(); .)
		]
		
	|	finally                 (.  target.BeginBlock(a.FinallyBlock); .)
		lbrace
		{   Statement<a.FinallyBlock>
		}
		rbrace                  (.  target.EndBlock(); .)
		
		[	                    (.  target.BeginBlock(a.CatchBlock); .)
		    catch
			(   lpar
				GetCall<out a.ExceptionVar>
				rpar
			|                   (.  SemErr(la,"catch-clauses that don't store the exception are illegal."); .)
			)
			lbrace
			{   Statement<a.CatchBlock>
			}
			rbrace
			                    (.  target.EndBlock(); .)
		]
	]                       
                                (.  block.Add(a); .)
.

Throw<AstBlock block>
                                (.  AstThrow th; .)
=
	ThrowExpression<out th>
                                (.  block.Add(th); .)
.                                

Using<AstBlock block>
                                (.  AstUsing use = new AstUsing(this); .)
=
    uusing lpar Expr<out use.Expression> rpar
                                (.  target.BeginBlock(use.Block); .)
    StatementBlock<use.Block>
                                (.  target.EndBlock();
                                    block.Add(use); 
                                .)
.

Arguments<ArgumentsProxy args>
                                (.  
									IAstExpression expr;
                                .)
=
	[
		lpar
		[	Expr<out expr>      (.  args.Add(expr); .)
			{	WEAK comma
				Expr<out expr>  (.  args.Add(expr); .)
			}
		]
		rpar
	]
								(.	args.RememberRightAppendPosition(); .)
	[
		appendleft
		(
			IF(la.kind == _lpar && (!isLambdaExpression()))
			lpar
			[	Expr<out expr>	(.  args.Add(expr); .)
				{	comma
					Expr<out expr>	
								(.  args.Add(expr); .)
				}
			]
			rpar
		|	Expr<out expr>		(.  args.Add(expr); .)
		)
	]
.
#file:D:\DotNetProjects\Prexonite-Hg\prx-assembla-hg\Prexonite\Compiler\Grammar\Footer.atg#
/*
 * Prexonite, a scripting engine (Scripting Language -> Bytecode -> Virtual Machine)
 *  Copyright (C) 2007  Christian "SealedSun" Klauser
 *  E-mail  sealedsun a.t gmail d.ot com
 *  Web     http://www.sealedsun.ch/
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  Please contact me (sealedsun a.t gmail do.t com) if you need a different license.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

END Prexonite.#file:default#

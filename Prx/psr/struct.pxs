var struct\ordinalIc [is compiler;];
build does struct\ordinalIc = System::StringComparison.OrdinalIgnoreCase;

build does require(@"psr\macro.pxs");

macro struct\as_macro as struct()
{
    var CTORID = Prexonite::Compiler::StructHook.CtorId;
    var PRIVATEKEY = Prexonite::Compiler::StructHook.PrivateKey;
    var STRUCTID = Prexonite::Compiler::StructHook.StructId;
    var LOGICALIDKEY = Prexonite::PFunction.LogicalIdKey;
    var PARENTFUNCTIONKEY = Prexonite::PFunction.ParentFunctionKey;

    function getId(g) =
        if(g.Meta.ContainsKey(STRUCTID))
            g.Meta[STRUCTID].Text
        else if(g.Meta.ContainsKey(LOGICALIDKEY))
            g.Meta[LOGICALIDKEY].Text
        else
            null;
        ;
        
    var parentId = context.Function.Id;
    var methods = context.Application.Functions
        >> where(f => 
            f
                .Meta[PARENTFUNCTIONKEY]
                .Text
                .Equals(parentId, struct\ordinalIc)            
            And Not f.Meta[PRIVATEKEY].Switch)
        >> map(f => 
        {
			if(Not f.Meta.ContainsKey(LOGICALIDKEY))
				return (null: null);
			return (getId(f): f.Meta[LOGICALIDKEY].Text);            
        })
        >> where(fcf => fcf.Value is not Null and fcf.Key is not Null);
        
    var block = ast("BlockExpression");
    var structV = tempalloc;
    
    //assign new structure
    var assignStructure = ast\lvar(SI.set, structV);
    assignStructure.Arguments.Add(ast\new("Structure"));
    block.Add(assignStructure);
    
    //assign ctorId
    var assignCtorId = ast\member(ast\lvar(SI.get, structV), SI.get,"\\");
    assignCtorId.Arguments.Add(ast\const(CTORID));
    assignCtorId.Arguments.Add(ast\const(parentId));
    block.Add(assignCtorId);
    
    //assign methods
    foreach(var method in methods)
    {
        var addMethod = ast\member(ast\lvar(SI.get, structV), SI.get, @"\\");
        addMethod.Arguments.Add(ast\const(method.Key));
        addMethod.Arguments.Add(ast\lvar(SI.get, method.Value));
        block.Add(addMethod);
    }
    
    //return struct
    block.Expression = ast\lvar(SI.get, structV);
    tempfree(structV);
    return block;
}